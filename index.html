<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>íƒœì–‘ê³„ + PETS / SAC RL</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #051022;
      color: #e9ecff;
      font: 13px/1.45 system-ui;
    }
    #app {
      position: fixed;
      inset: 0;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    .ui {
      position: fixed;
      left: 12px;
      top: 12px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
      padding: 10px;
      border-radius: 10px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      max-width: 96vw;
      z-index: 10;
    }
    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .btn {
      cursor: pointer;
      padding: 6px 9px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color: #e9ecff;
    }
    input[type=range] { width: 200px; }
    input[type=number],
    input[type=text] { width: 70px; }
    select {
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(0,0,0,.3);
      color: #e9ecff;
      font-size: 12px;
    }
    .small {
      font-size: 11px;
      opacity: .85;
    }
    .hud {
      position: fixed;
      right: 10px;
      top: 10px;
      padding: 8px 10px;
      background: rgba(0,0,0,.45);
      border-radius: 8px;
      font-family: monospace;
      font-size: 11px;
      max-width: 260px;
      line-height: 1.3;
      z-index: 10;
    }
    /* ê²°ê³¼ ëª¨ë‹¬ ì˜¤ë²„ë ˆì´ */
    #resultOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    #resultModal {
      background: #0b1220;
      border: 1px solid rgba(255,255,255,.3);
      border-radius: 14px;
      padding: 20px 36px;
      box-shadow: 0 18px 40px rgba(0,0,0,.7);
      text-align: center;
      min-width: 260px;
    }
    #resultModal h2 {
      margin: 0 0 6px;
      font-size: 20px;
    }
    #resultModal .percent {
      font-size: 32px;
      font-weight: bold;
      margin: 4px 0 12px;
      color: #ffe066;
    }
    #sideLog {
      position: fixed;
      right: 10px;
      bottom: 10px;
      padding: 8px 10px;
      background: rgba(0,0,0,.4);
      border-radius: 8px;
      font-size: 11px;
      max-width: 260px;
      max-height: 30vh;
      overflow-y: auto;
      z-index: 10;
    }
    #sideLog h3 {
      margin: 0 0 4px;
      font-size: 12px;
      opacity: .9;
    }
  </style>
</head>
<body>
<div id="app"></div>

<!-- UI íŒ¨ë„ -->
<div class="ui">
  <div class="row">
    <label for="speed">ì†ë„ (ì¼/ì´ˆ)</label>
    <input id="speed" type="range" min="0" max="500" step="0.1" value="0.3" />
    <input id="speedNum" type="text" value="0.3" />
    <button class="btn" data-rate="1">1Ã—</button>
    <button class="btn" data-rate="10">10Ã—</button>
    <button class="btn" data-rate="100">100Ã—</button>
  </div>

  <div class="row">
    <label for="focusSel">ì¤‘ì‹¬ì </label>
    <select id="focusSel">
      <option>ììœ (ìˆ˜ë™)</option>
      <option selected>íƒœì–‘</option>
      <option>ìˆ˜ì„±</option>
      <option>ê¸ˆì„±</option>
      <option>ì§€êµ¬</option>
      <option>ë‹¬</option>
      <option>í™”ì„±</option>
      <option>ëª©ì„±</option>
      <option>í† ì„±</option>
      <option>ì²œì™•ì„±</option>
      <option>í•´ì™•ì„±</option>
      <option>ëª…ì™•ì„±</option>
    </select>
    <label>
      <input id="axisToggle" type="checkbox" checked />
      ìì „ì¶• í‘œì‹œ
    </label>
    <label>
      <input id="gravToggle" type="checkbox" />
      ì¤‘ë ¥ì¥ í‘œì‹œ(í–‰ì„± í¬í•¨)
    </label>
  </div>

  <div class="row">
    <button class="btn" id="spawnShip">ìš°ì£¼ì„  ì†Œí™˜ (PETS/SAC ë¹„êµ)</button>
    <button class="btn" id="delShip">ìš°ì£¼ì„  ì‚­ì œ(ìˆ˜ë™)</button>
    <button class="btn" id="spawnAst">ì†Œí–‰ì„± êµ° ì†Œí™˜</button>
    <button class="btn" id="spawnField">ì—­ì¥ ì´ë²¤íŠ¸</button>
    <button class="btn" id="clearObjs">ëª¨ë‘ ì‚­ì œ</button>
  </div>

  <!-- ğŸ”¥ RL ê´€ë ¨ UI -->
  <div class="row">
    <label for="autoTarget">RL ëª©í‘œ</label>
    <select id="autoTarget">
      <option>ì§€êµ¬</option>
      <option>ë‹¬</option>
      <option>í™”ì„±</option>
      <option>ëª©ì„±</option>
      <option>í† ì„±</option>
      <option>ì²œì™•ì„±</option>
      <option>í•´ì™•ì„±</option>
      <option>ëª…ì™•ì„±</option>
      <option>íƒœì–‘</option>
      <option>ìˆ˜ì„±</option>
      <option>ê¸ˆì„±</option>
    </select>
    <button class="btn" id="resetRL">RL ìš°ì£¼ì„  ë¦¬ì…‹</button>
  </div>

  <div class="row small">
    <label><input id="petsEnable" type="checkbox" checked /> PETS</label>
    <label><input id="sacEnable" type="checkbox" checked /> SAC</label>
    <span>
      PETS F:<span id="petsFuel">-</span> R:<span id="petsRew">0</span> |
      SAC F:<span id="sacFuel">-</span> R:<span id="sacRew">0</span>
    </span>
  </div>

   <!-- PETS vs SAC ì„ íƒ ë²„íŠ¼ -->
  <div class="row" id="choiceRow" style="display:none;">
    <button class="btn" id="choosePETS">PETS ì‚¬ìš©</button>
    <button class="btn" id="chooseSAC">SAC ì‚¬ìš©</button>
  </div>

  <div class="row small">
    <div>
      ì‹œì‘ ì‹œê°:
      <span id="startTime">2025-01-01 00:00:00</span>
    </div>
    <div class="small">â€¢ ì¢Œí´ë¦­: íšŒì „ Â· íœ : ì¤Œ Â· ìš°í´ë¦­: íŒ¬</div>
  </div>
</div>

<div class="hud" id="hudBox">
  PETS / SAC ìƒíƒœ<br>
  --------------------------<br>
  ì´ˆê¸°í™” ì¤‘...
</div>

<!-- ê²°ê³¼ ëª¨ë‹¬ -->
<div id="resultOverlay">
  <div id="resultModal">
    <h2>ë¹„í–‰ ê²°ê³¼</h2>
    <div id="resultLine"></div>
    <div class="percent" id="resultPercent">ì„±ê³µë¥  0%</div>
    <div style="font-size:12px; opacity:.8;">(ëª¨ë‹¬ ë°”ê¹¥ì„ í´ë¦­í•˜ë©´ ë‹«íˆê³  ì´ˆê¸°í™”)</div>
  </div>
</div>

<!-- ê²°ê³¼ ë¡œê·¸ -->
<div id="sideLog">
  <h3>ê²°ê³¼ ë¡œê·¸</h3>
  <div id="logContent"></div>
</div>

<script src="./three.min.js"></script>
<script>
/*
 * ì „ì²´ ê¸°ëŠ¥ ìš”ì•½
 *  - ì¼€í”ŒëŸ¬ ë°©ì •ì‹ì„ ì´ìš©í•œ íƒ€ì› ê¶¤ë„ (ì´ì‹¬ë¥  í¬í•¨)
 *  - í–‰ì„±ë³„ ëŒ€í‘œ ìœ„ì„± ìƒì„± + í† ì„± ê³ ë¦¬
 *  - ë¼ê·¸ë‘ì£¼ í¬ì¸íŠ¸(L1, L2, L4, L5) ì‹œê°í™”
 *  - ì†Œí–‰ì„± êµ° (ìš°ì£¼ì„  ë°©í–¥ìœ¼ë¡œ ë‚ ì•„ì˜¤ëŠ” êµ°ì§‘) ìƒì„±
 *  - ìš°ì£¼ì„ /ì†Œí–‰ì„±: ì¤‘ë ¥ ì˜í–¥ì„ ë°›ëŠ” ë™ì  ê°ì²´ (velocity verlet)
 *  - PETS / SAC ë‘ ê°€ì§€ "ê°•í™”í•™ìŠµ ìŠ¤íƒ€ì¼" ìë™ ì¡°í–¥ ì •ì±…
 *  - Observation í™•ì¥ + ë³´ìƒ ì‹œê°í™” + ì¶”ë ¥ íŒŒí‹°í´
 */

/* -------------------------------------------------
 * ê¸°ë³¸ Three.js ì„¤ì •
 * ------------------------------------------------- */
const app = document.getElementById('app');

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(app.clientWidth, app.clientHeight);
renderer.setClearColor(0x051022, 1);
app.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  60,
  app.clientWidth / app.clientHeight,
  0.1,
  20000
);

// ì¹´ë©”ë¼ ê¶¤ë„ íŒŒë¼ë¯¸í„°
let radius = 260;
let phi    = THREE.MathUtils.degToRad(28);
let theta  = THREE.MathUtils.degToRad(40);

const manualTarget = new THREE.Vector3(0, 0, 0);
let focusTarget = null;

// í´ë¦­ ê¸°ë°˜ ìƒì„±ìš© ì „ì—­
const raycaster   = new THREE.Raycaster();
const mouse       = new THREE.Vector2();
const clickPlane  = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // y = 0
let pendingSpawn  = null;  // { type: 'ship' | 'asteroid' }

function getClickPositionOnPlane(e) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);

  const pos = new THREE.Vector3();
  const hit = raycaster.ray.intersectPlane(clickPlane, pos);

  if (!hit) {
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    pos.copy(camera.position).add(dir.multiplyScalar(30));
  }
  return pos;
}

function getTarget() {
  return focusTarget
    ? focusTarget.getWorldPosition(new THREE.Vector3())
    : manualTarget;
}

function updateCam() {
  const t = getTarget();

  const x = t.x + radius * Math.sin(phi) * Math.cos(theta);
  const y = t.y + radius * Math.cos(phi);
  const z = t.z + radius * Math.sin(phi) * Math.sin(theta);

  camera.position.set(x, y, z);
  camera.lookAt(t);
}
updateCam();

/* -------------------------------------------------
 * ì‹œë®¬ë ˆì´ì…˜ ì‹œê°„ / ìƒìˆ˜
 * ------------------------------------------------- */
let simDate   = new Date('2025-01-01T00:00:00Z');
let timeScale = 0.3;       // ì¼/ì´ˆ (ê¸°ë³¸ ì†ë„)
const G       = 5e-6;      // ë™ì  ê°ì²´ìš© ì¤‘ë ¥ ìƒìˆ˜
const MAX_ACC = 0.3;       // í•œ ë²ˆì— ë„ˆë¬´ í° ê°€ì†ë„ ë°©ì§€

scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const sunLight = new THREE.PointLight(0xffffff, 2.2, 0, 2);
scene.add(sunLight);

/* -------------------------------------------------
 * ì „ì—­ ì»¨í…Œì´ë„ˆ
 * ------------------------------------------------- */
const bodies          = {};  // ì´ë¦„ -> ì²œì²´ ì •ë³´
const heavyBodies     = [];  // ì¤‘ë ¥ì— ì°¸ì—¬í•˜ëŠ” ì²œì²´
const axisList        = [];  // ìì „ì¶• ë©”ì‰¬
const dynamicObjects  = [];  // ìš°ì£¼ì„ /ì†Œí–‰ì„±
const lagrangeHelpers = [];  // ë¼ê·¸ë‘ì£¼ í¬ì¸íŠ¸ í‘œì‹œ
const warpFields      = [];  // â˜… ê³µê°„ ì™œê³¡ í•„ë“œ(ì—­ì¥) ëª©ë¡

const SIZE = 1;
const DIST = 1;

/* -------------------------------------------------
 * ìœ í‹¸ í•¨ìˆ˜
 * ------------------------------------------------- */
function mkRing(r, color = 0x2a3355, opacity = 0.8) {
  const geo = new THREE.RingGeometry(r - 0.12, r + 0.12, 256);
  geo.rotateX(-Math.PI / 2);
  const mat = new THREE.MeshBasicMaterial({
    color,
    transparent: true,
    opacity,
    side: THREE.DoubleSide,
  });
  return new THREE.Mesh(geo, mat);
}

function mkAxis(len) {
  const geo = new THREE.CylinderGeometry(0.04, 0.04, len, 8);
  const mat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.75,
  });
  const cyl = new THREE.Mesh(geo, mat);
  cyl.position.y = 0;
  return cyl;
}

/* -------------------------------------------------
 * ì²œì²´ ìƒì„± í•¨ìˆ˜
 * ------------------------------------------------- */
function createBody({
  name,
  parent          = scene,
  size            = 1,
  color           = 0xffffff,
  orbitDist       = 0,
  orbitPeriodDays = 0,
  rotPeriodHours  = 24,
  axialTiltDeg    = 0,
  ecc             = 0,
  orbitInc        = 0,
  massScale       = 1,
  showOrbit       = true,
  primary         = null,
} = {}) {
  // ê³µì „ìš© pivot
  const pivot = new THREE.Group();
  parent.add(pivot);
  pivot.rotation.x = THREE.MathUtils.degToRad(orbitInc || 0);

  // ìì „ì¶• ê¸°ìš¸ê¸°ìš© ê·¸ë£¹
  const spin = new THREE.Group();
  spin.rotation.z = THREE.MathUtils.degToRad(axialTiltDeg || 0);
  pivot.add(spin);

  // í–‰ì„± ë©”ì‰¬
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(size * SIZE, 32, 32),
    new THREE.MeshStandardMaterial({
      color,
      roughness: 0.85,
    })
  );
  spin.add(mesh);

  // ìì „ì¶•
  const axis = mkAxis(size * 3);
  spin.add(axis);
  axisList.push(axis);

  const mass = Math.max(1e-6, Math.pow(size, 3) * massScale);

  const body = {
    name,
    pivot,
    spin,
    mesh,
    orbitDist: orbitDist * DIST,
    orbitPeriodDays,
    rotPeriodHours,
    mass,
    ecc,
    orbitInc,
    primary,
    meanAnomaly: Math.random() * Math.PI * 2,
    semiMajor: orbitDist * DIST,
  };

  bodies[name] = body;
  heavyBodies.push(body);

  return body;
}

/* -------------------------------------------------
 * í–‰ì„± ë°ì´í„° ì •ì˜
 * ------------------------------------------------- */
const defs = [
  { name: 'íƒœì–‘', size: 10,   dist: 0,   orbit: 0,       rotH: 25.38,           tilt: 7.25,  ecc: 0,          orbitInc: 0,    massScale: 1e6,   color: '#ffd54a' },
  { name: 'ìˆ˜ì„±', size: 0.9,  dist: 16,  orbit: 87.969,  rotH: 58.6462 * 24,    tilt: 0.01,  ecc: 0.205630,   orbitInc: 7.005, massScale: 0.055, color: '#555555' },
  { name: 'ê¸ˆì„±', size: 1.1,  dist: 22,  orbit: 224.701, rotH: -243.0185 * 24,  tilt: 177.36, ecc: 0.006772, orbitInc: 3.394, massScale: 0.815, color: '#fff7c4' },
  { name: 'ì§€êµ¬', size: 1.2,  dist: 30,  orbit: 365.256, rotH: 0.99726963 * 24, tilt: 23.44, ecc: 0.01671123, orbitInc: 0.0,   massScale: 1,     color: '#3a82ff' },
  { name: 'í™”ì„±', size: 0.9,  dist: 38,  orbit: 686.98,  rotH: 1.02595676 * 24, tilt: 25.19, ecc: 0.0933941, orbitInc: 1.85,  massScale: 0.107, color: '#d14b3a' },
  { name: 'ëª©ì„±', size: 4.0,  dist: 60,  orbit: 4332.59, rotH: 0.41354 * 24,    tilt: 3.13,  ecc: 0.04839266, orbitInc: 1.305, massScale: 318,   color: '#e6b56a' },
  { name: 'í† ì„±', size: 3.6,  dist: 78,  orbit: 10756.2, rotH: 0.44401 * 24,    tilt: 26.73, ecc: 0.055723,   orbitInc: 2.485, massScale: 95,    color: '#d2b48c' },
  { name: 'ì²œì™•ì„±', size: 2.9, dist: 96,  orbit: 30707.49, rotH: -0.71833 * 24, tilt: 97.77, ecc: 0.04565, orbitInc: 0.77,  massScale: 14,    color: '#6ecff6' },
  { name: 'í•´ì™•ì„±', size: 2.8, dist: 112, orbit: 60223.35, rotH: 0.67125 * 24,  tilt: 28.32, ecc: 0.00859048, orbitInc: 1.769, massScale: 17,   color: '#264bff' },
  { name: 'ëª…ì™•ì„±', size: 0.5, dist: 140, orbit: 90560,   rotH: -6.3872 * 24,   tilt: 122.53, ecc: 0.24883, orbitInc: 17.14, massScale: 0.0022, color: '#bbaea0' },
];

// í–‰ì„± ë° ìƒíƒœ ë°°ì—´
const planetStates = [];
for (const p of defs) {
  const body = createBody({
    name: p.name,
    size: p.size,
    orbitDist: p.dist,
    orbitPeriodDays: p.orbit,
    rotPeriodHours: p.rotH,
    axialTiltDeg: p.tilt,
    ecc: p.ecc,
    orbitInc: p.orbitInc,
    massScale: p.massScale,
    color: p.color,
  });
  planetStates.push({ def: p, node: body, moons: [] });
}

/* -------------------------------------------------
 * í–‰ì„± ê¶¤ë„ íƒ€ì› ë¼ì¸
 * ------------------------------------------------- */
const planetOrbitLines = [];

function createOrbitLine({
  a,
  e,
  iDeg,
  omegaDeg,
  OmegaDeg,
  color = 0xffffff,
  opacity = 0.25,
  segments = 360,
}) {
  const pts = [];
  const iRad      = THREE.MathUtils.degToRad(iDeg || 0);
  const omegaRad  = THREE.MathUtils.degToRad(omegaDeg || 0);
  const OmegaRad  = THREE.MathUtils.degToRad(OmegaDeg || 0);

  const n = segments;

  for (let k = 0; k <= n; k++) {
    const nu = (2 * Math.PI * k) / n;

    const r = (a * (1 - e * e)) / (1 + e * Math.cos(nu));

    const v = new THREE.Vector3(
      r * Math.cos(nu),
      0,
      r * Math.sin(nu)
    );

    v.applyAxisAngle(new THREE.Vector3(0, 1, 0), omegaRad);
    v.applyAxisAngle(new THREE.Vector3(1, 0, 0), iRad);
    v.applyAxisAngle(new THREE.Vector3(0, 1, 0), OmegaRad);

    pts.push(v);
  }

  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const mat = new THREE.LineBasicMaterial({
    color,
    transparent: true,
    opacity,
  });

  const line = new THREE.Line(geo, mat);
  scene.add(line);
  return line;
}

for (const ps of planetStates) {
  const node = ps.node;
  if (node.orbitPeriodDays <= 0) continue;

  const name = ps.def.name;

  let col = 0x444c66;
  if (name === 'ìˆ˜ì„±') col = 0xaaaaaa;
  else if (name === 'ê¸ˆì„±') col = 0xffc966;
  else if (name === 'ì§€êµ¬') col = 0x3a82ff;
  else if (name === 'í™”ì„±') col = 0xff5533;
  else if (name === 'ëª©ì„±') col = 0xe6b56a;
  else if (name === 'í† ì„±') col = 0xd2b48c;
  else if (name === 'ì²œì™•ì„±') col = 0x6ecff6;
  else if (name === 'í•´ì™•ì„±') col = 0x264bff;
  else if (name === 'ëª…ì™•ì„±') col = 0xbbaea0;

  const line = createOrbitLine({
    a: node.semiMajor,
    e: node.ecc || 0,
    iDeg: node.orbitInc || 0,
    omegaDeg: 0,
    OmegaDeg: 0,
    color: col,
    opacity: 0.25,
    segments: 400,
  });

  planetOrbitLines.push(line);
}

/* -------------------------------------------------
 * ìœ„ì„± ì¶”ê°€ (ë‹¬ + ì£¼ìš” ìœ„ì„±)
 * ------------------------------------------------- */
(() => {
  const earth = bodies['ì§€êµ¬'];
  if (!earth) return;

  const moon = createBody({
    name: 'ë‹¬',
    parent: earth.pivot,
    size: 0.35,
    orbitDist: 4,
    orbitPeriodDays: 27.322,
    rotPeriodHours: 655.7,
    axialTiltDeg: 6.68,
    massScale: 0.0123,
    color: '#cfd6ff',
    showOrbit: false,
  });

  planetStates
    .find((x) => x.def.name === 'ì§€êµ¬')
    .moons.push({
      ...moon,
      orbitDist: 4,
      orbitPeriodDays: 27.322,
      orbitalAngle: Math.random() * Math.PI * 2,
    });
})();

const majorMoons = {
  'ëª©ì„±': [
    ['ì´ì˜¤',      0.7,  1.769, '#ffd1a8'],
    ['ìœ ë¡œíŒŒ',    1.3,  3.551, '#cfe8ff'],
    ['ê°€ë‹ˆë©”ë°',  2.1,  7.154, '#e9d5b3'],
    ['ì¹¼ë¦¬ìŠ¤í† ',  3.0, 16.689, '#c2b7a1'],
  ],
  'í† ì„±': [
    ['íƒ€ì´íƒ„',     3.5, 15.95, '#d9c28a'],
    ['ì—”ì…€ë¼ë‘ìŠ¤', 1.1,  1.37, '#dfeaf7'],
  ],
  'ì²œì™•ì„±': [
    ['í‹°íƒ€ë‹ˆì•„', 1.6,  8.7, '#cfe6ff'],
    ['ì˜¤ë² ë¡ ',   2.0, 13.5, '#bfb8a6'],
  ],
  'í•´ì™•ì„±': [
    ['íŠ¸ë¦¬í†¤', 2.1, 5.88, '#98bfff'],
  ],
  'ëª…ì™•ì„±': [
    ['ì¹´ë¡ ', 1.2, 6.387, '#b0a59a'],
  ],
};

for (const ps of planetStates) {
  const name = ps.def.name;
  if (!majorMoons[name]) continue;

  for (const [mName, mDist, mPeriod, mColor] of majorMoons[name]) {
    const moon = createBody({
      name: mName,
      parent: ps.node.pivot,
      size: 0.25,
      color: mColor,
      orbitDist: mDist,
      orbitPeriodDays: mPeriod,
      massScale: 0.01,
      showOrbit: false,
    });

    ps.moons.push({
      ...moon,
      orbitDist: mDist,
      orbitPeriodDays: mPeriod,
      orbitalAngle: Math.random() * Math.PI * 2,
    });
  }
}

// í† ì„± ê³ ë¦¬
(() => {
  const sat = bodies['í† ì„±'];
  if (!sat) return;

  const r = 3.6 * 2;
  const geo = new THREE.RingGeometry(r, r * 1.6, 128);
  geo.rotateX(-Math.PI / 2);
  const mat = new THREE.MeshStandardMaterial({
    color: 0xd8cfae,
    roughness: 0.95,
    transparent: true,
    opacity: 0.6,
    side: THREE.DoubleSide,
  });
  const ring = new THREE.Mesh(geo, mat);
  sat.pivot.add(ring);
})();

/* ========== ì¤‘ë ¥ / ê´€ì¸¡ ========== */
function computeGravitationalAcceleration(pos) {
  const acc = new THREE.Vector3();
  for (const b of heavyBodies) {
    const bp   = b.pivot.getWorldPosition(new THREE.Vector3());
    const rVec = new THREE.Vector3().subVectors(bp, pos);
    const r    = rVec.length();
    if (r === 0) continue;
    const baseR = b.mesh.geometry.parameters.radius || 1;
    let maxRangeMul = 16;
    let effMass     = b.mass;
    if (b.name === 'íƒœì–‘') effMass *= 0.0002;
    const rMax = baseR * maxRangeMul;
    if (r > rMax) continue;
    const r2 = Math.max(100, r * r);
    let accMag = (G * effMass) / r2;
    if (accMag > MAX_ACC) accMag = MAX_ACC;
    acc.addScaledVector(rVec.normalize(), accMag);
  }
  return acc;
}
function computePotentialEnergy(pos, mass=1) {
  let pe = 0;
  for (const b of heavyBodies) {
    const bp = b.pivot.getWorldPosition(new THREE.Vector3());
    const r  = bp.distanceTo(pos);
    if (r>0) pe += -G * b.mass * mass / r;
  }
  return pe;
}
function computeCollisionRisk(pos) {
  let risk = 0;
  for (const b of heavyBodies) {
    const bp = b.pivot.getWorldPosition(new THREE.Vector3());
    const r  = bp.distanceTo(pos);
    const baseR = b.mesh.geometry.parameters.radius || 1;
    const safe = baseR * 5;
    if (r < safe) risk = Math.max(risk, (safe - r)/safe);
  }
  return Math.min(1,risk);
}
function getRLTargetPos() {
  const sel = document.getElementById('autoTarget').value;
  const b = bodies[sel];
  if (!b) return new THREE.Vector3(0,0,0);
  return b.pivot.getWorldPosition(new THREE.Vector3());
}
function getObservation(ship) {
  const targetPos = getRLTargetPos();
  const g = computeGravitationalAcceleration(ship.pos);
  const toTarget = new THREE.Vector3().subVectors(targetPos, ship.pos);
  const dist = toTarget.length();
  const vel = ship.vel.clone();
  const ke = 0.5 * ship.mass * vel.lengthSq();
  const pe = computePotentialEnergy(ship.pos, ship.mass);
  const totalE = ke + pe;
  const angMom = ship.pos.clone().cross(vel);
  const collisionRisk = computeCollisionRisk(ship.pos);
  return {pos: ship.pos.clone(), vel, grav: g, toTarget, dist, fuel: ship.fuel,
          kinetic: ke, potential: pe, totalE, angMom, collisionRisk};
}

/* -------------------------------------------------
 * ë™ì  ê°ì²´ (ìš°ì£¼ì„ , ì†Œí–‰ì„±)
 * ------------------------------------------------- */

function getNearestShip(pos) {
  let best = null;
  let bestDist = Infinity;
  for (const o of dynamicObjects) {
    if (o.type !== 'ship') continue;
    const d = o.pos.distanceTo(pos);
    if (d < bestDist) {
      bestDist = d;
      best = o;
    }
  }
  return best;
}

// ğŸ›° ìš°ì£¼ì„  ìŠ¤í° 
function spawnSpaceshipSimple(pos, vel, policyType, color) {
  const geo = new THREE.ConeGeometry(0.3, 0.8, 8);
  geo.rotateX(Math.PI / 2);
  const mat = new THREE.MeshStandardMaterial({ color });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(pos);
  scene.add(mesh);
  const ship = {
    type:'ship',
    mesh,
    pos: mesh.position.clone(),
    vel: vel.clone(),
    mass: 0.05,
    radius: 0.4,
    fuel: 1.0,
    maxThrust: 0.22,   // ì¶œë ¥ í¬ê²Œ â†‘
    lastFuelUsed:0,
    prevGoalDist:null,
    totalReward:0,
    collided:false,
    policyType,
    alive:true
  };
  dynamicObjects.push(ship);
  return ship;
}

function spawnAsteroid(pos, vel) {
  const sBase = Math.random() * 0.6 + 0.2;
  const s = sBase * 0.5;

  const geo = new THREE.DodecahedronGeometry(s, 0);
  const mat = new THREE.MeshStandardMaterial({ color: 0x999999 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(pos);
  scene.add(mesh);

  const obj = {
    type: 'asteroid',
    mesh,
    pos: mesh.position.clone(),
    vel: vel.clone(),
    mass: Math.pow(s, 3) * 0.2,
    radius: s,
    alive: true
  };
  dynamicObjects.push(obj);
  return obj;
}

/* ì†Œí–‰ì„± êµ° ìƒì„± */
function spawnAsteroidSwarm(centerPos, ship) {
  const pos = centerPos.clone();

  let dirToShip = new THREE.Vector3(0, 0, 0);
  if (ship) {
    pos.y = ship.pos.y;
    dirToShip.subVectors(ship.pos, pos);
    if (dirToShip.lengthSq() > 0) dirToShip.normalize();
  }

  const baseSpeed = ship ? 0.25 : 0.0;
  const baseVel = dirToShip.clone().multiplyScalar(baseSpeed);

  spawnAsteroid(pos, baseVel);

  const count = 5 + Math.floor(Math.random() * 2);
  for (let i = 0; i < count; i++) {
    const offset = new THREE.Vector3(
      (Math.random() - 0.5) * 4,
      0,
      (Math.random() - 0.5) * 4
    );
    const p = pos.clone().add(offset);

    let v = baseVel.clone();
    if (ship && baseSpeed > 0) {
      const randomDir = new THREE.Vector3(
        (Math.random() - 0.5) * 0.3,
        (Math.random() - 0.5) * 0.05,
        (Math.random() - 0.5) * 0.3
      );
      v.add(randomDir).multiplyScalar(0.8 + Math.random() * 0.6);
    }
    spawnAsteroid(p, v);
  }
}

/* í­ë°œ ì´í™íŠ¸ */
function explodeAt(pos) {
  const group = new THREE.Group();
  for (let i=0;i<18;i++){
    const geo = new THREE.SphereGeometry(0.06,6,6);
    const mat = new THREE.MeshBasicMaterial({color:0xffaa44});
    const p = new THREE.Mesh(geo,mat);
    p.position.copy(pos);
    p.userData.v = new THREE.Vector3(
      (Math.random()-0.5)*2,
      (Math.random()-0.5)*2,
      (Math.random()-0.5)*2
    ).multiplyScalar(0.6);
    group.add(p);
  }
  scene.add(group);
  const t0 = performance.now();
  const id = setInterval(()=>{
    const dt=(performance.now()-t0)/1000;
    group.children.forEach(ch=>{
      ch.position.addScaledVector(ch.userData.v,0.04);
    });
    if(dt>1.5){
      clearInterval(id);
      scene.remove(group);
    }
  },50);
}

/* ì¶”ë ¥ íŒŒí‹°í´ */
function spawnThrustParticle(ship,dir){
  const geo = new THREE.SphereGeometry(0.15,8,8);
  const mat = new THREE.MeshBasicMaterial({
    color: ship.policyType==="PETS"?0xffdd66:0x66c0ff,
    transparent:true,
    opacity:0.9
  });
  const p = new THREE.Mesh(geo,mat);
  const back = dir.clone().multiplyScalar(-1);
  p.position.copy(ship.pos).addScaledVector(back, ship.radius||0.8);
  p.userData.vel = back.multiplyScalar(0.6);
  p.userData.life=0.6;
  scene.add(p);
  thrustParticles.push(p);
}
function updateThrustParticles(dt){
  for(let i=thrustParticles.length-1;i>=0;i--){
    const p = thrustParticles[i];
    p.userData.life-=dt;
    p.position.addScaledVector(p.userData.vel,dt);
    p.material.opacity = Math.max(0,p.userData.life/0.6);
    if(p.userData.life<=0){
      scene.remove(p);
      thrustParticles.splice(i,1);
    }
  }
}

/* ========== RL ì•¡ì…˜ ì ìš© + PETS/SAC ì •ì±… ========== */
function applyRLAction(ship, action, dt) {
  const dir = action.dir.clone().normalize();
  const thrustOn = !!action.thrustOn;
  const fuelRatio = Math.max(0,Math.min(1,action.fuelRatio ?? 0.5));
  ship.lastFuelUsed=0;
  if(thrustOn && ship.fuel>0){
    const thrustMag = ship.maxThrust*fuelRatio;
    ship.vel.addScaledVector(dir, thrustMag*dt);
    const fuelUsed = fuelRatio*dt*0.9;
    ship.fuel = Math.max(0, ship.fuel-fuelUsed);
    ship.lastFuelUsed = fuelUsed;
    spawnThrustParticle(ship,dir);
  }
}
function stepPETS(ship,dt){
  const obs = getObservation(ship);
  if (obs.dist<1 || ship.fuel<=0.01) return;
  const baseDir = obs.toTarget.clone().normalize();
  let bestScore=-Infinity, bestDir=baseDir.clone();
  const horizon=8, candCount=16;
  for(let i=0;i<candCount;i++){
    const jitter = new THREE.Vector3(
      (Math.random()-0.5)*0.4,
      (Math.random()-0.5)*0.2,
      (Math.random()-0.5)*0.4
    );
    const candDir = baseDir.clone().add(jitter).normalize();
    let pos = obs.pos.clone();
    let vel = obs.vel.clone();
    let score=0;
    for(let t=0;t<horizon;t++){
      const g = computeGravitationalAcceleration(pos);
      vel.addScaledVector(g,dt);
      vel.addScaledVector(candDir, ship.maxThrust*0.5*dt);
      pos.addScaledVector(vel,dt);
      const d = pos.distanceTo(getRLTargetPos());
      score-=d*0.02;
    }
    const risk = computeCollisionRisk(pos);
    score-=risk*3;
    if(score>bestScore){bestScore=score; bestDir.copy(candDir);}
  }
  applyRLAction(ship,{
    thrustOn: obs.dist>1 && ship.fuel>0.02,
    dir:bestDir,
    fuelRatio:0.7
  },dt);
  const progress = (ship.prevGoalDist ?? obs.dist)-obs.dist;
  ship.totalReward += progress*15 - ship.lastFuelUsed*20 - dt*0.4;
  ship.prevGoalDist = obs.dist;
  document.getElementById('petsFuel').textContent=(ship.fuel*100).toFixed(1);
  document.getElementById('petsRew').textContent=ship.totalReward.toFixed(1);
}
function stepSAC(ship,dt){
  const obs = getObservation(ship);
  if (obs.dist<1 || ship.fuel<=0.01) return;
  const toTargetDir = obs.toTarget.clone().normalize();
  const velDir = obs.vel.length()>1e-3 ? obs.vel.clone().normalize() : new THREE.Vector3();
  const gravDir= obs.grav.length()>1e-4 ? obs.grav.clone().normalize() : new THREE.Vector3();
  let baseDir = new THREE.Vector3()
    .addScaledVector(toTargetDir,1.0)
    .addScaledVector(velDir,-0.5)
    .addScaledVector(gravDir,-0.2);
  if(baseDir.length()<1e-3) baseDir = toTargetDir.clone();
  const noise = new THREE.Vector3(
    (Math.random()-0.5)*0.3,
    (Math.random()-0.5)*0.2,
    (Math.random()-0.5)*0.3
  );
  baseDir.add(noise.multiplyScalar(0.3)).normalize();
  applyRLAction(ship,{
    thrustOn: obs.dist>1 && ship.fuel>0.02,
    dir:baseDir,
    fuelRatio:0.5
  },dt);
  const progress = (ship.prevGoalDist ?? obs.dist)-obs.dist;
  ship.totalReward += progress*10 - ship.lastFuelUsed*10 - dt*0.3;
  ship.prevGoalDist = obs.dist;
  document.getElementById('sacFuel').textContent=(ship.fuel*100).toFixed(1);
  document.getElementById('sacRew').textContent=ship.totalReward.toFixed(1);
}

/* ========== PETS/SAC ì˜ˆì¸¡ ê²½ë¡œ ê³„ì‚° ========== */
function predictTrajectory(ship, policyType, steps=140, dt=0.7){
  const pts=[];
  let pos = ship.pos.clone();
  let vel = ship.vel.clone();
  let fuel = ship.fuel;
  for(let i=0;i<steps;i++){
    const targetPos = getRLTargetPos();
    const toTarget  = new THREE.Vector3().subVectors(targetPos,pos);
    const dist      = toTarget.length();
    if (dist<1) break;
    const g = computeGravitationalAcceleration(pos);
    let dir;
    if(policyType==="PETS"){
      const baseDir = toTarget.clone().normalize();
      const jitter = new THREE.Vector3(
        (Math.random()-0.5)*0.3,
        (Math.random()-0.5)*0.15,
        (Math.random()-0.5)*0.3
      );
      dir = baseDir.add(jitter).normalize();
    }else{
      const toDir = toTarget.clone().normalize();
      const velDir= vel.length()>1e-3?vel.clone().normalize():new THREE.Vector3();
      dir = new THREE.Vector3()
        .addScaledVector(toDir,1.0)
        .addScaledVector(velDir,-0.3)
        .addScaledVector(g.clone().normalize(),-0.1)
        .normalize();
    }
    if(fuel>0){
      const thrustMag = ship.maxThrust*(policyType==="PETS"?0.6:0.45);
      vel.addScaledVector(dir,thrustMag*dt);
      fuel-=0.003;
      if(fuel<0) fuel=0;
    }
    vel.addScaledVector(g,dt);
    pos.addScaledVector(vel,dt);
    pts.push(pos.clone());
  }
  return pts;
}
let petsPathLine=null, sacPathLine=null;
function showPredictedPath(ship, policyType){
  const pts = predictTrajectory(ship, policyType);
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const color = policyType==="PETS"?0xffdd33:0x33aaff;
  const mat = new THREE.LineBasicMaterial({color,transparent:true,opacity:0.8});
  const line = new THREE.Line(geo,mat);
  scene.add(line);
  if(policyType==="PETS"){
    if(petsPathLine) scene.remove(petsPathLine);
    petsPathLine=line;
  }else{
    if(sacPathLine) scene.remove(sacPathLine);
    sacPathLine=line;
  }
}
  
/* -------------------------------------------------
 * ê³µê°„ ì™œê³¡ í•„ë“œ(ì—­ì¥) ìƒì„±
 *  - ìš°ì£¼ì„ ê³¼ ëª©í‘œ ì§€ì  ì¤‘ê°„ì— ìƒì„±
 *  - ë‚´ë¶€ ì¤‘ë ¥ì„ ë‹¤ì‹œ ì„ì–´ì„œ ì¤‘ë ¥ ìš°ì„¸ ì˜ì—­ ë³€ê²½
 * ------------------------------------------------- */
function spawnWarpField() {
  // RL íƒ€ê²Ÿ ìœ„ì¹˜(í–‰ì„±)ê³¼ ëŒ€í‘œ ìš°ì£¼ì„  ì„ íƒ
  const targetPos = getRLTargetPos();
  const mainShip  = petsShip || sacShip || getNearestShip(targetPos);
  if (!mainShip) {
    console.warn('ì—­ì¥ì„ ë§Œë“¤ ìš°ì£¼ì„ ì´ ì—†ìŠµë‹ˆë‹¤.');
    return;
  }

  // ìš°ì£¼ì„ ê³¼ ëª©í‘œ ì§€ì ì˜ ì¤‘ê°„ ì§€ì ì— ìƒì„±
  const center = new THREE.Vector3().lerpVectors(
    mainShip.pos,
    targetPos,
    0.5
  );

  const radius   = 40;   // í•„ë“œ ë°˜ê²½
  const strength = 0.8;  // íš¨ê³¼ ê°•ë„ (0~1)
  const life     = 80;   // ì§€ì† ì‹œê°„(ì´ˆ, ì‹¤ì œ ì‹œê°„ ê¸°ì¤€ ëŒ€ëµ)

  // ì‹œê°í™”ìš© ë°˜íˆ¬ëª… êµ¬
  const sGeo = new THREE.SphereGeometry(radius, 32, 32);
  const sMat = new THREE.MeshBasicMaterial({
    color: 0x8844ff,
    transparent: true,
    opacity: 0.06,
    wireframe: true,
  });
  const sphere = new THREE.Mesh(sGeo, sMat);
  sphere.position.copy(center);
  scene.add(sphere);

  warpFields.push({
    center,
    radius,
    strength,
    life,
    maxLife: life,
    sphere,
    ring,
  });
}

/* ì—­ì¥ ì‹œê° íš¨ê³¼ & ìˆ˜ëª… ì—…ë°ì´íŠ¸ */
function updateWarpFields(dtReal) {
  for (let i = warpFields.length - 1; i >= 0; i--) {
    const f = warpFields[i];
    f.life -= dtReal;

    if (f.life <= 0) {
      scene.remove(f.sphere);
      scene.remove(f.ring);
      warpFields.splice(i, 1);
      continue;
    }

    // ì²œì²œíˆ íšŒì „ + ì„œì„œíˆ ì‚¬ë¼ì§€ëŠ” ì—°ì¶œ
    const t = f.life / f.maxLife;          // 1 -> 0
    f.sphere.material.opacity = 0.06 * t;
  }
}

/* -------------------------------------------------
 * ì¤‘ë ¥ / ì—ë„ˆì§€ / ê´€ì¸¡
 * ------------------------------------------------- */
function computeGravitationalAcceleration(pos, ignoreBody = null) {
  const acc = new THREE.Vector3();

  for (const b of heavyBodies) {
    if (b === ignoreBody) continue;

    const bp   = b.pivot.getWorldPosition(new THREE.Vector3());
    const rVec = new THREE.Vector3().subVectors(bp, pos);
    const r    = rVec.length();
    if (r === 0) continue;

    const baseR = b.mesh.geometry.parameters.radius || 1;

    let maxRangeMul = 12;
    let effMass     = b.mass;

    if (b.name === 'íƒœì–‘') {
      maxRangeMul = 16;
      effMass    *= 0.0002;
    }

    const rMax = baseR * maxRangeMul;
    if (r > rMax) continue;

    const r2 = Math.max(100, r * r);
    let accMag = (G * effMass) / r2;
    if (accMag > MAX_ACC) accMag = MAX_ACC;

    acc.addScaledVector(rVec.normalize(), accMag);
  }

  // â˜… ê³µê°„ ì™œê³¡ í•„ë“œì˜ ì˜í–¥ ì ìš©
  return applyWarpFieldsToAcceleration(pos, acc);
}

/* ì—­ì¥ì— ì˜í•´ ì¤‘ë ¥ ìš°ì„¸ ì˜ì—­/ë°©í–¥ì„ ì™œê³¡ */
function applyWarpFieldsToAcceleration(pos, acc) {
  if (!warpFields.length) return acc;

  const sunBody = bodies['íƒœì–‘'];
  const sunPos  = sunBody
    ? sunBody.pivot.getWorldPosition(new THREE.Vector3())
    : new THREE.Vector3(0, 0, 0);

  const targetPos = getRLTargetPos(); // RL ëª©í‘œ(í–‰ì„±) ìœ„ì¹˜

  for (const f of warpFields) {
    const d = f.center.distanceTo(pos);
    if (d > f.radius) continue;

    const falloff = 1 - d / f.radius;          // ì¤‘ì‹¬ì—ì„œ 1, ê²½ê³„ì—ì„œ 0
    const strength = f.strength * falloff;     // ì‹¤ì œ íš¨ê³¼ í¬ê¸°

    // 1) ê¸°ì¡´ ì¤‘ë ¥ì„ ì¼ë¶€ ì•½í™” (ê¸°ë³¸ 40% ì •ë„ ê¹ìŒ)
    const weaken = 1 - 0.4 * strength;
    acc.multiplyScalar(weaken);

    // 2) ì¤‘ë ¥ ìš°ì„¸ ë°©í–¥ì„ "ëª©í‘œ í–‰ì„± ìª½ + íƒœì–‘ ê¶¤ë„ ë°©í–¥"ìœ¼ë¡œ ë¹„í‹€ê¸°
    const toTarget = new THREE.Vector3().subVectors(targetPos, pos).normalize();
    const toSun    = new THREE.Vector3().subVectors(sunPos, pos).normalize();
    const lateral  = new THREE.Vector3().crossVectors(toSun, new THREE.Vector3(0,1,0)).normalize();

    // ëª©í‘œ ë°©í–¥ + ê³µì „ ë°©í–¥ì„ ì„ì–´ì„œ ìƒˆë¡œìš´ ë°©í–¥ ìƒì„±
    const warpDir = new THREE.Vector3()
      .addScaledVector(toTarget, 0.8)
      .addScaledVector(lateral, 0.4)
      .normalize();

    const baseMag = acc.length();
    const extraMag = baseMag * 1.2 * strength;   // ì•½ê°„ ë” ê°•í•˜ê²Œ

    acc.addScaledVector(warpDir, extraMag);
  }
  return acc;
}


function computePotentialEnergy(pos, mass = 1.0) {
  let pe = 0;
  for (const b of heavyBodies) {
    const bp = b.pivot.getWorldPosition(new THREE.Vector3());
    const r  = bp.distanceTo(pos);
    if (r > 0) {
      pe += -G * b.mass * mass / r;
    }
  }
  return pe;
}

function computeCollisionRisk(pos) {
  let risk = 0;
  for (const b of heavyBodies) {
    const bp = b.pivot.getWorldPosition(new THREE.Vector3());
    const r  = bp.distanceTo(pos);
    const baseR = b.mesh.geometry.parameters.radius || 1;
    const safe = baseR * 5;
    if (r < safe) {
      risk = Math.max(risk, (safe - r) / safe);
    }
  }
  return Math.min(1, risk);
}

/* ì£¼ì–´ì§„ ìœ„ì¹˜ì—ì„œ ì—­ì¥ ì˜í–¥ë„(0~1)ì™€ ë°©í–¥ ë²¡í„° */
function computeWarpFieldInfo(pos) {
  let maxInfluence = 0;
  let nearestDir   = new THREE.Vector3(0,0,0);

  for (const f of warpFields) {
    const d = f.center.distanceTo(pos);
    if (d > f.radius) continue;

    const inf = 1 - d / f.radius;  // ì¤‘ì‹¬ì— ê°€ê¹Œìš¸ìˆ˜ë¡ 1
    if (inf > maxInfluence) {
      maxInfluence = inf;
      nearestDir.subVectors(f.center, pos).normalize();
    }
  }

  return {
    influence: maxInfluence,   // 0ì´ë©´ ì—­ì¥ ì˜í–¥ ì—†ìŒ
    dir: nearestDir
  };
}


function getRLTargetPos() {
  const sel = document.getElementById('autoTarget').value;
  const b = bodies[sel];
  if (!b) return new THREE.Vector3(0,0,0);
  return b.pivot.getWorldPosition(new THREE.Vector3());
}

function getObservation(ship) {
  const targetPos = getRLTargetPos();
  const g = computeGravitationalAcceleration(ship.pos);
  const toTarget = new THREE.Vector3().subVectors(targetPos, ship.pos);
  const dist = toTarget.length();
  const vel = ship.vel.clone();

  const ke = 0.5 * ship.mass * vel.lengthSq();
  const pe = computePotentialEnergy(ship.pos, ship.mass);
  const totalE = ke + pe;
    const angMom = ship.pos.clone().cross(vel);
  const collisionRisk = computeCollisionRisk(ship.pos);
  const warpInfo      = computeWarpFieldInfo(ship.pos);

  return {
    pos: ship.pos.clone(),
    vel,
    grav: g,
    toTarget,
    dist,
    fuel: ship.fuel,
    kinetic: ke,
    potential: pe,
    totalE,
    angMom,
    collisionRisk,
    // â˜… ì—­ì¥ ê´€ë ¨ ê´€ì¸¡ê°’
    warpInfluence: warpInfo.influence, // 0~1
    warpDir: warpInfo.dir              // ì—­ì¥ ì¤‘ì‹¬ ë°©í–¥
  };
}

function spawnSpaceshipSimple(pos, vel, policyType, color) {
  const geo = new THREE.ConeGeometry(0.3, 0.8, 8);
  geo.rotateX(Math.PI / 2);
  const mat = new THREE.MeshStandardMaterial({ color });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(pos);
  scene.add(mesh);
  const ship = {
    type:'ship',
    mesh,
    pos: mesh.position.clone(),
    vel: vel.clone(),
    mass: 0.05,
    radius: 0.4,
    fuel: 1.0,
    maxThrust: 0.22,   // ì¶œë ¥ í¬ê²Œ â†‘
    lastFuelUsed:0,
    prevGoalDist:null,
    totalReward:0,
    collided:false,
    policyType,
    alive:true
  };
  dynamicObjects.push(ship);
  return ship;
}

/* -------------------------------------------------
 * ë¼ê·¸ë‘ì£¼ í¬ì¸íŠ¸ í‘œì‹œ
 * ------------------------------------------------- */
function updateLagrangeFor(planet) {
  for (let i = lagrangeHelpers.length - 1; i >= 0; i--) {
    if (lagrangeHelpers[i].userData.parent === planet) {
      scene.remove(lagrangeHelpers[i]);
      lagrangeHelpers.splice(i, 1);
    }
  }

  const sun = bodies['íƒœì–‘'];
  if (!sun) return;

  const rp = planet.pivot.getWorldPosition(new THREE.Vector3());
  const rs = sun.pivot.getWorldPosition(new THREE.Vector3());
  const r  = rp.distanceTo(rs);
  const mu = planet.mass / (sun.mass + planet.mass);

  const d  = r * Math.pow(mu / 3, 1 / 3);
  const d1 = d;
  const d2 = d;

  const dir = new THREE.Vector3().subVectors(rs, rp).normalize();

  const pL1 = rp.clone().addScaledVector(dir, d1);
  const pL2 = rp.clone().addScaledVector(dir, -d2);

  const up    = new THREE.Vector3(0, 1, 0);
  const toSun = new THREE.Vector3().subVectors(rp, rs).normalize();
  const ort   = new THREE.Vector3().crossVectors(up, toSun).normalize();

  const pL4 = rp
    .clone()
    .addScaledVector(toSun, Math.cos(Math.PI / 3) * r)
    .addScaledVector(ort,  Math.sin(Math.PI / 3) * r);

  const pL5 = rp
    .clone()
    .addScaledVector(toSun, Math.cos(Math.PI / 3) * r)
    .addScaledVector(ort, -Math.sin(Math.PI / 3) * r);

  const points = [pL1, pL2, pL4, pL5];

  for (const pt of points) {
    const geo = new THREE.SphereGeometry(0.18, 8, 8);
    const mat = new THREE.MeshBasicMaterial({
      color: 0x66ffcc,
      transparent: true,
      opacity: 0.9,
    });
    const s = new THREE.Mesh(geo, mat);
    s.position.copy(pt);
    s.userData.parent = planet;
    scene.add(s);
    lagrangeHelpers.push(s);
  }
}

/* -------------------------------------------------
 * UI ë°”ì¸ë”© (ì†ë„, ì¤‘ì‹¬ì , í† ê¸€)
 * ------------------------------------------------- */
const speed    = document.getElementById('speed');
const speedNum = document.getElementById('speedNum');

function setRate(v) {
  const n = parseFloat(v);
  timeScale = Math.max(0, isNaN(n) ? 0 : n);
  speed.value    = String(timeScale);
  speedNum.value = String(timeScale);
}

speed.addEventListener('input', (e) => {
  setRate(e.target.value);
});

speedNum.addEventListener('input', () => {
  setRate(speedNum.value);
});

document.querySelectorAll('.btn[data-rate]').forEach((btn) => {
  btn.addEventListener('click', () => {
    setRate(btn.dataset.rate);
  });
});

const focusSel = document.getElementById('focusSel');

function applyFocus() {
  const v = focusSel.value;
  if (v === 'ììœ (ìˆ˜ë™)') {
    focusTarget = null;
  } else {
    focusTarget = (bodies[v] ? bodies[v].pivot : null) || bodies['íƒœì–‘'].pivot;
  }
  updateCam();
}
focusSel.addEventListener('change', applyFocus);

const axisToggle = document.getElementById('axisToggle');
axisToggle.addEventListener('change', () => {
  axisList.forEach((a) => (a.visible = axisToggle.checked));
});
axisList.forEach((a) => (a.visible = true));

const gravToggle = document.getElementById('gravToggle');
let showGravityField = false;
let gravHelpers = [];

gravToggle.addEventListener('change', () => {
  showGravityField = gravToggle.checked;
  updateGravityHelpers();
});

function updateGravityHelpers() {
  gravHelpers.forEach((h) => scene.remove(h));
  gravHelpers.length = 0;
  if (!showGravityField) return;

  for (const b of heavyBodies) {
    const center = b.pivot.getWorldPosition(new THREE.Vector3());
    const baseR  = b.mesh.geometry.parameters.radius || 1;
    const rVals  = [2, 4, 8, 12].map((x) => x * baseR);

    for (const r of rVals) {
      const geo = new THREE.RingGeometry(r - 0.06, r + 0.06, 64);
      geo.rotateX(-Math.PI / 2);
      const mat = new THREE.MeshBasicMaterial({
        color: 0x66ccff,
        transparent: true,
        opacity: 0.06,
        side: THREE.DoubleSide,
      });
      const ring = new THREE.Mesh(geo, mat);
      ring.position.copy(center);
      gravHelpers.push(ring);
      scene.add(ring);
    }

    updateLagrangeFor(b);
  }
}

/* -------------------------------------------------
 * ë§ˆìš°ìŠ¤ ì¹´ë©”ë¼ ì»¨íŠ¸ë¡¤
 * ------------------------------------------------- */
let dragging = false;
let px = 0;
let py = 0;
let button = 0;

app.addEventListener('mousedown', (e) => {
  if (e.button === 0 && pendingSpawn) {
    const pos = getClickPositionOnPlane(e);

    if (pendingSpawn.type === 'ship') {
      const vel = new THREE.Vector3(0, 0, 0);
      spawnSpaceship(pos, vel, null, 0x88ffdd);
    } else if (pendingSpawn.type === 'asteroid') {
      const nearestShip = getNearestShip(pos);
      spawnAsteroidSwarm(pos, nearestShip);
    }

    pendingSpawn = null;
    return;
  }

  dragging = true;
  px = e.clientX;
  py = e.clientY;
  button = e.button;
});

window.addEventListener('mouseup', () => {
  dragging = false;
});
app.addEventListener('contextmenu', (e) => e.preventDefault());

window.addEventListener('mousemove', (e) => {
  if (!dragging) return;

  const dx = e.clientX - px;
  const dy = e.clientY - py;

  if (button === 0) {
    theta -= dx * 0.005;
    phi   -= dy * 0.005;
    const eps = 0.001;
    phi = Math.max(eps, Math.min(Math.PI - eps, phi));
  } else if (button === 2) {
    if (!focusTarget) {
      const s = radius * 0.0012;
      camera.updateMatrixWorld();
      const fwd   = new THREE.Vector3();
      camera.getWorldDirection(fwd);
      const right = fwd.clone().cross(camera.up).normalize();
      const up    = camera.up.clone().normalize();

      manualTarget.addScaledVector(right, -dx * s);
      manualTarget.addScaledVector(up,    dy * s);
    }
  }

  px = e.clientX;
  py = e.clientY;
  updateCam();
});

app.addEventListener('wheel', (e) => {
  e.preventDefault();
  radius *= 1 + Math.sign(e.deltaY) * 0.08;
  radius  = Math.max(30, Math.min(5000, radius));
  updateCam();
}, { passive: false });

/* -------------------------------------------------
 * ë²„íŠ¼ ì•¡ì…˜ (ìš°ì£¼ì„ /ì†Œí–‰ì„±)
 * ------------------------------------------------- */
document.getElementById('spawnShip').addEventListener('click', () => {
  pendingSpawn = { type: 'ship' };
  console.log('ìš°ì£¼ì„  ìƒì„± ëª¨ë“œ: í™”ë©´ì—ì„œ ìœ„ì¹˜ë¥¼ í´ë¦­í•˜ì„¸ìš”.');
});

document.getElementById('delShip').addEventListener('click', () => {
  for (let i = dynamicObjects.length - 1; i >= 0; i--) {
    if (dynamicObjects[i].type === 'ship' && !dynamicObjects[i].policyType) {
      scene.remove(dynamicObjects[i].mesh);
      dynamicObjects.splice(i, 1);
    }
  }
});

document.getElementById('spawnAst').addEventListener('click', () => {
  pendingSpawn = { type: 'asteroid' };
  console.log('ì†Œí–‰ì„± êµ° ìƒì„± ëª¨ë“œ: í™”ë©´ì—ì„œ ìœ„ì¹˜ë¥¼ í´ë¦­í•˜ì„¸ìš”.');
});

document.getElementById('spawnField').addEventListener('click', () => {
  spawnWarpField();                          // â˜… ë°”ë¡œ ìƒì„± (í´ë¦­ ìœ„ì¹˜ X)
  console.log('ì—­ì¥ ìƒì„±: ìš°ì£¼ì„ ê³¼ ëª©í‘œ ì§€ì  ì‚¬ì´ì— ê³µê°„ ì™œê³¡ í•„ë“œê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.');
});

document.getElementById('clearObjs').addEventListener('click', () => {
  dynamicObjects.forEach((o) => scene.remove(o.mesh));
  dynamicObjects.length = 0;
  petsShip = null;
  sacShip  = null;
  spawnRLShips();
});

/* -------------------------------------------------
 * ì¼€í”ŒëŸ¬ ë°©ì •ì‹ í’€ì´ (E)
 * ------------------------------------------------- */
function solveKepler(M, e) {
  let E = M;
  for (let i = 0; i < 12; i++) {
    const f  = E - e * Math.sin(E) - M;
    const fp = 1 - e * Math.cos(E);
    E -= f / fp;
  }
  return E;
}

/* -------------------------------------------------
 * ì—­ì¥(í•„ë“œ) ì´ë²¤íŠ¸
 *  - ë²„íŠ¼ í´ë¦­ ì‹œ, ì„ íƒí•œ RL ëª©í‘œê¹Œì§€
 *    ìš°ì£¼ì„  ê²½ë¡œ ìœ„ì— ë°˜íˆ¬ëª… ë§ ì—¬ëŸ¬ ê°œ ìƒì„±
 *  - ì‹œê°„ì´ ì§€ë‚˜ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ì‚¬ë¼ì§
 * ------------------------------------------------- */
const fieldEvents = [];

function triggerFieldEvent() {
  // ê¸°ì¤€ ìš°ì£¼ì„ : PETS ìš°ì„ , ì—†ìœ¼ë©´ SAC, ê·¸ê²ƒë„ ì—†ìœ¼ë©´ ì•„ë¬´ ship
  let ship = petsShip || sacShip || null;
  if (!ship) {
    ship = dynamicObjects.find(o => o.type === "ship") || null;
  }
  if (!ship) return;

  // í˜„ì¬ RL ëª©í‘œ ìœ„ì¹˜
  const targetPos = getRLTargetPos();

  const from = ship.pos.clone();
  const to   = targetPos.clone();

  const steps = 1; // ëª‡ ê°œì˜ ì—­ì¥ ë§ì„ ë§Œë“¤ì§€
  for (let i = 1; i <= steps; i++) {
    const t = i / (steps + 1);
    const pos = new THREE.Vector3().lerpVectors(from, to, t);

    const r = 3 + Math.random() * 2; // ë§ í¬ê¸°
    const geo = new THREE.RingGeometry(r * 0.6, r, 64);
    geo.rotateX(-Math.PI / 2);

    const mat = new THREE.MeshBasicMaterial({
      color: 0xff66ff,
      transparent: true,
      opacity: 0.6,
      side: THREE.DoubleSide,
    });

    const ring = new THREE.Mesh(geo, mat);
    ring.position.copy(pos);
    scene.add(ring);

    fieldEvents.push({
      mesh: ring,
      life: 100 + Math.random() * 2,           // ì¡´ì¬ ì‹œê°„(ì´ˆ)
      spin: (Math.random() * 0.8 - 0.4),     // íšŒì „ ì†ë„
    });
  }
}

// ë§¤ í”„ë ˆì„ ì—­ì¥ ì• ë‹ˆë©”ì´ì…˜
function updateFieldEvents(dt) {
  for (let i = fieldEvents.length - 1; i >= 0; i--) {
    const f = fieldEvents[i];
    f.life -= dt;
    f.mesh.rotation.z += f.spin * dt;
    f.mesh.material.opacity = Math.max(0, f.life / 4);
    if (f.life <= 0) {
      scene.remove(f.mesh);
      fieldEvents.splice(i, 1);
    }
  }
}


/* -------------------------------------------------
 * ì¶”ë ¥ íŒŒí‹°í´
 * ------------------------------------------------- */
const thrustParticles = [];

function spawnThrustParticle(ship, thrustDir) {
  const geo = new THREE.SphereGeometry(0.15, 8, 8);
  const mat = new THREE.MeshBasicMaterial({
    color: 0x88ffff,
    transparent: true,
    opacity: 0.9,
  });
  const p = new THREE.Mesh(geo, mat);

  const back = thrustDir.clone().multiplyScalar(-1);
  p.position.copy(ship.pos).addScaledVector(back, ship.radius || 0.8);

  p.userData.vel  = back.multiplyScalar(0.6);
  p.userData.life = 0.6;

  scene.add(p);
  thrustParticles.push(p);
}

function updateThrustParticles(dt) {
  for (let i = thrustParticles.length - 1; i >= 0; i--) {
    const p = thrustParticles[i];
    p.userData.life -= dt;
    p.position.addScaledVector(p.userData.vel, dt);
    p.material.opacity = Math.max(0, p.userData.life / 0.6);
    if (p.userData.life <= 0) {
      scene.remove(p);
      thrustParticles.splice(i, 1);
    }
  }
}

/* -------------------------------------------------
 * RL ì•¡ì…˜ ì ìš©
 * ------------------------------------------------- */
function applyRLAction(ship, action, dt) {
  const dir = action.dir.clone().normalize();
  const thrustOn  = !!action.thrustOn;
  const fuelRatio = Math.max(0, Math.min(1, action.fuelRatio ?? 0.5));

  ship.lastFuelUsed = 0;

  if (thrustOn && ship.fuel > 0) {
    const thrustMag = ship.maxThrust * fuelRatio;
    ship.vel.addScaledVector(dir, thrustMag * dt);
    const fuelUsed = fuelRatio * dt * 0.9;
    ship.fuel = Math.max(0, ship.fuel - fuelUsed);
    ship.lastFuelUsed = fuelUsed;

    spawnThrustParticle(ship, dir);
  }
}

/* -------------------------------------------------
 * PETS ìŠ¤íƒ€ì¼ ì •ì±… (ëª¨ë¸ ê¸°ë°˜, ë¯¸ë˜ ê¶¤ë„ íƒìƒ‰)
 * ------------------------------------------------- */
function stepPETS(ship, dt) {
  const obs = getObservation(ship);
  if (!ship.alive) return;
  if (obs.dist < 1 || ship.fuel <= 0.01) return;

  // ê¸°ë³¸ ë°©í–¥: ëª©í‘œ ì§€ì  ìª½
  const baseDir = obs.toTarget.clone().normalize();

  // ì—­ì¥ ì•ˆì— ìˆì„ ë•ŒëŠ” ì—­ì¥ ë°©í–¥ë„ ì¡°ê¸ˆ ì„ê¸°
  if (obs.warpInfluence > 0) {
    baseDir
      .addScaledVector(obs.warpDir, 0.4 * obs.warpInfluence)
      .normalize();
  }

  const horizon   = 8;
  const candCount = 18;

  // â˜… ë¹ ì§„ ë¶€ë¶„: í›„ë³´ ì¤‘ ìµœê³  ì ìˆ˜, ê·¸ë•Œì˜ ë°©í–¥
  let bestScore = -Infinity;
  let bestDir   = baseDir.clone();

  for (let i = 0; i < candCount; i++) {
    const jitter = new THREE.Vector3(
      (Math.random() - 0.5) * 0.4,
      (Math.random() - 0.5) * 0.2,
      (Math.random() - 0.5) * 0.4
    );
    const candDir = baseDir.clone().add(jitter).normalize();

    let simPos = obs.pos.clone();
    let simVel = obs.vel.clone();
    let score  = 0;

    for (let t = 0; t < horizon; t++) {
      const g = computeGravitationalAcceleration(simPos);
      simVel.addScaledVector(g, dt);
      simVel.addScaledVector(candDir, ship.maxThrust * 0.5 * dt);
      simPos.addScaledVector(simVel, dt);

      const d = simPos.distanceTo(getRLTargetPos());
      score -= d * 0.02;
    }

    const risk = computeCollisionRisk(simPos);
    score -= risk * 3;

    if (score > bestScore) {
      bestScore = score;
      bestDir.copy(candDir);
    }
  }

  const action = {
    thrustOn:  obs.dist > 1 && ship.fuel > 0.02,
    dir:       bestDir,
    fuelRatio: 0.7
  };
  applyRLAction(ship, action, dt);

  const progress = (ship.prevGoalDist ?? obs.dist) - obs.dist;
  ship.totalReward += progress * 15 - ship.lastFuelUsed * 20 - dt * 0.4;
  ship.prevGoalDist = obs.dist;

  document.getElementById("petsFuel").textContent = (ship.fuel * 100).toFixed(1);
  document.getElementById("petsRew").textContent  = ship.totalReward.toFixed(1);
}

/* ========== RL ì•¡ì…˜ ì ìš© + PETS/SAC ì •ì±… ========== */
function applyRLAction(ship, action, dt) {
  const dir = action.dir.clone().normalize();
  const thrustOn = !!action.thrustOn;
  const fuelRatio = Math.max(0,Math.min(1,action.fuelRatio ?? 0.5));
  ship.lastFuelUsed=0;
  if(thrustOn && ship.fuel>0){
    const thrustMag = ship.maxThrust*fuelRatio;
    ship.vel.addScaledVector(dir, thrustMag*dt);
    const fuelUsed = fuelRatio*dt*0.9;
    ship.fuel = Math.max(0, ship.fuel-fuelUsed);
    ship.lastFuelUsed = fuelUsed;
    spawnThrustParticle(ship,dir);
  }
}
function stepPETS(ship,dt){
  const obs = getObservation(ship);
  if (obs.dist<1 || ship.fuel<=0.01) return;
  const baseDir = obs.toTarget.clone().normalize();
  let bestScore=-Infinity, bestDir=baseDir.clone();
  const horizon=8, candCount=16;
  for(let i=0;i<candCount;i++){
    const jitter = new THREE.Vector3(
      (Math.random()-0.5)*0.4,
      (Math.random()-0.5)*0.2,
      (Math.random()-0.5)*0.4
    );
    const candDir = baseDir.clone().add(jitter).normalize();
    let pos = obs.pos.clone();
    let vel = obs.vel.clone();
    let score=0;
    for(let t=0;t<horizon;t++){
      const g = computeGravitationalAcceleration(pos);
      vel.addScaledVector(g,dt);
      vel.addScaledVector(candDir, ship.maxThrust*0.5*dt);
      pos.addScaledVector(vel,dt);
      const d = pos.distanceTo(getRLTargetPos());
      score-=d*0.02;
    }
    const risk = computeCollisionRisk(pos);
    score-=risk*3;
    if(score>bestScore){bestScore=score; bestDir.copy(candDir);}
  }
  applyRLAction(ship,{
    thrustOn: obs.dist>1 && ship.fuel>0.02,
    dir:bestDir,
    fuelRatio:0.7
  },dt);
  const progress = (ship.prevGoalDist ?? obs.dist)-obs.dist;
  ship.totalReward += progress*15 - ship.lastFuelUsed*20 - dt*0.4;
  ship.prevGoalDist = obs.dist;
  document.getElementById('petsFuel').textContent=(ship.fuel*100).toFixed(1);
  document.getElementById('petsRew').textContent=ship.totalReward.toFixed(1);
}
function stepSAC(ship,dt){
  const obs = getObservation(ship);
  if (obs.dist<1 || ship.fuel<=0.01) return;
  const toTargetDir = obs.toTarget.clone().normalize();
  const velDir = obs.vel.length()>1e-3 ? obs.vel.clone().normalize() : new THREE.Vector3();
  const gravDir= obs.grav.length()>1e-4 ? obs.grav.clone().normalize() : new THREE.Vector3();
  let baseDir = new THREE.Vector3()
    .addScaledVector(toTargetDir,1.0)
    .addScaledVector(velDir,-0.5)
    .addScaledVector(gravDir,-0.2);
  if(baseDir.length()<1e-3) baseDir = toTargetDir.clone();
  const noise = new THREE.Vector3(
    (Math.random()-0.5)*0.3,
    (Math.random()-0.5)*0.2,
    (Math.random()-0.5)*0.3
  );
  baseDir.add(noise.multiplyScalar(0.3)).normalize();
  applyRLAction(ship,{
    thrustOn: obs.dist>1 && ship.fuel>0.02,
    dir:baseDir,
    fuelRatio:0.5
  },dt);
  const progress = (ship.prevGoalDist ?? obs.dist)-obs.dist;
  ship.totalReward += progress*10 - ship.lastFuelUsed*10 - dt*0.3;
  ship.prevGoalDist = obs.dist;
  document.getElementById('sacFuel').textContent=(ship.fuel*100).toFixed(1);
  document.getElementById('sacRew').textContent=ship.totalReward.toFixed(1);
}

/* ========== PETS/SAC ì˜ˆì¸¡ ê²½ë¡œ ê³„ì‚° ========== */
function predictTrajectory(ship, policyType, steps=140, dt=0.7){
  const pts=[];
  let pos = ship.pos.clone();
  let vel = ship.vel.clone();
  let fuel = ship.fuel;
  for(let i=0;i<steps;i++){
    const targetPos = getRLTargetPos();
    const toTarget  = new THREE.Vector3().subVectors(targetPos,pos);
    const dist      = toTarget.length();
    if (dist<1) break;
    const g = computeGravitationalAcceleration(pos);
    let dir;
    if(policyType==="PETS"){
      const baseDir = toTarget.clone().normalize();
      const jitter = new THREE.Vector3(
        (Math.random()-0.5)*0.3,
        (Math.random()-0.5)*0.15,
        (Math.random()-0.5)*0.3
      );
      dir = baseDir.add(jitter).normalize();
    }else{
      const toDir = toTarget.clone().normalize();
      const velDir= vel.length()>1e-3?vel.clone().normalize():new THREE.Vector3();
      dir = new THREE.Vector3()
        .addScaledVector(toDir,1.0)
        .addScaledVector(velDir,-0.3)
        .addScaledVector(g.clone().normalize(),-0.1)
        .normalize();
    }
    if(fuel>0){
      const thrustMag = ship.maxThrust*(policyType==="PETS"?0.6:0.45);
      vel.addScaledVector(dir,thrustMag*dt);
      fuel-=0.003;
      if(fuel<0) fuel=0;
    }
    vel.addScaledVector(g,dt);
    pos.addScaledVector(vel,dt);
    pts.push(pos.clone());
  }
  return pts;
}
let petsPathLine=null, sacPathLine=null;
function showPredictedPath(ship, policyType){
  const pts = predictTrajectory(ship, policyType);
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const color = policyType==="PETS"?0xffdd33:0x33aaff;
  const mat = new THREE.LineBasicMaterial({color,transparent:true,opacity:0.8});
  const line = new THREE.Line(geo,mat);
  scene.add(line);
  if(policyType==="PETS"){
    if(petsPathLine) scene.remove(petsPathLine);
    petsPathLine=line;
  }else{
    if(sacPathLine) scene.remove(sacPathLine);
    sacPathLine=line;
  }
}

/* ì—í”¼ì†Œë“œ ì¢…ë£Œ ì²˜ë¦¬ */
function endEpisode(ship, success){
  if(episodeFinished) return;
  episodeFinished=true;
  simulationPaused=true;
  totalAttempts++;
  if(success) totalSuccess++;
  const percent = Math.round(totalSuccess*100/totalAttempts);
  const targetName = document.getElementById('autoTarget').value;
  const method = ship.policyType || 'UNKNOWN';
  resultLine.textContent = `${method}ê°€ ${targetName} í–¥í•´ ${success?"ì„±ê³µ":"ì‹¤íŒ¨"}í–ˆìŠµë‹ˆë‹¤.`;
  resultPercent.textContent = `ì„±ê³µë¥  ${percent}% (${totalSuccess}/${totalAttempts})`;
  resultOverlay.style.display='flex';

  const ts = new Date().toISOString().slice(11,19);
  const line = document.createElement('div');
  line.textContent = `[${ts}] ${method} â†’ ${targetName}: ${success?"ì„±ê³µ":"ì‹¤íŒ¨"}`;
  logContent.prepend(line);
}

/* ëª¨ë‹¬ ë°”ê¹¥ í´ë¦­ ì‹œ ì´ˆê¸°í™” */
resultOverlay.addEventListener('click',e=>{
  if(e.target===resultOverlay){
    resultOverlay.style.display='none';
    // ìš°ì£¼ì„ /ê²½ë¡œ ì œê±°
    if(activeShip){scene.remove(activeShip.mesh); activeShip.alive=false;}
    if(petsShip && petsShip!==activeShip){scene.remove(petsShip.mesh);}
    if(sacShip && sacShip!==activeShip){scene.remove(sacShip.mesh);}
    if(petsPathLine){scene.remove(petsPathLine);}
    if(sacPathLine){scene.remove(sacPathLine);}
    petsShip=sacShip=activeShip=null;
    petsPathLine=sacPathLine=null;
    simulationPaused=false;
    episodeFinished=false;
  }
});

/* ========== ì¼€í”ŒëŸ¬ E ========== */
function solveKepler(M,e){
  let E=M;
  for(let i=0;i<12;i++){
    const f=E-e*Math.sin(E)-M;
    const fp=1-e*Math.cos(E);
    E-=f/fp;
  }
  return E;
}


/* -------------------------------------------------
 * ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
 * ------------------------------------------------- */
let last = performance.now();
const hudBox = document.getElementById("hudBox");

function tick(now) {
  const dtReal = (now - last) / 1000;
  last = now;

  const dtDays = dtReal * timeScale;
  simDate = new Date(
    simDate.getTime() + dtDays * 24 * 3600 * 1000
  );
  document.getElementById('startTime').textContent =
    simDate.toISOString().replace('T', ' ').slice(0, 19);

  const physScale = Math.max(0, Math.min(timeScale, 100));
  const dtPhys    = dtReal * physScale;

  // íƒœì–‘ ìì „
  const sunBody = bodies['íƒœì–‘'];
  if (sunBody) {
    sunBody.spin.rotation.y +=
      dtDays * (2 * Math.PI / defs[0].rotH);
  }

  // í–‰ì„±/ìœ„ì„± ì—…ë°ì´íŠ¸
  for (const ps of planetStates) {
    const node = ps.node;

    if (node.orbitPeriodDays > 0) {
      const n = (2 * Math.PI) / node.orbitPeriodDays;
      node.meanAnomaly =
        (node.meanAnomaly + n * dtDays) % (2 * Math.PI);

      const M = node.meanAnomaly;
      const e = node.ecc || 0;
      const E = solveKepler(M, e);

      const a = node.semiMajor;
      const b = a * Math.sqrt(Math.max(0, 1 - e * e));

      const x0 = a * (Math.cos(E) - e);
      const z0 = -b * Math.sin(E);

      const pos = new THREE.Vector3(x0, 0, z0);

      const iRad = THREE.MathUtils.degToRad(node.orbitInc || 0);
      pos.applyAxisAngle(new THREE.Vector3(1, 0, 0), iRad);

      node.pivot.position.copy(pos);
    }

    const rotDays = Math.abs(node.rotPeriodHours) / 24;
    const rotSgn  = node.rotPeriodHours >= 0 ? 1 : -1;

    if (rotDays > 0) {
      node.spin.rotation.y +=
        rotSgn * dtDays * (2 * Math.PI / rotDays);
    }

    if (ps.moons && ps.moons.length > 0) {
      for (const m of ps.moons) {
        if (m.orbitPeriodDays <= 0) continue;

        const nm = (2 * Math.PI) / m.orbitPeriodDays;
        m.orbitalAngle =
          (m.orbitalAngle + nm * dtDays) % (2 * Math.PI);

        const ca = Math.cos(m.orbitalAngle);
        const sa = Math.sin(m.orbitalAngle);

        m.pivot.position.set(
          ca * m.orbitDist,
          0,
          -sa * m.orbitDist
        );
      }
    }
  }

  if (showGravityField) updateGravityHelpers();

  // ë™ì  ê°ì²´ (ì¤‘ë ¥ + RL + ì¶©ëŒ)
  if(dtPhys>0 && dynamicObjects.length>0){
    for(let i=dynamicObjects.length-1;i>=0;i--){
      const o=dynamicObjects[i];
      if(!o.alive) continue;
      if(o.type==='ship' && !episodeFinished){
        if(o.policyType==="PETS" && petsEnabled) stepPETS(o,dtPhys);
        else if(o.policyType==="SAC" && sacEnabled) stepSAC(o,dtPhys);
      }
      const a0=computeGravitationalAcceleration(o.pos);
      o.pos.addScaledVector(o.vel,dtPhys)
           .addScaledVector(a0,0.5*dtPhys*dtPhys);
      const a1=computeGravitationalAcceleration(o.pos);
      o.vel.addScaledVector(a0.add(a1).multiplyScalar(0.5),dtPhys);
      o.mesh.position.copy(o.pos);

      // ì¶©ëŒ ì²´í¬
      for(const hb of heavyBodies){
        const hp = hb.pivot.getWorldPosition(new THREE.Vector3());
        const dist=hp.distanceTo(o.pos);
        const rBody=hb.mesh.geometry.parameters.radius||1;
        if(dist<rBody*1.1+(o.radius||0.5)){
          explodeAt(o.pos);
          if(o.type==='ship'){
            o.collided=true;
            o.totalReward-=50;
            endEpisode(o,false);
          }
          scene.remove(o.mesh);
          o.alive=false;
          dynamicObjects.splice(i,1);
          break;
        }
      }

      // ë„ì°© íŒì •
      if(o.type==='ship' && !episodeFinished && o.policyType){
        const obs = getObservation(o);
        const successDist=2.0;
        if(obs.dist<successDist){
          endEpisode(o,true);
        }else if(o.fuel<=0){
          endEpisode(o,false);
        }
      }
    }
  }

  updateThrustParticles(dtReal);
  updateWarpFields(dtReal);    // â˜… ì—­ì¥ ìˆ˜ëª…/ì‹œê° íš¨ê³¼ ê°±ì‹ 

  // HUD ê°±ì‹ 
  if (petsShip && sacShip) {
    const obsP = getObservation(petsShip);
    const obsS = getObservation(sacShip);
    hudBox.innerHTML =
      "PETS / SAC ìƒíƒœ<br>--------------------------<br>" +
      `Target: ${document.getElementById('autoTarget').value}<br>` +
      `PETS dist: ${obsP.dist.toFixed(1)}  v:${obsP.vel.length().toFixed(2)} E:${obsP.totalE.toFixed(1)}<br>`+
      `PETS risk:${obsP.collisionRisk.toFixed(2)} fuel:${(petsShip.fuel*100).toFixed(1)}%<br>`+
      `SAC  dist: ${obsS.dist.toFixed(1)}  v:${obsS.vel.length().toFixed(2)} E:${obsS.totalE.toFixed(1)}<br>`+
      `SAC  risk:${obsS.collisionRisk.toFixed(2)} fuel:${(sacShip.fuel*100).toFixed(1)}%<br>`+
      `(ìš°ì£¼ì„  ì†Œí™˜ â†’ ì˜ˆì¸¡ ê²½ë¡œ í™•ì¸ â†’ PETS/SAC ì„ íƒ)`;
  }
  updateCam();
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* -------------------------------------------------
 * ë¦¬ì‚¬ì´ì¦ˆ ëŒ€ì‘ & ì´ˆê¸° UI ì„¤ì •
 * ------------------------------------------------- */
window.addEventListener('resize', () => {
  const w = app.clientWidth;
  const h = app.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
});

document.getElementById('speed').value    = String(timeScale);
document.getElementById('speedNum').value = String(timeScale);
focusSel.value = 'íƒœì–‘';
applyFocus();
radius = 200;
updateCam();

</script>
</body>
</html>

