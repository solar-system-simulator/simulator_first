<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>3D íƒœì–‘ê³„ â€” ì‹¤ê° ë‚˜ëŠ” ê¶¤ë„ë©´ & ì¼€í”ŒëŸ¬ ì†ë„</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#061024;color:#e9f2ff;font:12px/1.4 system-ui}
  #app{position:fixed; inset:0}
  canvas{display:block; width:100%; height:100%}
  .ui{
    position:fixed; left:12px; top:12px; background:rgba(255,255,255,.04);
    border:1px solid rgba(255,255,255,.06); padding:8px 10px; border-radius:10px;
    display:flex; gap:10px; flex-wrap:wrap; align-items:center; max-width:96vw; z-index:20;
  }
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .btn{cursor:pointer; padding:4px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.02)}
  .btn:hover{background:rgba(255,255,255,.04)}
  input[type="range"]{width:200px}
  select,input[type="number"]{background:transparent; color:#e9f2ff; border:1px solid rgba(255,255,255,.06); border-radius:6px; padding:4px}
  .hint{opacity:.7;font-size:12px;color:#bcd}
</style>
</head>
<body>
<div id="app"></div>

<div class="ui">
  <div class="row">
    <label for="speed">ì†ë„</label>
    <input id="speed" type="range" min="0" max="8" step="0.1" value="2">
    <input id="speedNum" type="number" min="0" max="8" step="0.1" value="2" style="width:60px">
    <button class="btn" data-rate="1">1Ã—</button>
    <button class="btn" data-rate="2">2Ã—</button>
    <button class="btn" data-rate="3">3Ã—</button>
  </div>

  <div class="row">
    <label for="focusSel">ì¤‘ì‹¬ì </label>
    <select id="focusSel">
      <option>ììœ (ìˆ˜ë™)</option>
      <option>íƒœì–‘</option>
      <option selected>ì§€êµ¬</option>
      <option>ìˆ˜ì„±</option><option>ê¸ˆì„±</option><option>ë‹¬</option><option>í™”ì„±</option>
      <option>ëª©ì„±</option><option>í† ì„±</option><option>ì²œì™•ì„±</option><option>í•´ì™•ì„±</option>
    </select>
    <label><input id="axisToggle" type="checkbox" checked> ìì „ì¶• í‘œì‹œ</label>
    <span class="hint">â€¢ ì¢Œí´ë¦­: íšŒì „ Â· íœ : ì¤Œ Â· ìš°í´ë¦­: íŒ¬(ììœ  ëª¨ë“œ)</span>
  </div>

  <div class="row">
    <button class="btn" id="spawnAsteroidBtn">â˜„ï¸ ì†Œí–‰ì„± ì†Œí™˜ (ì•)</button>
    <button class="btn" id="spawnShipBtn">ğŸš€ ìš°ì£¼ì„  ì†Œí™˜ (ì•)</button>
    <button class="btn" id="clearShipsBtn">ğŸ—‘ï¸ ìš°ì£¼ì„  ì‚­ì œ</button>
    <label style="margin-left:8px"><input id="showGravity" type="checkbox" checked> ì¤‘ë ¥ê¶Œ ì‹œê°í™”</label>
  </div>
</div>

<!-- Three.js UMD -->
<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>

<script>
/*
  ì‹¤ì‚¬í™”ëœ ê¶¤ë„ë©´ + ì¼€í”ŒëŸ¬ ê¸°ë°˜ ì†ë„ ì ìš© ë²„ì „
  - ê¶¤ë„ë©´: inclination(i), longitude of ascending node(raan), argument of periapsis(arg)
  - ìœ„ì¹˜/ë¼ì¸ ê³„ì‚°: ë™ì¼í•œ íšŒì „í–‰ë ¬ì„ ì¬ì‚¬ìš©
  - ê°ì†ë„: Ï‰ âˆ a^(-3/2) (ì§€êµ¬ ê¸°ì¤€ìœ¼ë¡œ ì •ê·œí™”)
*/

// ---------- ê¸°ë³¸ ì„¤ì • ----------
const app = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(app.clientWidth, app.clientHeight);
renderer.setClearColor(0x061024, 1);
app.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, app.clientWidth/app.clientHeight, 0.1, 20000);
let radius = 220, phi = THREE.MathUtils.degToRad(25), theta = THREE.MathUtils.degToRad(30);
const manualTarget = new THREE.Vector3(0,0,0);
let focusTarget = null;
function getTarget(){ return focusTarget ? focusTarget.getWorldPosition(new THREE.Vector3()) : manualTarget; }
function updateCam(){
  const t = getTarget();
  const x = t.x + radius * Math.sin(phi) * Math.cos(theta);
  const y = t.y + radius * Math.cos(phi);
  const z = t.z + radius * Math.sin(phi) * Math.sin(theta);
  camera.position.set(x,y,z);
  camera.lookAt(t);
}
updateCam();
scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const sunLight = new THREE.PointLight(0xffffff, 2.6, 0, 2);
scene.add(sunLight);

// helpers
function axisMesh(len, thick=0.06){
  const g = new THREE.CylinderGeometry(thick, thick, len, 12);
  const m = new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.7, depthWrite:false });
  const cyl = new THREE.Mesh(g, m);
  cyl.position.y = 0;
  return cyl;
}

// containers
const bodies = {}; // name -> group
const axisList = [];
const SIZE = 1.0;
let timeScale = 2;

// ---------- Sun ----------
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(10*SIZE, 64, 64),
  new THREE.MeshBasicMaterial({ color: 0xffd97a })
);
scene.add(sun);
sunLight.position.copy(sun.position);

// ---------- body factory ----------
function createBodySimple({ name, size=1, color=0xffffff, axialTiltDeg=0 } = {}) {
  const group = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.7 });
  const sphere = new THREE.Mesh(new THREE.SphereGeometry(size*SIZE, 32,32), mat);
  group.add(sphere);
  const ax = axisMesh(size*SIZE*3.0, Math.max(0.03, size*SIZE*0.06));
  group.add(ax); axisList.push(ax);
  return { name, group, sphere, axis: ax, size };
}

// ---------- planet definitions (i: inclination deg, raan: deg, arg: deg) ----------
const planetDefs = [
  { name:'ìˆ˜ì„±', color:0xb4b4b4, size:0.9, a:16, orbit:87.969, rotH:1407.6, tilt:0.03, e:0.2056, i: 7.0, raan:48.331, arg:29.124 },
  { name:'ê¸ˆì„±', color:0xd8b47d, size:1.1, a:22, orbit:224.701, rotH:-5832.5, tilt:177.36, e:0.0068, i: 3.4, raan:76.680, arg:54.884 },
  { name:'ì§€êµ¬', color:0x5fa8ff, size:1.2, a:30, orbit:365.256, rotH:23.934, tilt:23.44, e:0.0167,  i: 0.0, raan:0.0, arg:102.9373,
    moons:[ { name:'ë‹¬', color:0xcfd6ff, size:0.35, a:4.0, orbit:27.322, rotH:655.7, tilt:6.68 } ]
  },
  { name:'í™”ì„±', color:0xff6b6b, size:0.9, a:38, orbit:686.980, rotH:24.623, tilt:25.19, e:0.0934, i: 1.85, raan:49.558, arg:286.537,
    moons:[ { name:'í¬ë³´ìŠ¤', color:0xaaaaaa, size:0.12, a:2.5, orbit:0.3189, rotH:7.65, tilt:0 }, { name:'ë°ì´ëª¨ìŠ¤', color:0xcccccc, size:0.08, a:3.2, orbit:1.263, rotH:30.3, tilt:0 } ]
  },
  { name:'ëª©ì„±', color:0xc89f68, size:4.0, a:60, orbit:4332.589, rotH:9.925, tilt:3.13, e:0.0489, i: 1.3, raan:100.464, arg:273.867,
    moons:[ { name:'ì´ì˜¤', color:0xe6d27c, size:0.25, a:6.0, orbit:1.769, rotH:42.46, tilt:0 }, { name:'ìœ ë¡œíŒŒ', color:0xdddddd, size:0.22, a:7.5, orbit:3.551, rotH:85.2, tilt:0.1 } ]
  },
  { name:'í† ì„±', color:0xd8cfae, size:3.6, a:78, orbit:10759.22, rotH:10.656, tilt:26.73, e:0.0565, i: 2.48, raan:113.665, arg:339.392, ring:true,
    moons:[ { name:'íƒ€ì´íƒ„', color:0xcab47a, size:0.28, a:8.0, orbit:15.945, rotH:382.7, tilt:0.3 } ]
  },
  { name:'ì²œì™•ì„±', color:0x9bd7ff, size:2.9, a:96, orbit:30688.5, rotH:-17.24, tilt:97.77, e:0.0457, i: 0.77, raan:74.006, arg:96.998857,
    moons:[ { name:'í‹°íƒ€ë‹ˆì•„', color:0xcccccc, size:0.18, a:6.0, orbit:8.706, rotH:208.9, tilt:0 } ]
  },
  { name:'í•´ì™•ì„±', color:0x6aa7ff, size:2.8, a:112, orbit:60182.0, rotH:16.11, tilt:28.32, e:0.0113, i: 1.77, raan:131.784, arg:272.8461,
    moons:[ { name:'íŠ¸ë¦¬í†¤', color:0xcfd6ff, size:0.22, a:6.5, orbit:5.877, rotH:141.0, tilt:0, retrogradeOrbit:true } ]
  }
];

// ---------- helper: build rotation matrix from orbital elements ----------
function buildOrbitalTransform(def){
  // orbital-plane coords -> ecliptic/world
  // Steps: rotate by argument (Ï‰) about Z, then by inclination (i) about X, then by RAAN (Î©) about Z.
  const iRad = THREE.MathUtils.degToRad(def.i || 0);
  const raanRad = THREE.MathUtils.degToRad(def.raan || 0);
  const argRad = THREE.MathUtils.degToRad(def.arg || 0);

  const mat = new THREE.Matrix4();
  const rotArg = new THREE.Matrix4().makeRotationZ(argRad);
  const rotInc = new THREE.Matrix4().makeRotationX(iRad);
  const rotRaan = new THREE.Matrix4().makeRotationZ(raanRad);

  // final: R = R_Î© * R_i * R_Ï‰
  mat.multiply(rotRaan).multiply(rotInc).multiply(rotArg);
  return mat;
}

// ---------- create orbits & bodies ----------
const planetStates = [];
for (const def of planetDefs){
  const a = def.a;
  const e = def.e || 0;
  const b = a * Math.sqrt(1 - e*e);
  const transform = buildOrbitalTransform(def); // matrix for this orbit

  // orbit line: generate ellipse in orbital plane, then transform
  const pts = [];
  const curve = new THREE.EllipseCurve(-e*a, 0, a, b, 0, 2*Math.PI, false, 0);
  const raw = curve.getPoints(512);
  for (let p of raw){
    // orbital-plane coords (x_orb, y_orb, 0)
    const v = new THREE.Vector3(p.x, p.y, 0);
    v.applyMatrix4(transform); // rotate into world
    pts.push(v);
  }
  const orbitGeom = new THREE.BufferGeometry().setFromPoints(pts);
  const orbitMat = new THREE.LineBasicMaterial({ color:def.color, transparent:true, opacity:0.35 });
  const orbitLine = new THREE.LineLoop(orbitGeom, orbitMat);
  scene.add(orbitLine);

  // body
  const body = createBodySimple({ name:def.name, size:def.size, color:def.color, axialTiltDeg:def.tilt });
  scene.add(body.group);

  // moons
  const moons = [];
  if (def.moons){
    for (const m of def.moons){
      const mBody = createBodySimple({ name:m.name, size:m.size, color:m.color, axialTiltDeg:m.tilt });
      body.group.add(mBody.group);
      moons.push({ def:m, node:mBody, orbitAngle: Math.random()*Math.PI*2 });
    }
  }

  // gravity ring visual
  const MASS_RATIO = { 'ìˆ˜ì„±':0.055,'ê¸ˆì„±':0.815,'ì§€êµ¬':1.0,'í™”ì„±':0.107,'ëª©ì„±':317.8,'í† ì„±':95.2,'ì²œì™•ì„±':14.5,'í•´ì™•ì„±':17.1 };
  const massRatio = MASS_RATIO[def.name] || 0.2;
  const MAX_MASS = 317.8;
  const gravityRadius = Math.max(18, def.a * 0.20 + (massRatio / MAX_MASS) * def.a * 2.0);
  const ringMesh = new THREE.Mesh(
    new THREE.RingGeometry(gravityRadius*0.95, gravityRadius*1.05, 64).rotateX(-Math.PI/2),
    new THREE.MeshBasicMaterial({ color: def.color, transparent:true, opacity:0.06, side:THREE.DoubleSide })
  );
  ringMesh.visible = document.getElementById ? false : false; // will position in tick

  const ps = {
    def, a, b, e,
    transform, orbitLine,
    node: body,
    moons,
    orbitAngle: Math.random()*Math.PI*2,
    rotPeriodHours: def.rotH,
    gravityRadius,
    massRatio,
    _gravRing: ringMesh,
    _destroyed: false
  };
  scene.add(ringMesh);
  planetStates.push(ps);
  bodies[def.name] = body.group;
}

// ---------- UI bindings ----------
const speed = document.getElementById('speed');
const speedNum = document.getElementById('speedNum');
function setRate(v){ timeScale = Math.max(0, Number(v) || 0); speed.value = String(timeScale); speedNum.value = String(timeScale); }
speed.addEventListener('input', e=> setRate(e.target.value));
speedNum.addEventListener('input', e=> setRate(e.target.value));
document.querySelectorAll('.btn[data-rate]').forEach(b=> b.addEventListener('click', ()=> setRate(b.dataset.rate)));

const focusSel = document.getElementById('focusSel');
function applyFocus(){
  const v = focusSel.value;
  if (v === 'ììœ (ìˆ˜ë™)') focusTarget = null;
  else if (v === 'íƒœì–‘') focusTarget = sun;
  else focusTarget = bodies[v] || null;
  updateCam();
}
focusSel.addEventListener('change', applyFocus);

const axisToggle = document.getElementById('axisToggle');
axisToggle.addEventListener('change', ()=> axisList.forEach(ax => ax.visible = axisToggle.checked));
axisList.forEach(ax => ax.visible = true);

// ---------- mouse controls ----------
let dragging=false, px=0, py=0, button=0;
app.addEventListener('mousedown', e=>{ dragging=true; px=e.clientX; py=e.clientY; button=e.button; });
window.addEventListener('mouseup', ()=> dragging=false);
app.addEventListener('contextmenu', e=> e.preventDefault());

window.addEventListener('mousemove', e=>{
  if (!dragging) return;
  const dx = (e.clientX - px), dy = (e.clientY - py);
  if (button === 0) { theta -= dx * 0.005; phi -= dy * 0.005; const eps = 0.001; phi = Math.max(eps, Math.min(Math.PI-eps, phi)); }
  else if (button === 2) { if (!focusTarget) { const s = radius * 0.0012; camera.updateMatrixWorld(); const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); const right = fwd.clone().cross(camera.up).normalize(); const up = camera.up.clone().normalize(); manualTarget.addScaledVector(right, -dx*s); manualTarget.addScaledVector(up, dy*s); } }
  px = e.clientX; py = e.clientY; updateCam();
});
app.addEventListener('wheel', e=>{ e.preventDefault(); radius *= (1 + Math.sign(e.deltaY)*0.08); radius = Math.max(30, Math.min(2000, radius)); updateCam(); },{passive:false});

// ---------- Entities (ê°„ë‹¨íˆ ì¬ì‚¬ìš©) ----------
const ships = [];
const asteroids = [];
const explosions = [];
const raycaster = new THREE.Raycaster();
const mouseVec = new THREE.Vector2();
const groundPlane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);

function pointerToWorld(clientX, clientY){
  const rect = renderer.domElement.getBoundingClientRect();
  mouseVec.x = ((clientX - rect.left) / rect.width) * 2 - 1;
  mouseVec.y = -((clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouseVec, camera);
  const p = new THREE.Vector3();
  raycaster.ray.intersectPlane(groundPlane, p);
  return p;
}

function spawnExplosion(position){
  const group = [];
  const particleCount = 12 + Math.floor(Math.random()*18);
  for (let i=0;i<particleCount;i++){
    const g = new THREE.SphereGeometry(0.3 + Math.random()*0.6, 6,6);
    const mat = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(0.05 + Math.random()*0.08, 0.85, 0.5), transparent:true });
    const m = new THREE.Mesh(g, mat);
    m.position.copy(position);
    m.userData.v = new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.2)*2, (Math.random()-0.5)*2);
    scene.add(m);
    group.push(m);
  }
  explosions.push({ particles:group, life:1.6, age:0 });
}

function spawnAsteroidAt(pos){
  const geom = new THREE.SphereGeometry(0.6 + Math.random()*1.4, 8,8);
  const mat = new THREE.MeshStandardMaterial({ color:0x9e9e9e, roughness:1.0 });
  const m = new THREE.Mesh(geom, mat);
  m.position.copy(pos);
  scene.add(m);
  const vel = new THREE.Vector3((Math.random()-0.5)*0.6, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.6);
  asteroids.push({ mesh:m, vel, remove:false });
}

function spawnShipAt(pos){
  const geom = new THREE.ConeGeometry(1.0, 2.4, 12);
  const mat = new THREE.MeshStandardMaterial({ color:0x66ffff, emissive:0x113344, roughness:0.4 });
  const m = new THREE.Mesh(geom, mat);
  m.rotation.x = Math.PI/2;
  m.position.copy(pos);
  scene.add(m);
  const ship = { mesh:m, vel:new THREE.Vector3(0,0,0), ai:{ mode:'idle', brain:null }, remove:false };
  ships.push(ship);
  return ship;
}

document.getElementById('spawnAsteroidBtn').addEventListener('click', ()=>{
  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
  const pos = camera.position.clone().add(dir.multiplyScalar(radius * 0.6));
  spawnAsteroidAt(pos);
});
document.getElementById('spawnShipBtn').addEventListener('click', ()=>{
  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
  const pos = camera.position.clone().add(dir.multiplyScalar(radius * 0.6));
  spawnShipAt(pos);
});
document.getElementById('clearShipsBtn').addEventListener('click', ()=>{
  for (const s of ships) scene.remove(s.mesh);
  ships.length = 0;
});
renderer.domElement.addEventListener('pointerdown', (ev)=>{
  if (ev.button !== 0) return;
  const p = pointerToWorld(ev.clientX, ev.clientY);
  if (ev.shiftKey) spawnAsteroidAt(p);
  else spawnShipAt(p);
});

// ---------- entity updates ----------
function updateEntities(dtSec){
  for (let i=explosions.length-1;i>=0;i--){
    const ex = explosions[i]; ex.age += dtSec;
    for (const p of ex.particles){
      p.position.addScaledVector(p.userData.v, dtSec*4);
      p.material.opacity = Math.max(0, 1 - ex.age/ex.life);
      p.scale.setScalar(1 + ex.age*1.5);
    }
    if (ex.age >= ex.life){
      for (const p of ex.particles) scene.remove(p);
      explosions.splice(i,1);
    }
  }

  // planet world positions cache
  const planetPositions = planetStates.map(ps => {
    const pos = new THREE.Vector3();
    ps.node.group.getWorldPosition(pos);
    return { ps, pos };
  });

  // asteroids
  for (let i=asteroids.length-1;i>=0;i--){
    const a = asteroids[i];
    if (a.remove){ scene.remove(a.mesh); asteroids.splice(i,1); continue; }
    const acc = new THREE.Vector3();
    for (const {ps, pos} of planetPositions){
      if (ps._destroyed) continue;
      const rVec = pos.clone().sub(a.mesh.position);
      const dist = rVec.length();
      if (dist < ps.gravityRadius && dist > 0.1){
        const strength = (ps.massRatio / 317.8) * 600;
        const aMag = strength / (dist*dist + 1);
        acc.addScaledVector(rVec.normalize(), aMag);
        if (document.getElementById('showGravity').checked){
          a.mesh.material.emissive = new THREE.Color(ps.def.color).multiplyScalar(0.12);
        }
      }
    }
    a.vel.add(acc.multiplyScalar(dtSec));
    a.mesh.position.addScaledVector(a.vel, dtSec);
    for (const {ps, pos} of planetPositions){
      if (ps._destroyed) continue;
      const dist = pos.distanceTo(a.mesh.position);
      const approxPlanetRadius = ps.def.size * SIZE * 1.0;
      if (dist < approxPlanetRadius * 0.9 + (a.mesh.geometry.parameters.radius || 1.0)){
        if (!ps._destroyed){
          ps._destroyed = true;
          if (ps.node.group.children.length) ps.node.group.remove(ps.node.group.children[0]);
          if (ps._gravRing) scene.remove(ps._gravRing);
          spawnExplosion(pos);
        }
        a.remove = true;
        break;
      }
    }
    if (a.remove){ scene.remove(a.mesh); asteroids.splice(i,1); continue; }
  }

  // ships (simplified)
  for (let i=ships.length-1;i>=0;i--){
    const s = ships[i];
    if (s.remove){ scene.remove(s.mesh); ships.splice(i,1); continue; }
    const acc = new THREE.Vector3();
    for (const {ps, pos} of planetPositions){
      if (ps._destroyed) continue;
      const rVec = pos.clone().sub(s.mesh.position);
      const dist = rVec.length();
      if (dist < ps.gravityRadius && dist > 0.1){
        const strength = (ps.massRatio / 317.8) * 600;
        const aMag = strength / (dist*dist + 1);
        acc.addScaledVector(rVec.normalize(), aMag);
        if (document.getElementById('showGravity').checked) s.mesh.material.emissive = new THREE.Color(ps.def.color).multiplyScalar(0.08);
      }
    }
    s.vel.add(acc.multiplyScalar(dtSec));
    s.mesh.position.addScaledVector(s.vel, dtSec);
    const speedMag = s.vel.length();
    if (speedMag > 0.0001){
      const dir = s.vel.clone().normalize();
      const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), dir);
      s.mesh.quaternion.slerp(quat, 0.06);
    }
    for (const {ps, pos} of planetPositions){
      if (ps._destroyed) continue;
      const dist = pos.distanceTo(s.mesh.position);
      const approxPlanetRadius = ps.def.size * SIZE * 1.0;
      if (dist < approxPlanetRadius * 0.9 + 1.0){
        s.remove = true;
        spawnExplosion(pos);
        break;
      }
    }
  }

  updateCam();
}

// ---------- tick: ì¼€í”ŒëŸ¬ ê¸°ë°˜ ê°ì†ë„ + ê¶¤ë„ë©´ ì ìš© ----------
let last = performance.now();

// choose Earth as normalization reference
const earthDef = planetDefs.find(p=>p.name==='ì§€êµ¬');
const earth_a = earthDef.a;
const earth_orbitDays = earthDef.orbit;
const earthBaseOmega = 2*Math.PI / earth_orbitDays; // rad/day

function tick(now){
  const dtSec = (now - last) / 1000; last = now;
  const dtDays = dtSec * timeScale;

  sun.rotation.y += dtDays * (2*Math.PI / 25.0);

  for (const ps of planetStates){
    if (ps._destroyed) {
      ps.orbitAngle += dtDays * (2*Math.PI / Math.max(1, ps.def.orbit));
      continue;
    }

    // ì¼€í”ŒëŸ¬ ê¸°ë°˜ ê°ì†ë„: Ï‰ = Ï‰_earth * (a_earth / a)^(3/2)
    const a = ps.a;
    const omega = earthBaseOmega * Math.pow(earth_a / a, 1.5);
    ps.orbitAngle += omega * dtDays;

    // orbital-plane coordinates
    const ang = ps.orbitAngle;
    const x_orb = ps.a * (Math.cos(ang) - ps.e);
    const y_orb = ps.b * Math.sin(ang);
    const vOrb = new THREE.Vector3(x_orb, y_orb, 0);

    // transform into world using precomputed transform
    const worldPos = vOrb.clone().applyMatrix4(ps.transform);
    ps.node.group.position.copy(worldPos);

    // rotate spin
    const rotDays = Math.abs(ps.rotPeriodHours)/24;
    const rotSgn = ps.rotPeriodHours >= 0 ? 1 : -1;
    if (rotDays > 0){
      if (ps.node.group.children[0]) ps.node.group.children[0].rotation.y += rotSgn * dtDays * (2*Math.PI / rotDays);
    }

    // position gravity ring (flat on ecliptic for clarity) â€” project ring roughly around worldPos
    if (ps._gravRing){
      ps._gravRing.position.copy(worldPos).y += 0.01;
      ps._gravRing.rotation.x = -Math.PI/2;
      ps._gravRing.visible = (document.getElementById('showGravity').checked && !ps._destroyed);
    }

    // moons (local simple circular orbits, not inclined)
    for (let i=0;i<ps.moons.length;i++){
      const m = ps.moons[i];
      const mdef = ps.def.moons[i];
      m.orbitAngle += dtDays * (2*Math.PI / m.def.orbit);
      const ca = Math.cos(m.orbitAngle), sa = Math.sin(m.orbitAngle);
      const mx = ca * m.def.a;
      const mz = -sa * m.def.a;
      m.node.group.position.set(mx, 0, mz);
      const mRotDays = Math.abs(m.def.rotH || 24)/24;
      if (mRotDays > 0 && m.node.group.children[0]) m.node.group.children[0].rotation.y += dtDays * (2*Math.PI / mRotDays);
    }
  }

  updateEntities(dtSec);
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

// ---------- resize ----------
addEventListener('resize', ()=>{
  const w = app.clientWidth, h = app.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
});

// ---------- initial ----------
document.getElementById('speed').value = '2';
document.getElementById('speedNum').value = '2';
timeScale = 2;
focusSel.value = 'ì§€êµ¬'; applyFocus();
radius = 220; updateCam();

</script>
</body>
</html>






