<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>íƒœì–‘ê³„ + PETS / SAC RL</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #051022;
      color: #e9ecff;
      font: 13px/1.45 system-ui;
      overflow: hidden;
    }
    #app {
      position: fixed;
      inset: 0;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    .ui {
      position: fixed;
      left: 12px;
      top: 12px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
      padding: 10px;
      border-radius: 10px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      max-width: 96vw;
      z-index: 10;
    }
    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .btn {
      cursor: pointer;
      padding: 6px 9px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color: #e9ecff;
    }
    input[type=range] { width: 200px; }
    input[type=number],
    input[type=text] { width: 70px; }
    select {
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(0,0,0,.3);
      color: #e9ecff;
      font-size: 12px;
    }
    .small {
      font-size: 11px;
      opacity: .85;
    }
    .hud {
      position: fixed;
      right: 10px;
      bottom: 120px;
      padding: 8px 10px;
      background: rgba(0,0,0,.45);
      border-radius: 8px;
      font-family: monospace;
      font-size: 11px;
      max-width: 260px;
      line-height: 1.3;
      z-index: 10;
    }
    /* ê²°ê³¼ ëª¨ë‹¬ ì˜¤ë²„ë ˆì´ */
    #resultOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    #resultModal {
      background: #0b1220;
      border: 1px solid rgba(255,255,255,.3);
      border-radius: 14px;
      padding: 20px 36px;
      box-shadow: 0 18px 40px rgba(0,0,0,.7);
      text-align: center;
      min-width: 260px;
    }
    #resultModal h2 {
      margin: 0 0 6px;
      font-size: 20px;
    }
    #resultModal .percent {
      font-size: 32px;
      font-weight: bold;
      margin: 4px 0 12px;
      color: #ffe066;
    }
    #sideLog {
      position: fixed;
      right: 10px;
      bottom: 10px;
      padding: 8px 10px;
      background: rgba(0,0,0,.4);
      border-radius: 8px;
      font-size: 11px;
      max-width: 260px;
      max-height: 30vh;
      overflow-y: auto;
      z-index: 10;
    }
    #sideLog h3 {
      margin: 0 0 4px;
      font-size: 12px;
      opacity: .9;
    }
  </style>
</head>
<body>
<div id="app"></div>

<!-- UI íŒ¨ë„ -->
<div class="ui">
  <div class="row">
    <label for="speed">ì†ë„ (ì¼/ì´ˆ)</label>
    <input id="speed" type="range" min="0" max="500" step="0.1" value="0.3" />
    <input id="speedNum" type="text" value="0.3" />
    <button class="btn" data-rate="1">1Ã—</button>
    <button class="btn" data-rate="10">10Ã—</button>
    <button class="btn" data-rate="100">100Ã—</button>
  </div>

  <div class="row">
    <label for="focusSel">ì¤‘ì‹¬ì </label>
    <select id="focusSel">
      <option>ììœ (ìˆ˜ë™)</option>
      <option selected>íƒœì–‘</option>
      <option>ìˆ˜ì„±</option>
      <option>ê¸ˆì„±</option>
      <option>ì§€êµ¬</option>
      <option>ë‹¬</option>
      <option>í™”ì„±</option>
      <option>ëª©ì„±</option>
      <option>í† ì„±</option>
      <option>ì²œì™•ì„±</option>
      <option>í•´ì™•ì„±</option>
      <option>ëª…ì™•ì„±</option>
    </select>
    <label>
      <input id="axisToggle" type="checkbox" checked />
      ìì „ì¶• í‘œì‹œ
    </label>
    <label>
      <input id="gravToggle" type="checkbox" />
      ì¤‘ë ¥ì¥ í‘œì‹œ(í–‰ì„± í¬í•¨)
    </label>
  </div>

  <div class="row">
    <button class="btn" id="spawnShip">ìš°ì£¼ì„  ì†Œí™˜ (PETS/SAC ë¹„êµ)</button>
    <button class="btn" id="spawnAst">ì†Œí–‰ì„± êµ° ì†Œí™˜</button>
    <button class="btn" id="spawnField">ì—­ì¥ ìƒì„±</button>
    <button class="btn" id="clearObjs">ëª¨ë‘ ì‚­ì œ</button>
  </div>

  <!-- RL ê´€ë ¨ UI -->
  <div class="row">
    <label for="autoTarget">RL ëª©í‘œ</label>
    <select id="autoTarget">
      <option>ì§€êµ¬</option>
      <option>ë‹¬</option>
      <option>í™”ì„±</option>
      <option>ëª©ì„±</option>
      <option>í† ì„±</option>
      <option>ì²œì™•ì„±</option>
      <option>í•´ì™•ì„±</option>
      <option>ëª…ì™•ì„±</option>
      <option>íƒœì–‘</option>
      <option>ìˆ˜ì„±</option>
      <option>ê¸ˆì„±</option>
    </select>
  </div>

  <div class="row small">
    <label><input id="petsEnable" type="checkbox" checked /> PETS</label>
    <label><input id="sacEnable" type="checkbox" checked /> SAC</label>
    <span>
      PETS F:<span id="petsFuel">-</span> R:<span id="petsRew">0</span> |
      SAC F:<span id="sacFuel">-</span> R:<span id="sacRew">0</span>
    </span>
  </div>

  <!-- PETS vs SAC ì„ íƒ ë²„íŠ¼ -->
  <div class="row" id="choiceRow" style="display:none;">
    <button class="btn" id="choosePETS">PETS ì‚¬ìš©</button>
    <button class="btn" id="chooseSAC">SAC ì‚¬ìš©</button>
  </div>

  <div class="row small">
    <div>
      ì‹œì‘ ì‹œê°:
      <span id="startTime">2025-01-01 00:00:00</span>
    </div>
    <div class="small">â€¢ ì¢Œí´ë¦­: íšŒì „ Â· íœ : ì¤Œ Â· ìš°í´ë¦­: íŒ¬</div>
  </div>
</div>

<div class="hud" id="hudBox">
  PETS / SAC ìƒíƒœ<br>
  --------------------------<br>
  ì´ˆê¸°í™” ì¤‘...
</div>

<!-- ê²°ê³¼ ëª¨ë‹¬ -->
<div id="resultOverlay">
  <div id="resultModal">
    <h2>ë¹„í–‰ ê²°ê³¼</h2>
    <div id="resultLine"></div>
    <div class="percent" id="resultPercent">ì„±ê³µë¥  0%</div>
    <div style="font-size:12px; opacity:.8;">(ëª¨ë‹¬ ë°”ê¹¥ì„ í´ë¦­í•˜ë©´ ë‹«íˆê³  ì´ˆê¸°í™”)</div>
  </div>
</div>

<!-- ê²°ê³¼ ë¡œê·¸ -->
<div id="sideLog">
  <h3>ê²°ê³¼ ë¡œê·¸</h3>
  <div id="logContent"></div>
</div>

<script src="./three.min.js"></script>
<script>
// Vector3.sub()ê°€ undefinedë¥¼ ë°›ì•„ë„ ì£½ì§€ ì•Šë„ë¡ ë³´í˜¸ë§‰ì„ ì”Œì›€
(function () {
  const oldSub = THREE.Vector3.prototype.sub;
  THREE.Vector3.prototype.sub = function (v) {
    if (!v) {
      console.warn("Vector3.sub called with undefined, ignore this call");
      return this;
    }
    return oldSub.call(this, v);
  };

  const oldSubVectors = THREE.Vector3.prototype.subVectors;
  THREE.Vector3.prototype.subVectors = function (a, b) {
    if (!a || !b) {
      console.warn("Vector3.subVectors called with undefined, ignore this call");
      return this;
    }
    return oldSubVectors.call(this, a, b);
  };
})();
</script>
<script>
/* ========== ê¸°ë³¸ Three.js ì„¸íŒ… ========== */
const app = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(app.clientWidth, app.clientHeight);
renderer.setClearColor(0x051022, 1);
app.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  60,
  app.clientWidth / app.clientHeight,
  0.1,
  20000
);

// ì¹´ë©”ë¼ ê¶¤ë„ íŒŒë¼ë¯¸í„°
let radius = 260;
let phi    = THREE.MathUtils.degToRad(28);
let theta  = THREE.MathUtils.degToRad(40);

const manualTarget = new THREE.Vector3(0, 0, 0);
let focusTarget = null;

function getTarget() {
  return focusTarget
    ? focusTarget.getWorldPosition(new THREE.Vector3())
    : manualTarget;
}
function updateCam() {
  const t = getTarget();
  const x = t.x + radius * Math.sin(phi) * Math.cos(theta);
  const y = t.y + radius * Math.cos(phi);
  const z = t.z + radius * Math.sin(phi) * Math.sin(theta);
  camera.position.set(x, y, z);
  camera.lookAt(t);
}
updateCam();

/* ========== ì‹œê°„ / ìƒìˆ˜ ========== */
let simDate   = new Date('2025-01-01T00:00:00Z');
let timeScale = 0.3;
const G       = 5e-6;
const MAX_ACC = 0.3;

scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const sunLight = new THREE.PointLight(0xffffff, 2.2, 0, 2);
scene.add(sunLight);

const bodies          = {};
const heavyBodies     = [];
const axisList        = [];
const dynamicObjects  = [];
const lagrangeHelpers = [];
const warpFields      = [];   // ì—­ì¥ í•„ë“œ
const thrustParticles = [];

const SIZE = 1;
const DIST = 1;

/* ========== ìœ í‹¸ ========== */
function mkAxis(len) {
  const geo = new THREE.CylinderGeometry(0.04, 0.04, len, 8);
  const mat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.75,
  });
  const cyl = new THREE.Mesh(geo, mat);
  cyl.position.y = 0;
  return cyl;
}

/* ========== ì²œì²´ ìƒì„± ========== */
function createBody({
  name,
  parent          = scene,
  size            = 1,
  color           = 0xffffff,
  orbitDist       = 0,
  orbitPeriodDays = 0,
  rotPeriodHours  = 24,
  axialTiltDeg    = 0,
  ecc             = 0,
  orbitInc        = 0,
  massScale       = 1,
} = {}) {
  const pivot = new THREE.Group();
  parent.add(pivot);
  pivot.rotation.x = THREE.MathUtils.degToRad(orbitInc || 0);

  const spin = new THREE.Group();
  spin.rotation.z = THREE.MathUtils.degToRad(axialTiltDeg || 0);
  pivot.add(spin);

  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(size * SIZE, 32, 32),
    new THREE.MeshStandardMaterial({
      color,
      roughness: 0.85,
    })
  );
  spin.add(mesh);

  const axis = mkAxis(size * 3);
  spin.add(axis);
  axisList.push(axis);

  const mass = Math.max(1e-6, Math.pow(size, 3) * massScale);

  const body = {
    name,
    pivot,
    spin,
    mesh,
    orbitDist: orbitDist * DIST,
    orbitPeriodDays,
    rotPeriodHours,
    mass,
    ecc,
    orbitInc,
    meanAnomaly: Math.random() * Math.PI * 2,
    semiMajor: orbitDist * DIST,
  };

  bodies[name] = body;
  heavyBodies.push(body);
  return body;
}

/* ========== í–‰ì„± ë°ì´í„° ========== */
const defs = [
  { name: 'íƒœì–‘', size: 10,   dist: 0,   orbit: 0,       rotH: 25.38,           tilt: 7.25,  ecc: 0,          orbitInc: 0,    massScale: 1e6,   color: '#ffd54a' },
  { name: 'ìˆ˜ì„±', size: 0.9,  dist: 16,  orbit: 87.969,  rotH: 58.6462 * 24,    tilt: 0.01,  ecc: 0.205630,   orbitInc: 7.005, massScale: 0.055, color: '#555555' },
  { name: 'ê¸ˆì„±', size: 1.1,  dist: 22,  orbit: 224.701, rotH: -243.0185 * 24,  tilt: 177.36, ecc: 0.006772, orbitInc: 3.394, massScale: 0.815, color: '#fff7c4' },
  { name: 'ì§€êµ¬', size: 1.2,  dist: 30,  orbit: 365.256, rotH: 0.99726963 * 24, tilt: 23.44, ecc: 0.01671123, orbitInc: 0.0,   massScale: 1,     color: '#3a82ff' },
  { name: 'í™”ì„±', size: 0.9,  dist: 38,  orbit: 686.98,  rotH: 1.02595676 * 24, tilt: 25.19, ecc: 0.0933941, orbitInc: 1.85,  massScale: 0.107, color: '#d14b3a' },
  { name: 'ëª©ì„±', size: 4.0,  dist: 60,  orbit: 4332.59, rotH: 0.41354 * 24,    tilt: 3.13,  ecc: 0.04839266, orbitInc: 1.305, massScale: 318,   color: '#e6b56a' },
  { name: 'í† ì„±', size: 3.6,  dist: 78,  orbit: 10756.2, rotH: 0.44401 * 24,    tilt: 26.73, ecc: 0.055723,   orbitInc: 2.485, massScale: 95,    color: '#d2b48c' },
  { name: 'ì²œì™•ì„±', size: 2.9, dist: 96,  orbit: 30707.49, rotH: -0.71833 * 24, tilt: 97.77, ecc: 0.04565, orbitInc: 0.77,  massScale: 14,    color: '#6ecff6' },
  { name: 'í•´ì™•ì„±', size: 2.8, dist: 112, orbit: 60223.35, rotH: 0.67125 * 24,  tilt: 28.32, ecc: 0.00859048, orbitInc: 1.769, massScale: 17,   color: '#264bff' },
  { name: 'ëª…ì™•ì„±', size: 0.5, dist: 140, orbit: 90560,   rotH: -6.3872 * 24,   tilt: 122.53, ecc: 0.24883, orbitInc: 17.14, massScale: 0.0022, color: '#bbaea0' },
];

const planetStates = [];
for (const p of defs) {
  const body = createBody({
    name: p.name,
    size: p.size,
    orbitDist: p.dist,
    orbitPeriodDays: p.orbit,
    rotPeriodHours: p.rotH,
    axialTiltDeg: p.tilt,
    ecc: p.ecc,
    orbitInc: p.orbitInc,
    massScale: p.massScale,
    color: p.color,
  });
  planetStates.push({ def: p, node: body, moons: [] });
}

/* ========== ê¶¤ë„ íƒ€ì› ========== */
function createOrbitLine({a,e,iDeg,omegaDeg,OmegaDeg,color=0xffffff,opacity=0.25,segments=360}) {
  const pts = [];
  const iRad      = THREE.MathUtils.degToRad(iDeg || 0);
  const omegaRad  = THREE.MathUtils.degToRad(omegaDeg || 0);
  const OmegaRad  = THREE.MathUtils.degToRad(OmegaDeg || 0);
  for (let k = 0; k <= segments; k++) {
    const nu = (2 * Math.PI * k) / segments;
    const r = (a * (1 - e * e)) / (1 + e * Math.cos(nu));
    const v = new THREE.Vector3(r * Math.cos(nu),0,r * Math.sin(nu));
    v.applyAxisAngle(new THREE.Vector3(0, 1, 0), omegaRad);
    v.applyAxisAngle(new THREE.Vector3(1, 0, 0), iRad);
    v.applyAxisAngle(new THREE.Vector3(0, 1, 0), OmegaRad);
    pts.push(v);
  }
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const mat = new THREE.LineBasicMaterial({color,transparent:true,opacity});
  const line = new THREE.Line(geo, mat);
  scene.add(line);
  return line;
}

for (const ps of planetStates) {
  const node = ps.node;
  if (node.orbitPeriodDays <= 0) continue;
  const name = ps.def.name;
  let col = 0x444c66;
  if (name === 'ìˆ˜ì„±') col = 0xaaaaaa;
  else if (name === 'ê¸ˆì„±') col = 0xffc966;
  else if (name === 'ì§€êµ¬') col = 0x3a82ff;
  else if (name === 'í™”ì„±') col = 0xff5533;
  else if (name === 'ëª©ì„±') col = 0xe6b56a;
  else if (name === 'í† ì„±') col = 0xd2b48c;
  else if (name === 'ì²œì™•ì„±') col = 0x6ecff6;
  else if (name === 'í•´ì™•ì„±') col = 0x264bff;
  else if (name === 'ëª…ì™•ì„±') col = 0xbbaea0;
  createOrbitLine({
    a: node.semiMajor,
    e: node.ecc || 0,
    iDeg: node.orbitInc || 0,
    omegaDeg: 0,
    OmegaDeg: 0,
    color: col,
    opacity: 0.25,
    segments: 400,
  });
}

/* ========== ë‹¬/ìœ„ì„± + í† ì„± ê³ ë¦¬ ========== */

// 1) ì§€êµ¬ì˜ ë‹¬
(() => {
  const earth = bodies['ì§€êµ¬'];
  if (!earth) return;

  const moon = createBody({
    name: 'ë‹¬',
    parent: earth.pivot,
    size: 0.35,
    orbitDist: 4,
    orbitPeriodDays: 27.322,
    rotPeriodHours: 655.7,
    axialTiltDeg: 6.68,
    massScale: 0.0123,
    color: '#cfd6ff',
    showOrbit: false,
  });

  planetStates.find(x => x.def.name === 'ì§€êµ¬').moons.push({
    ...moon,
    orbitDist: 4,
    orbitPeriodDays: 27.322,
    orbitalAngle: Math.random() * Math.PI * 2,
  });
})();

// 2) ëŒ€í‘œ ìœ„ì„±ë“¤
const majorMoons = {
  'ëª©ì„±': [
    ['ì´ì˜¤',      7.0,   1.769,  '#ffd1a8'],
    ['ìœ ë¡œíŒŒ',    9.0,   3.551,  '#cfe8ff'],
    ['ê°€ë‹ˆë©”ë°', 11.0,   7.154,  '#e9d5b3'],
    ['ì¹¼ë¦¬ìŠ¤í† ', 14.0,  16.689,  '#c2b7a1'],
  ],
  'í† ì„±': [
    ['íƒ€ì´íƒ„',    10.0,  15.95,  '#d9c28a'],
    ['ì—”ì…€ë¼ë‘ìŠ¤', 7.0,   1.37,  '#dfeaf7'],
  ],
  'ì²œì™•ì„±': [
    ['í‹°íƒ€ë‹ˆì•„',  7.0,   8.7,   '#cfe6ff'],
    ['ì˜¤ë² ë¡ ',    9.0,  13.5,   '#bfb8a6'],
  ],
  'í•´ì™•ì„±': [
    ['íŠ¸ë¦¬í†¤',    7.0,   5.88,  '#98bfff'],
  ],
  'ëª…ì™•ì„±': [
    ['ì¹´ë¡ ',      3.0,   6.387, '#b0a59a'],
  ],
};

// ê° í–‰ì„±ì— ìœ„ì„± ìƒì„±
for (const ps of planetStates) {
  const name   = ps.def.name;
  const planet = ps.node;
  const list   = majorMoons[name];
  if (!list) continue;

  for (const [mName, mDist, mPeriod, mColor] of list) {
    const moonBody = createBody({
      name: mName,
      parent: planet.pivot,
      size: 0.25,
      color: mColor,
      orbitDist: mDist,
      orbitPeriodDays: mPeriod,
      rotPeriodHours: mPeriod*24,
      massScale: 0.01,
    });

    ps.moons.push({
      ...moonBody,
      orbitDist: mDist,
      orbitPeriodDays: mPeriod,
      orbitalAngle: Math.random() * Math.PI * 2,
    });
  }
}

// 3) í† ì„± ê³ ë¦¬
(() => {
  const saturn = bodies['í† ì„±'];
  if (!saturn) return;

  const r = 3.6 * 2;
  const geo = new THREE.RingGeometry(r, r * 1.6, 128);
  geo.rotateX(-Math.PI / 2);
  const mat = new THREE.MeshStandardMaterial({
    color: 0xd8cfae,
    roughness: 0.95,
    transparent: true,
    opacity: 0.6,
    side: THREE.DoubleSide,
  });
  const ring = new THREE.Mesh(geo, mat);
  saturn.pivot.add(ring);
})();

/* ========== ì¤‘ë ¥ / ê´€ì¸¡ ========== */

// ì—­ì¥, íŠ¹ìˆ˜ íš¨ê³¼ ì „í˜€ ì—†ì´ í–‰ì„±ë“¤ ì¤‘ë ¥ë§Œ ê³„ì‚°
function computeGravitationalAccelerationRaw(pos) {
  const acc = new THREE.Vector3();
  for (const b of heavyBodies) {
    const bp   = b.pivot.getWorldPosition(new THREE.Vector3());
    const rVec = new THREE.Vector3().subVectors(bp, pos);
    const r    = rVec.length();
    if (r === 0) continue;

    const baseR = b.mesh.geometry.parameters.radius || 1;
    let maxRangeMul = 16;
    let effMass     = b.mass;
    if (b.name === 'íƒœì–‘') effMass *= 0.0002;

    const rMax = baseR * maxRangeMul;
    if (r > rMax) continue;

    const r2 = Math.max(100, r * r);
    let accMag = (G * effMass) / r2;
    if (accMag > MAX_ACC) accMag = MAX_ACC;

    acc.addScaledVector(rVec.normalize(), accMag);
  }
  return acc;
}

// ì˜ˆì¸¡ìš©: ë¯¸ë˜ ì‹œì (ghostDays)ì— í–‰ì„±ë“¤ì´ ì–´ë”” ìˆëŠ”ì§€ ê¸°ì¤€ìœ¼ë¡œ ì¤‘ë ¥ ê³„ì‚°
function computeGravitationalAccelerationGhost(pos, ghostDays) {
  const acc = new THREE.Vector3();

  for (const b of heavyBodies) {
    // ê³µì „í•˜ëŠ” í–‰ì„±ì€ ë¯¸ë˜ ìœ„ì¹˜, íƒœì–‘ì²˜ëŸ¼ orbitPeriodDays=0 ì¸ ì• ë“¤ì€ í˜„ì¬ ìœ„ì¹˜
    let bp;
    if (b.orbitPeriodDays && b.orbitPeriodDays > 0) {
      bp = getFuturePlanetPos(b, ghostDays);
    } else {
      bp = b.pivot.getWorldPosition(new THREE.Vector3());
    }

    const rVec = new THREE.Vector3().subVectors(bp, pos);
    const r    = rVec.length();
    if (r === 0) continue;

    const baseR = b.mesh.geometry.parameters.radius || 1;
    let maxRangeMul = 16;
    let effMass     = b.mass;
    if (b.name === 'íƒœì–‘') effMass *= 0.0002;

    const rMax = baseR * maxRangeMul;
    if (r > rMax) continue;

    const r2 = Math.max(100, r * r);
    let accMag = (G * effMass) / r2;
    if (accMag > MAX_ACC) accMag = MAX_ACC;

    acc.addScaledVector(rVec.normalize(), accMag);
  }
  return acc;
}


function computeGravitationalAcceleration(pos) {
  const acc = new THREE.Vector3();
  for (const b of heavyBodies) {
    const bp   = b.pivot.getWorldPosition(new THREE.Vector3());
    const rVec = new THREE.Vector3().subVectors(bp, pos);
    const r    = rVec.length();
    if (r === 0) continue;
    const baseR = b.mesh.geometry.parameters.radius || 1;
    let maxRangeMul = 16;
    let effMass     = b.mass;
    if (b.name === 'íƒœì–‘') effMass *= 0.0002;
    const rMax = baseR * maxRangeMul;
    if (r > rMax) continue;
    const r2 = Math.max(100, r * r);
    let accMag = (G * effMass) / r2;
    if (accMag > MAX_ACC) accMag = MAX_ACC;
    acc.addScaledVector(rVec.normalize(), accMag);
  }
  // ì—­ì¥ íš¨ê³¼ ë°˜ì˜
  return applyWarpFieldsToAcceleration(pos, acc);
}

function computePotentialEnergy(pos, mass=1) {
  let pe = 0;
  for (const b of heavyBodies) {
    const bp = b.pivot.getWorldPosition(new THREE.Vector3());
    const r  = bp.distanceTo(pos);
    if (r>0) pe += -G * b.mass * mass / r;
  }
  return pe;
}

// ì¶©ëŒ ìœ„í—˜ë„
function computeCollisionRisk(pos) {
  let risk = 0;

  // í–‰ì„±
  for (const b of heavyBodies) {
    const bp = b.pivot.getWorldPosition(new THREE.Vector3());
    const r  = bp.distanceTo(pos);
    const baseR = b.mesh.geometry.parameters.radius || 1;
    const safe  = baseR * 5;
    if (r < safe) {
      risk = Math.max(risk, (safe - r) / safe);
    }
  }

  // ì†Œí–‰ì„±
  for (const o of dynamicObjects) {
    if (!o.alive || o.type !== 'asteroid') continue;
    const r  = o.pos.distanceTo(pos);
    const safe = (o.radius || 0.5) * 4;
    if (r < safe) {
      risk = Math.max(risk, (safe - r) / safe);
    }
  }

  return Math.min(1, risk);
}

// ìœ„í—˜ ì§€ì—­ íšŒí”¼ ë²¡í„°
function computeAvoidanceVector(pos) {
  const dir = new THREE.Vector3();

  // í–‰ì„± íšŒí”¼
  for (const b of heavyBodies) {
    const bp = b.pivot.getWorldPosition(new THREE.Vector3());
    const v  = new THREE.Vector3().subVectors(pos, bp); // í–‰ì„±â†’ìš°ì£¼ì„ 
    v.y *= 0.2;   // ìœ„ë¡œ ë„ë§ê°€ëŠ” ì„±í–¥ ì¤„ì´ê¸°
    const d  = v.length();
    const baseR = b.mesh.geometry.parameters.radius || 1;
    const safe  = baseR * 5;

    if (d < safe && d > 1e-3) {
      const w = (safe - d) / safe;
      dir.addScaledVector(v.normalize(), w / d);
    }
  }

  // ì†Œí–‰ì„± íšŒí”¼
  for (const o of dynamicObjects) {
    if (!o.alive || o.type !== 'asteroid') continue;
    const v = new THREE.Vector3().subVectors(pos, o.pos);
    v.y *= 0.2;
    const d = v.length();
    const safe = (o.radius || 0.5) * 4;

    if (d < safe && d > 1e-3) {
      const w = (safe - d) / safe;
      dir.addScaledVector(v.normalize(), w / d);
    }
  }

  return dir;
}

// ì—­ì¥ ì •ë³´
function computeWarpFieldInfo(pos) {
  let maxInfluence = 0;
  let nearestDir   = new THREE.Vector3(0,0,0);
  for (const f of warpFields) {
    const d = f.center.distanceTo(pos);
    if (d > f.radius) continue;
    const inf = 1 - d / f.radius;
    if (inf > maxInfluence) {
      maxInfluence = inf;
      nearestDir.subVectors(f.center, pos).normalize();
    }
  }
  return { influence: maxInfluence, dir: nearestDir };
}

function getRLTargetPos() {
  const sel = document.getElementById('autoTarget').value;
  const b = bodies[sel];
  if (!b) return new THREE.Vector3(0,0,0);
  return b.pivot.getWorldPosition(new THREE.Vector3());
}

function getObservation(ship) {
  const targetPos = getRLTargetPos();
  const g        = computeGravitationalAcceleration(ship.pos);
  const toTarget = new THREE.Vector3().subVectors(targetPos, ship.pos);
  const dist     = toTarget.length();
  const vel      = ship.vel.clone();

  const ke       = 0.5 * ship.mass * vel.lengthSq();
  const pe       = computePotentialEnergy(ship.pos, ship.mass);
  const totalE   = ke + pe;
  const angMom   = ship.pos.clone().cross(vel);
  const collisionRisk = computeCollisionRisk(ship.pos);
  const warpInfo      = computeWarpFieldInfo(ship.pos);

  // ---- ì—¬ê¸°ì„œë¶€í„° ì¶”ê°€ ê³„ì‚° ----

  // 1) ëª©í‘œ ë°©í–¥ê³¼ ì†ë„ ë°©í–¥ì˜ ë‚´ì  (ì •ë ¬ë„)
  let targetVelDot = 0;
  if (vel.lengthSq() > 1e-8 && dist > 1e-8) {
    const vNorm  = vel.clone().normalize();
    const tNorm  = toTarget.clone().normalize();
    targetVelDot = vNorm.dot(tNorm);   // 1ì— ê°€ê¹Œìš°ë©´ "ëª©í‘œ ë°©í–¥ê³¼ ì˜ ì •ë ¬"
  }

  // 2) ì¤‘ë ¥ ê°€ì†ë„ì™€ ì†ë„ ë²¡í„°ì˜ ë‚´ì  (ì¤‘ë ¥ì„  íƒ€ëŠ” ì •ë„)
  let gravVelDot = 0;
  if (vel.lengthSq() > 1e-8 && g.lengthSq() > 1e-8) {
    const vNorm = vel.clone().normalize();
    const gNorm = g.clone().normalize();
    gravVelDot  = vNorm.dot(gNorm);
  }

  // 3) ë¼ê·¸ë‘ì£¼ í¬ì¸íŠ¸ ê´€ë ¨(í˜„ì¬ëŠ” ë”ë¯¸, ë‚˜ì¤‘ì— ì§„ì§œ êµ¬í˜„ ê°€ëŠ¥)
  const targetName = document.getElementById('autoTarget').value;
  const targetBody = bodies[targetName];
  let lgrgType = null;
  let lgrgDist = Infinity;
  let lgrgDir  = new THREE.Vector3(0, 0, 0);

  if (targetBody && typeof getNearestLagrangePointInfo === 'function') {
    const info = getNearestLagrangePointInfo(ship.pos, targetBody);
    if (info) {
      lgrgType = info.type ?? null;
      lgrgDist = info.dist ?? Infinity;
      if (info.toPoint instanceof THREE.Vector3) {
        lgrgDir = info.toPoint.clone().normalize();
      }
    }
  }

  // 4) ì¶©ëŒê¹Œì§€ ë‚¨ì€ ì‹œê°„(ì§€ê¸ˆì€ ë¯¸êµ¬í˜„ ìƒíƒœë¼ ë¬´í•œëŒ€ ì²˜ë¦¬)
  const collisionTTI = Infinity;

  // 5) GA(ì¤‘ë ¥ ë³´ì¡°) ê´€ë ¨ í”Œë˜ê·¸ (ì§€ê¸ˆì€ ì‚¬ìš© ì•ˆ í•¨)
  const gaAvailable = false;
  const distToGA    = Infinity;

  return {
    pos: ship.pos.clone(),
    vel,
    grav: g,
    toTarget,
    dist,
    fuel: ship.fuel,
    kinetic: ke,
    potential: pe,
    totalE,
    angMom,
    collisionRisk,
    warpInfluence: warpInfo.influence,
    warpDir: warpInfo.dir,

    // ë³´ìƒì‹ì—ì„œ ì“°ëŠ” ì¶”ê°€ í•­ëª©ë“¤
    targetVelDot,     // ëª©í‘œ í–¥í•´ ì–¼ë§ˆë‚˜ ì˜ ë‚ ê³  ìˆëŠ”ì§€
    gravVelDot,       // ì¤‘ë ¥ ë°©í–¥ê³¼ ì†ë„ ì •ë ¬ë„
    collisionTTI,     // ì¶©ëŒê¹Œì§€ ì‹œê°„(í˜„ì¬ ë”ë¯¸)
    gaAvailable,      // GA ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€(í˜„ì¬ false)
    distToGA,         // GA ìœ„ì¹˜ê¹Œì§€ ê±°ë¦¬(í˜„ì¬ ë¬´í•œëŒ€)
    lgrgType,         // 'L4' / 'L5' ë“± (í˜„ì¬ null)
    lgrgDist,         // ë¼ê·¸ë‘ì£¼ í¬ì¸íŠ¸ê¹Œì§€ ê±°ë¦¬
    lgrgDir           // ë¼ê·¸ë‘ì£¼ í¬ì¸íŠ¸ ë°©í–¥ ë‹¨ìœ„ ë²¡í„°
  };
}


/* ========== ì†Œí–‰ì„±/ìš°ì£¼ì„  ========== */

function getNearestShip(pos) {
  let best = null, bestDist = Infinity;
  for (const o of dynamicObjects) {
    if (o.type !== 'ship') continue;
    const d = o.pos.distanceTo(pos);
    if (d < bestDist) { bestDist=d; best=o; }
  }
  return best;
}

function spawnSpaceshipSimple(pos, vel, policyType, color) {
  const geo = new THREE.ConeGeometry(0.3, 0.8, 8);
  geo.rotateX(Math.PI / 2);
  const mat = new THREE.MeshStandardMaterial({ color });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(pos);
  scene.add(mesh);
  const ship = {
    type:'ship',
    mesh,
    pos: mesh.position.clone(),
    vel: vel.clone(),
    mass: 0.05,
    radius: 0.4,
    fuel: 2.0,
    maxThrust: 1,
    lastFuelUsed:0,
    prevGoalDist:null,
    totalReward:0,
    collided:false,
    policyType,
    alive:true
  };
  dynamicObjects.push(ship);
  return ship;
}

function spawnAsteroid(pos, vel) {
  const sBase = Math.random()*0.6+0.2;
  const s = sBase*0.5;
  const geo = new THREE.DodecahedronGeometry(s,0);
  const mat = new THREE.MeshStandardMaterial({color:0x999999});
  const mesh = new THREE.Mesh(geo,mat);
  mesh.position.copy(pos);
  scene.add(mesh);
  const obj = {
    type:'asteroid',
    mesh,
    pos: mesh.position.clone(),
    vel: vel.clone(),
    mass: Math.pow(s,3)*0.2,
    radius:s,
    alive:true
  };
  dynamicObjects.push(obj);
  return obj;
}

function spawnAsteroidSwarm(centerPos, ship) {
  const pos = centerPos.clone();
  let dirToShip = new THREE.Vector3(0,0,0);
  if (ship) {
    pos.y = ship.pos.y;
    dirToShip.subVectors(ship.pos,pos);
    if (dirToShip.lengthSq()>0) dirToShip.normalize();
  }
  const baseSpeed = ship ? 0.25 : 0.0;
  const baseVel = dirToShip.clone().multiplyScalar(baseSpeed);
  spawnAsteroid(pos,baseVel);
  const count = 6;
  for(let i=0;i<count;i++){
    const offset = new THREE.Vector3(
      (Math.random()-0.5)*4,0,(Math.random()-0.5)*4
    );
    const p = pos.clone().add(offset);
    let v = baseVel.clone();
    if (ship && baseSpeed>0){
      const randomDir = new THREE.Vector3(
        (Math.random()-0.5)*0.3,
        (Math.random()-0.5)*0.05,
        (Math.random()-0.5)*0.3
      );
      v.add(randomDir).multiplyScalar(0.8+Math.random()*0.6);
    }
    spawnAsteroid(p,v);
  }
}

/* === ì—­ì¥(ê³µê°„ ì™œê³¡ í•„ë“œ) ìƒì„± & ê°±ì‹  === */
function spawnWarpField() {
  const targetPos = getRLTargetPos();
  const mainShip  = activeShip || getNearestShip(targetPos);
  if (!mainShip) {
    console.warn('ì—­ì¥ì„ ë§Œë“¤ ìš°ì£¼ì„ ì´ ì—†ìŠµë‹ˆë‹¤.');
    return;
  }
  const center = new THREE.Vector3().lerpVectors(
    mainShip.pos,
    targetPos,
    0.5
  );
  const radius   = 40;
  const strength = 0.8;
  const life     = 80;

  const sGeo = new THREE.SphereGeometry(radius, 32, 32);
  const sMat = new THREE.MeshBasicMaterial({
    color: 0x8844ff,
    transparent: true,
    opacity: 0.06,
    wireframe: true,
  });
  const sphere = new THREE.Mesh(sGeo, sMat);
  sphere.position.copy(center);
  scene.add(sphere);

  warpFields.push({
    center,
    radius,
    strength,
    life,
    maxLife: life,
    sphere,
  });
}

function updateWarpFields(dtReal) {
  for (let i = warpFields.length - 1; i >= 0; i--) {
    const f = warpFields[i];
    f.life -= dtReal;
    if (f.life <= 0) {
      scene.remove(f.sphere);
      warpFields.splice(i, 1);
      continue;
    }
    const t = f.life / f.maxLife;
    f.sphere.material.opacity = 0.06 * t;
  }
}

// ì—­ì¥ì— ë”°ë¥¸ ì¤‘ë ¥ ì™œê³¡
function applyWarpFieldsToAcceleration(pos, acc) {
  if (!warpFields.length) return acc;

  const sunBody = bodies['íƒœì–‘'];
  const sunPos  = sunBody
    ? sunBody.pivot.getWorldPosition(new THREE.Vector3())
    : new THREE.Vector3(0, 0, 0);

  const targetPos = getRLTargetPos();

  for (const f of warpFields) {
    const d = f.center.distanceTo(pos);
    if (d > f.radius) continue;

    const falloff  = 1 - d / f.radius;
    const strength = f.strength * falloff;

    const weaken = 1 - 0.4 * strength;
    acc.multiplyScalar(weaken);

    const toTarget = new THREE.Vector3().subVectors(targetPos, pos).normalize();
    const toSun    = new THREE.Vector3().subVectors(sunPos, pos).normalize();
    const lateral  = new THREE.Vector3().crossVectors(toSun, new THREE.Vector3(0,1,0)).normalize();

    const warpDir = new THREE.Vector3()
      .addScaledVector(toTarget, 0.8)
      .addScaledVector(lateral, 0.4)
      .normalize();

    const baseMag  = acc.length();
    const extraMag = baseMag * 1.2 * strength;

    acc.addScaledVector(warpDir, extraMag);
  }
  return acc;
}

/* í­ë°œ ì´í™íŠ¸ */
function explodeAt(pos) {
  const group = new THREE.Group();
  for (let i=0;i<18;i++){
    const geo = new THREE.SphereGeometry(0.06,6,6);
    const mat = new THREE.MeshBasicMaterial({color:0xffaa44});
    const p = new THREE.Mesh(geo,mat);
    p.position.copy(pos);
    p.userData.v = new THREE.Vector3(
      (Math.random()-0.5)*2,
      (Math.random()-0.5)*2,
      (Math.random()-0.5)*2
    ).multiplyScalar(0.6);
    group.add(p);
  }
  scene.add(group);
  const t0 = performance.now();
  const id = setInterval(()=>{
    const dt=(performance.now()-t0)/1000;
    group.children.forEach(ch=>{
      ch.position.addScaledVector(ch.userData.v,0.04);
    });
    if(dt>1.5){
      clearInterval(id);
      scene.remove(group);
    }
  },50);
}

/* ì¶”ë ¥ íŒŒí‹°í´ */
function spawnThrustParticle(ship,dir){
  const geo = new THREE.SphereGeometry(0.15,8,8);
  const mat = new THREE.MeshBasicMaterial({
    color: ship.policyType==="PETS"?0xffdd66:0x66c0ff,
    transparent:true,
    opacity:0.9
  });
  const p = new THREE.Mesh(geo,mat);
  const back = dir.clone().multiplyScalar(-1);
  p.position.copy(ship.pos).addScaledVector(back, ship.radius||0.8);
  p.userData.vel = back.multiplyScalar(0.6);
  p.userData.life=0.6;
  scene.add(p);
  thrustParticles.push(p);
}
function updateThrustParticles(dt){
  for(let i=thrustParticles.length-1;i>=0;i--){
    const p = thrustParticles[i];
    p.userData.life-=dt;
    p.position.addScaledVector(p.userData.vel,dt);
    p.material.opacity = Math.max(0,p.userData.life/0.6);
    if(p.userData.life<=0){
      scene.remove(p);
      thrustParticles.splice(i,1);
    }
  }
}

// === ì¤‘ë ¥ ë³´ì¡°(GA) / ë¼ê·¸ë‘ì£¼ í¬ì¸íŠ¸ ê´€ë ¨ ë”ë¯¸ í•¨ìˆ˜ ===
// ì§€ê¸ˆì€ ì‹¤ì œ ê³„ì‚°ì€ ì•ˆ í•˜ê³ , ê³ ê¸‰ ë³´ìƒì‹ì—ì„œ ì—ëŸ¬ë§Œ ì•ˆ ë‚˜ê²Œ ê¸°ë³¸ê°’ë§Œ ëŒë ¤ì¤ë‹ˆë‹¤.

function getGravityAssistOpportunity(ship, targetName) {
  // ë‚˜ì¤‘ì— êµ¬í˜„í•˜ê³  ì‹¶ìœ¼ë©´ ì—¬ê¸°ì„œ GA í›„ë³´ í–‰ì„±, í”Œë¼ì´ë°”ì´ ë°˜ê²½ ë“±ì„ ê³„ì‚°í•˜ë©´ ë¨
  return null;  // í˜„ì¬ëŠ” GA ì‚¬ìš© ì•ˆ í•¨
}

function getNearestLagrangePointInfo(pos, targetBody) {
  // targetBody ì£¼ìœ„ì˜ L4/L5 ë“±ì„ ì°¾ëŠ”ë‹¤ê³  ê°€ì •í•˜ëŠ” ê³³ì´ì§€ë§Œ
  // ì•„ì§ êµ¬í˜„í•˜ì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ "ì—†ìŒ" ìƒíƒœë§Œ ëŒë ¤ì¤Œ
  return {
    type: null,                         // 'L4' / 'L5' ë“±
    dist: Infinity,                     // ë§¤ìš° ë©ˆ
    toPoint: new THREE.Vector3(0,0,0)   // ë°©í–¥ ë²¡í„°
  };
}

function getFutureLagrangePointInfo(pos, targetBody, ghostDays) {
  // ë¯¸ë˜ ì‹œì ìš© ë¼ê·¸ë‘ì£¼ í¬ì¸íŠ¸ ì •ë³´ë„ í˜„ì¬ëŠ” ë”ë¯¸
  return {
    type: null,
    dist: Infinity,
    toLPoint: new THREE.Vector3(0,0,0)
  };
}


/* ========== RL ì•¡ì…˜ ì ìš© + PETS/SAC ì •ì±… ========== */
function applyRLAction(ship, action, dt) {
  const dir = action.dir.clone().normalize();
  const thrustOn = !!action.thrustOn;
  const fuelRatio = Math.max(0,Math.min(1,action.fuelRatio ?? 1.0));
  let finalDir = dir.clone().normalize();
  // === [ê°œì„  ì‚¬í•­: ë¯¸ì„¸ ìì„¸ ì œì–´ ì ìš©] ===
  // action.pitchYawëŠ” [-1, 1] ë²”ìœ„ì˜ ë‘ ê°’ì„ ê°€ì§. (Yaw, Pitch)
  if (action.pitchYaw) { 
      const maxAngle = THREE.MathUtils.degToRad(1); // ìµœëŒ€ 1ë„ ë¯¸ì„¸ ì¡°ì •
      const yaw = action.pitchYaw[0] * maxAngle;
      const pitch = action.pitchYaw[1] * maxAngle;
        
      // í˜„ì¬ ìµœì¢… ë°©í–¥ì„ ê¸°ì¤€ìœ¼ë¡œ Yaw/Pitch íšŒì „ ì ìš©
      const rotationMatrix = new THREE.Matrix4();
      rotationMatrix.makeRotationAxis(new THREE.Vector3(0, 1, 0), yaw); // Yaw (ìˆ˜ì§ì¶• íšŒì „)
      rotationMatrix.multiply(new THREE.Matrix4().makeRotationAxis(finalDir.clone().cross(new THREE.Vector3(0, 1, 0)).normalize(), pitch)); // Pitch
        
      finalDir.applyMatrix4(rotationMatrix);
    }
  ship.lastFuelUsed=0;
  if(thrustOn && ship.fuel>0){
    const thrustMag = ship.maxThrust*fuelRatio;
    ship.vel.addScaledVector(dir, thrustMag*dt);
    const fuelUsed = fuelRatio*dt*0.9;
    ship.fuel = Math.max(0, ship.fuel-fuelUsed);
    ship.lastFuelUsed = fuelUsed;
    spawnThrustParticle(ship,dir);
  }
  ship.lastActionDir = finalDir.clone();
}
function stepPETS(ship, dt) {
    const obs = getObservation(ship);
    if (obs.dist < 1 || ship.fuel <= 0.01) return;

    // ğŸŒŸ ëª©í‘œ í–‰ì„± ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜¤ê¸°
    const targetId = document.getElementById('autoTarget').value;
    const targetBody = bodies[targetId];
    if (!targetBody || !targetBody.pos) {
        console.warn('Target body or position undefined:', targetId);
        return;
    }
    const currentTargetPos = targetBody.pos.clone();

    const baseDir = obs.toTarget.clone().normalize();

    // === [ê¸°ë³¸ ë°©í–¥ ì„¤ì •] ===
    // L4/L5 ìœ ë„
    if (obs.lgrgDist < 20 && (obs.lgrgType === 'L4' || obs.lgrgType === 'L5') && obs.dist > 15) {
        const lgrgInfluence = Math.min(1.0, (20 - obs.lgrgDist) / 20) * 0.4;
        baseDir.addScaledVector(obs.lgrgDir.clone().normalize(), lgrgInfluence);
    }
    // ì—­ì¥/íšŒí”¼ ë³´ì •
    if (obs.warpInfluence > 0) {
        baseDir.addScaledVector(obs.warpDir, 0.4 * obs.warpInfluence);
    }
    const avoidDir = computeAvoidanceVector(obs.pos);
    if (avoidDir.lengthSq() > 1e-6) {
        baseDir.addScaledVector(avoidDir.normalize(), 0.8);
    }
    baseDir.normalize();

    let bestScore = -Infinity, bestDir = baseDir.clone();
    const horizon = 8, candCount = 16;

    // === [PETS ê¶¤ì  ìƒ˜í”Œë§ ë° ë‚´ë¶€ ì ìˆ˜ ê³„ì‚°] ===
    for (let i = 0; i < candCount; i++) {
        const jitter = new THREE.Vector3(
            (Math.random() - 0.5) * 0.4,
            (Math.random() - 0.5) * 0.2,
            (Math.random() - 0.5) * 0.4
        );
        const candDir = baseDir.clone().add(jitter).normalize();
        let pos = obs.pos.clone();
        let vel = obs.vel.clone();
        let score = 0;

        for (let t = 0; t < horizon; t++) {
            const g = computeGravitationalAcceleration(pos);
            vel.addScaledVector(g, dt);
            vel.addScaledVector(candDir, ship.maxThrust * 0.5 * dt);
            pos.addScaledVector(vel, dt);

            // ê±°ë¦¬ ê¸°ë°˜ ì ìˆ˜
            const d = pos.distanceTo(currentTargetPos);
            score -= d * 0.02;

            // L4/L5 ê·¼ì ‘ ë³´ë„ˆìŠ¤
            const lgrg = getNearestLagrangePointInfo(pos, targetBody);
            if ((lgrg.type === 'L4' || lgrg.type === 'L5') && lgrg.dist < 15) {
                score += (15 - lgrg.dist) * 0.1;
            }
        }

        // ì¶©ëŒ ìœ„í—˜ë„
        const risk = computeCollisionRisk(pos) * 100;
        score -= risk * dt;

        if (score > bestScore) {
            bestScore = score;
            bestDir.copy(candDir);
        }
    }

    // === [í–‰ë™ ì ìš©] ===
    applyRLAction(ship, {
        thrustOn: obs.dist > 1 && ship.fuel > 0.02,
        dir: bestDir,
        fuelRatio: 0.7
    }, dt);

    // =========================================================================
    // === [ì™¸ë¶€ í™˜ê²½ ë³´ìƒ ê³„ì‚° ë° í†µí•©] ===
    // =========================================================================
    const progress = (ship.prevGoalDist ?? obs.dist) - obs.dist;
    const fuelPenalty = ship.lastFuelUsed;
    const dist = obs.dist;
    const velMag = obs.vel.length();
    const gravMag = obs.grav.length();
    const fuelRatio = ship.lastFuelUsed / (ship.maxThrust * dt);

    const lastDir = ship.lastActionDir || new THREE.Vector3(1, 0, 0);
    const currentDir = bestDir.clone().normalize();
    const angleRad = lastDir.angleTo(currentDir);
    const jitterPenalty = angleRad * angleRad * 50.0;

    let efficiencyBonus = 0;
    if (fuelPenalty > 0.001) {
        efficiencyBonus = (progress / fuelPenalty) * 10.0;
    } else if (progress > 0) {
        efficiencyBonus = progress * 15.0;
    }

    const alignmentBonus = obs.targetVelDot * 5.0;
    const kineticPenalty = obs.kinetic * 0.005;
    const timePenalty = 0.8;
    const inverseDistBonus = dist > 0.01 ? (1 / (dist * dist)) * 5000.0 : 0;
    const softCaptureBonus = dist < 10 ? (1 / (1 + velMag)) * 5.0 : 0;
    const gravSquaredPenalty = gravMag * gravMag * 0.25;

    const lgrgBonus = (obs.lgrgType === 'L4' || obs.lgrgType === 'L5') ? (1 / (1 + obs.lgrgDist)) * 1.5 : 0;
    const ttiPenalty = obs.collisionTTI < 5.0 ? (1 / obs.collisionTTI) * 10.0 : 0;
    const inclinationSquaredPenalty = (obs.pos.y * obs.pos.y) + (obs.vel.y * obs.vel.y);
    const inclinationPenalty = Math.abs(ship.pos.y) * 0.025 + Math.abs(ship.vel.y) * 1.5;

    const riskVal = obs.collisionRisk;
    let safeProgressBonus = progress * 15;
    if (riskVal > 0.01) safeProgressBonus *= (1 / (riskVal * riskVal + 1)); 
    else safeProgressBonus *= 1.2;
    const escapeBonus = Math.abs(obs.gravVelDot - (-1)) * -2.0;
    const riskSquaredPenalty = riskVal * riskVal * 30.0;
    const excessiveThrustPenalty = fuelRatio > 0.7 ? (fuelRatio - 0.7) * 10.0 : 0;

    const prevPredDist = ship.prevPredDist ?? obs.predDist;
    const predProgress = prevPredDist - obs.predDist;
    const predictedTargetBonus = predProgress * 20.0;
    ship.prevPredDist = obs.predDist;

    const velDiff = obs.vel.clone().sub(obs.targetVel).length();
    const velMatchPenalty = velDiff * 2.5;

    const angleToTarget = obs.velDirAngle;
    const angleAlignBonus = (Math.PI - angleToTarget) * 3.0;

    let decelApproachBonus = 0;
    if (dist < 12 && dist > 4) decelApproachBonus = (1 / (velMag + 0.1)) * 4.0;

    // ğŸŒŸ ìµœì¢… ë³´ìƒ í•©ì‚°
    ship.totalReward +=
        efficiencyBonus +
        progress * 15 +
        alignmentBonus * dt +
        angleAlignBonus * dt +
        inverseDistBonus +
        softCaptureBonus * dt +
        predictedTargetBonus +
        decelApproachBonus * dt +
        lgrgBonus * dt +
        safeProgressBonus +
        escapeBonus * dt -
        fuelPenalty * 20 -
        dt * 0.4 -
        kineticPenalty * dt -
        timePenalty * dt -
        gravSquaredPenalty * dt -
        inclinationPenalty * dt -
        inclinationSquaredPenalty * 0.1 * dt -
        jitterPenalty * dt -
        riskSquaredPenalty * dt -
        excessiveThrustPenalty * dt -
        velMatchPenalty * dt -
        ttiPenalty * dt;

    ship.prevGoalDist = obs.dist;

    document.getElementById('petsFuel').textContent = (ship.fuel * 100).toFixed(1);
    document.getElementById('petsRew').textContent = ship.totalReward.toFixed(1);

    // ë§ˆì§€ë§‰ìœ¼ë¡œ í–‰ë™ ë°©í–¥ ì €ì¥
    ship.lastActionDir = bestDir.clone();
}


  function stepSAC(ship,dt){
Â  const obs = getObservation(ship);
Â  if (obs.dist<1 || ship.fuel<=0.01) return;
Â  
Â  const toTargetDir = obs.toTarget.clone().normalize();
Â  const velDir = obs.vel.length()>1e-3 ? obs.vel.clone().normalize() : new THREE.Vector3();
Â  const gravDir= obs.grav.length()>1e-4 ? obs.grav.clone().normalize() : new THREE.Vector3();

Â  // === [ê¸°ë³¸ ë°©í–¥ ì„¤ì •] ===
Â  let baseDir = new THREE.Vector3()
Â  Â  .addScaledVector(toTargetDir, 1.0)
Â  Â  .addScaledVector(velDir,Â  Â  -0.5)
Â  Â  .addScaledVector(gravDir,Â  Â -0.2);

Â  // L4/L5 ìœ ë„
Â  if (obs.lgrgDist < 20 && (obs.lgrgType === 'L4' || obs.lgrgType === 'L5') && obs.dist > 15) {
Â  Â  const lgrgInfluence = Math.min(1.0, (20 - obs.lgrgDist) / 20) * 0.5;
Â  Â  baseDir.addScaledVector(obs.lgrgDir.clone().normalize(), lgrgInfluence);
Â  }
Â Â 
Â  // ì—­ì¥/íšŒí”¼/ë…¸ì´ì¦ˆ ë³´ì •
Â  if (obs.warpInfluence > 0) {
Â  Â  baseDir.addScaledVector(obs.warpDir, 0.6 * obs.warpInfluence);
Â  }
Â  const avoidDir = computeAvoidanceVector(obs.pos);
Â  if (avoidDir.lengthSq() > 1e-6) {
Â  Â  baseDir.addScaledVector(avoidDir.normalize(), 1.0);
Â  }
Â  const noise = new THREE.Vector3(
Â  Â  (Math.random()-0.5)*0.3, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.3
Â  );
Â  baseDir.add(noise.multiplyScalar(0.3));

Â  baseDir.normalize();

Â  // === [í–‰ë™ ì ìš©] ===
Â  applyRLAction(ship,{
Â  Â  thrustOn: obs.dist>1 && ship.fuel>0.02,
Â  Â  dir:baseDir,
Â  Â  fuelRatio:0.5
Â  },dt);

// =========================================================================
// === [ì™¸ë¶€ í™˜ê²½ ë³´ìƒ ê³„ì‚° ë° í†µí•©] ===
// SACëŠ” baseDirë¥¼ ì‚¬ìš©í–ˆìœ¼ë¯€ë¡œ, jitterPenalty ê³„ì‚°ì„ ìœ„í•´ baseDirë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
// =========================================================================

    // ğŸŒŸ ë³€ìˆ˜ ì •ì˜ ë° ì¤‘ë³µ ì œê±°
    const progress = (ship.prevGoalDist ?? obs.dist) - obs.dist;
    const fuelPenalty = ship.lastFuelUsed; // ëˆ„ë½ëœ ë³€ìˆ˜ ì •ì˜
    const dist = obs.dist;
    const velMag = obs.vel.length();
    const gravMag = obs.grav.length();
    const fuelRatio = ship.lastFuelUsed / (ship.maxThrust * dt);

    // B. ë–¨ë¦¼ í˜ë„í‹° (baseDir ì‚¬ìš©)
    const lastDir = ship.lastActionDir || new THREE.Vector3(1, 0, 0); 
    const currentDir = baseDir.clone().normalize(); 
    const angleRad = lastDir.angleTo(currentDir);
    const jitterPenalty = angleRad * angleRad * 50.0;
    
    // A. íš¨ìœ¨ ë³´ë„ˆìŠ¤
    let efficiencyBonus = 0;
    if (fuelPenalty > 0.001) {
        efficiencyBonus = (progress / fuelPenalty) * 10.0;
    } else if (progress > 0) {
        efficiencyBonus = progress * 15.0; 
    }
    const alignmentBonus = obs.targetVelDot * 5.0; // A & D ì¤‘ë³µ
    const kineticPenalty = obs.kinetic * 0.005;
    const timePenalty = 0.8;

    // B. ìµœì¢… ì ‘ê·¼ ë³´ë„ˆìŠ¤
    let inverseDistBonus = dist > 0.01 ? (1 / (dist * dist)) * 5000.0 : 0;
    let softCaptureBonus = dist < 10 ? (1 / (1 + velMag)) * 5.0 : 0;
    const gravSquaredPenalty = (gravMag * gravMag) * 0.5;

    // C. ì „ëµì  ê²½ìœ ì§€ ë³´ìƒ
    let gaFlybyReward = 0; // obs.gaAvailable ë° gaOpportunityê°€ ì •ì˜ë˜ì—ˆë‹¤ê³  ê°€ì •
    /* if (obs.gaAvailable && obs.distToGA < gaOpportunity.flybyRadius * 1.5) { gaFlybyReward = 20.0; } */
    
    let lgrgBonus = (obs.lgrgType === 'L4' || obs.lgrgType === 'L5') ? (1 / (1 + obs.lgrgDist)) * 1.5 : 0;
    let ttiPenalty = obs.collisionTTI < 5.0 ? (1 / obs.collisionTTI) * 10.0 : 0;
    const inclinationSquaredPenalty = (obs.pos.y * obs.pos.y) + (obs.vel.y * obs.vel.y);
    const inclinationPenalty = (Math.abs(ship.pos.y) * 0.025) + (Math.abs(ship.vel.y) * 1.5);

    // D. ìœ„í—˜ ê´€ë¦¬ ë³´ìƒ
    const risk = obs.collisionRisk;
    let safeProgressBonus = progress * 15;
    if (risk > 0.01) { safeProgressBonus *= (1 / (risk * risk + 1)); } else { safeProgressBonus *= 1.2; }
    const escapeBonus = Math.abs(obs.gravVelDot - (-1)) * -1.0 * 2.0;
    const riskSquaredPenalty = (risk * risk) * 30.0;
    let excessiveThrustPenalty = fuelRatio > 0.7 ? (fuelRatio - 0.7) * 10.0 : 0;
    // 1) ëª©í‘œ ë¯¸ë˜ ì˜ˆì¸¡ ìœ„ì¹˜ ì ‘ê·¼ ë³´ìƒ
    const prevPredDist = ship.prevPredDist ?? obs.predDist;
    const predProgress = prevPredDist - obs.predDist;
    const predictedTargetBonus = predProgress * 20.0;
    ship.prevPredDist = obs.predDist;

    // 2) ëª©í‘œ í–‰ì„± ì†ë„ì™€ì˜ ì†ë„ ì°¨ì´ ìµœì†Œí™” ë³´ìƒ (ì •ë°€ ì°©ë¥™)
    const velDiff = obs.vel.clone().sub(obs.targetVel).length();
    const velMatchPenalty = velDiff * 2.5;

    // 3) ëª©í‘œ ë°©í–¥ ê°ë„ ê¸°ë°˜ ì •ë ¬ ë³´ìƒ (ì¶”ê°€ ì •í™•ë„ ìƒìŠ¹)
    const angleToTarget = obs.velDirAngle; // obs.toTarget ê³¼ obs.vel ì˜ ê°ë„
    const angleAlignBonus = (Math.PI - angleToTarget) * 3.0;

    // 4) ëª©í‘œ ê·¼ì²˜ì—ì„œ ê°ì† ì ‘ê·¼ ë³´ë„ˆìŠ¤ (ìŠ¤ì³ ì§€ë‚˜ê°€ëŠ” ë¬¸ì œ í•´ê²°)
    let decelApproachBonus = 0;
    if (dist < 12 && dist > 4) {
        decelApproachBonus = (1 / (velMag + 0.1)) * 4.0;
    }
    
    // === ğŸŒŸğŸŒŸğŸŒŸ ìµœì¢… ë³´ìƒ í•©ì‚° (ë¬¸ë²• ì˜¤ë¥˜ ìˆ˜ì • ë° í†µí•©) ğŸŒŸğŸŒŸğŸŒŸ
    // ê°€ì¥ ê°•ë ¥í•œ ë³´ìƒë“¤ì„ ê¸°ë°˜ìœ¼ë¡œ í•©ì‚°í•˜ê³  ì¤‘ë³µëœ ê¸°ë³¸ í˜ë„í‹° ì œê±°
    ship.totalReward +=
        // 1. ëª©í‘œ ê·¼ì ‘ ë° íš¨ìœ¨
        efficiencyBonus 
        + progress * 15 // ê¸°ë³¸ ê·¼ì ‘ ë³´ìƒ
        + alignmentBonus * dt
        + angleAlignBonus * dt
        
        // 2. ìµœì¢… ì ‘ê·¼ ë° ì •ë°€ ì œì–´
        + inverseDistBonus
        + softCaptureBonus * dt
        + predictedTargetBonus
        + decelApproachBonus * dt

        // 3. ì „ëµì  ê¸°ë™
        + gaFlybyReward
        + lgrgBonus * dt
        
        // 4. ìœ„í—˜ ê´€ë¦¬ ë° ì•ˆì „
        + safeProgressBonus 
        + escapeBonus * dt
        
        // 5. ëª¨ë“  í˜ë„í‹° í•©ì‚° (ê°ì†Œ)
        - fuelPenalty * 20 
        - dt * 0.4
        - kineticPenalty * dt
        - timePenalty * dt
        - gravSquaredPenalty * dt
        - inclinationPenalty * dt
        - inclinationSquaredPenalty * 0.1 * dt
        - jitterPenalty * dt
        - riskSquaredPenalty * dt
        - excessiveThrustPenalty * dt
        - ttiPenalty * dt
        - obs.grav.length() * 4.0 * dt // SAC ê³ ìœ ì˜ ì¤‘ë ¥ í˜ë„í‹°
        - velMatchPenalty * dt;

    ship.prevGoalDist = obs.dist;

Â  document.getElementById('sacFuel').textContent=(ship.fuel*100).toFixed(1);
Â  document.getElementById('sacRew').textContent=ship.totalReward.toFixed(1);
}

// === ì˜ˆìƒ ê¶¤ë„ ì˜ˆì¸¡ (3D, ì›€ì§ì´ëŠ” ëª©í‘œ + ì¤‘ë ¥ ë°˜ì˜) ===
function predictTrajectory(ship, policyType, steps = 900, dtSec = 0.175) {
  const pts = [];
  let pos  = ship.pos.clone();
  let vel  = ship.vel.clone();
  let fuel = ship.fuel;

  // ì‹œì‘ì 
  pts.push(pos.clone());

  const targetName = document.getElementById("autoTarget").value;
  const targetBody = bodies[targetName];
  if (!targetBody) return pts;

  // í–‰ì„± ë°˜ì§€ë¦„ ê¸°ë°˜ ë„ë‹¬ ê¸°ì¤€
  const targetRadius = targetBody.mesh.geometry.parameters.radius || 1;
  const successDist  = targetRadius * 3;

  // ì´ˆê¸° ì¤‘ë ¥ë³´ì¡°(GA) ì •ë³´
  const initialGAA = getGravityAssistOpportunity(ship, targetBody.name);
  let isExecutingGA = !!initialGAA;
  let gaFlybyPos = initialGAA
    ? initialGAA.body
        .pivot.getWorldPosition(new THREE.Vector3())
        .addScaledVector(initialGAA.approachVector, initialGAA.flybyRadius)
    : null;

  let ghostDays   = 0;
  const daysPerSec = Math.max(0.5, timeScale || 1);
  const baseFuelRatio = policyType === "PETS" ? 0.7 : 0.5;

  for (let i = 0; i < steps; i++) {
    const dDays = dtSec * daysPerSec;
    ghostDays += dDays;

    // 1) ì´ ì‹œì ì˜ ëª©í‘œ í–‰ì„± ìœ„ì¹˜
    const currentTargetPos = getFuturePlanetPos(targetBody, ghostDays);

    // 2) ê¸°ë³¸ ìœ íš¨ ëª©í‘œ = í˜„ì¬ í–‰ì„± ìœ„ì¹˜
    let effectiveTargetPos = currentTargetPos.clone();

    // 3) GA(í”Œë¼ì´ë°”ì´) ìˆ˜í–‰ ì¤‘ì´ë©´ GA í¬ì¸íŠ¸ë¥¼ ëª©í‘œë¡œ ì‚¬ìš©
    if (isExecutingGA && gaFlybyPos) {
      if (pos.distanceTo(gaFlybyPos) < 5) {
        // GA ì™„ë£Œ
        isExecutingGA = false;
      } else {
        effectiveTargetPos.copy(gaFlybyPos);
      }
    }

    // 4) GAê°€ ì•„ë‹ ë•Œë§Œ "ì„ í–‰ íƒ€ê²Ÿ ì¡°ì¤€" ì ìš©
    if (!isExecutingGA) {
      const futureTargetPos = getFuturePlanetPos(targetBody, ghostDays + 5); // 5ì¼ ë’¤ (ì¡°ì ˆ ê°€ëŠ¥)
      let orbitDir = new THREE.Vector3()
        .subVectors(futureTargetPos, currentTargetPos)
        .normalize();

      // ë§Œì•½ ì—¬ì „íˆ ê²½ë¡œê°€ ë°˜ëŒ€ë¡œ êº¾ì´ë©´ ì•„ë˜ í•œ ì¤„ì„ í™œì„±í™”í•´ì„œ ë°©í–¥ì„ ë’¤ì§‘ì–´ ë³´ì„¸ìš”.
      // orbitDir.multiplyScalar(-1);

      const distToCurrent = pos.distanceTo(currentTargetPos);
      const leadK   = Math.min(1.0, distToCurrent / 80);     // ë©€ìˆ˜ë¡ ì„ í–‰ëŸ‰ ì¦ê°€
      const leadLen = (targetRadius || 1) * 4 * leadK;       // í–‰ì„± í¬ê¸° ê¸°ì¤€ ì„ í–‰ ê¸¸ì´

      effectiveTargetPos.addScaledVector(orbitDir, leadLen);
    }

    // 5) ì‹¤ì œ ì¡°ì¤€ ë²¡í„° / ê±°ë¦¬
    const toEffectiveTarget = new THREE.Vector3()
      .subVectors(effectiveTargetPos, pos);
    const distToTarget = toEffectiveTarget.length();

    // ëª©í‘œ ê·¼ì²˜ê¹Œì§€ ì˜¤ë©´ ì¢…ë£Œ
    if (distToTarget < successDist) {
      pts.push(pos.clone());
      break;
    }

    // â˜… ë¯¸ë˜ ì‹œì (ghostDays) ê¸°ì¤€ ì¤‘ë ¥ ì‚¬ìš©
    const g = (typeof computeGravitationalAccelerationGhost === "function")
      ? computeGravitationalAccelerationGhost(pos, ghostDays)
      : computeGravitationalAccelerationRaw(pos);   // ë³´ì¡° í•¨ìˆ˜ ì—†ìœ¼ë©´ ê¸°ì¡´ raw ì¤‘ë ¥ ì‚¬ìš©

    const toDir = toEffectiveTarget.clone().normalize();
    let dir;

    // L í¬ì¸íŠ¸ ì •ë³´ë„ ë¯¸ë˜ ê¸°ì¤€
    const lgrgInfo = getFutureLagrangePointInfo(pos, targetBody, ghostDays);
    const lgrgDir  = lgrgInfo.toLPoint.clone().normalize();
    const isStableLPointNearby =
      (lgrgInfo.type === "L4" || lgrgInfo.type === "L5") &&
      lgrgInfo.dist < 20 &&
      distToTarget > 10;

    if (policyType === "PETS") {
      const jitter = new THREE.Vector3(
        (Math.random() - 0.5) * 0.2,
        (Math.random() - 0.5) * 0.2,
        (Math.random() - 0.5) * 0.2
      );
      dir = toDir.clone().add(jitter);
      if (isStableLPointNearby) {
        dir.addScaledVector(lgrgDir, 0.3);
      }
    } else {
      const velDir =
        vel.length() > 1e-3 ? vel.clone().normalize() : new THREE.Vector3();
      const gravDir =
        g.length() > 1e-4 ? g.clone().normalize() : new THREE.Vector3();

      dir = new THREE.Vector3()
        .addScaledVector(toDir,   1.0)
        .addScaledVector(velDir, -0.4)
        .addScaledVector(gravDir,-0.2);

      if (isStableLPointNearby) {
        dir.addScaledVector(lgrgDir, 0.5);
      }
    }

    if (dir.lengthSq() > 1e-6) dir.normalize();

    // ê±°ë¦¬ ê¸°ë°˜ ì¶”ë ¥ ë¹„ìœ¨ (ëª©í‘œì™€ì˜ ê±°ë¦¬ ê¸°ì¤€)
    let fuelRatio;
    if (distToTarget > 50) {
      fuelRatio = baseFuelRatio;
    } else if (distToTarget > 10) {
      fuelRatio = baseFuelRatio * (0.2 + 0.8 * (distToTarget - 10) / 40);
    } else {
      fuelRatio = baseFuelRatio * 0.15;
    }

    const thrustOn = fuel > 0 && distToTarget > targetRadius * 1.2;
    if (thrustOn) {
      const thrustMag = ship.maxThrust * fuelRatio;
      vel.addScaledVector(dir, thrustMag * dtSec);
      const fuelUsed = fuelRatio * dtSec * 0.6;
      fuel = Math.max(0, fuel - fuelUsed);
    }

    // ì¤‘ë ¥ / ìœ„ì¹˜ ì—…ë°ì´íŠ¸
    vel.addScaledVector(g, dtSec);
    pos.addScaledVector(vel, dtSec);

    pts.push(pos.clone());
  }

  return pts;
}

let petsPathLine=null, sacPathLine=null;
function showPredictedPath(ship, policyType){
  const pts = predictTrajectory(ship, policyType);
  if (!pts.length) return;   
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const color = policyType==="PETS"?0xffdd33:0x33aaff;
  const mat = new THREE.LineBasicMaterial({color,transparent:true,opacity:0.8});
  const line = new THREE.Line(geo,mat);
  scene.add(line);
  if(policyType==="PETS"){
    if(petsPathLine) scene.remove(petsPathLine);
    petsPathLine=line;
  }else{
    if(sacPathLine) scene.remove(sacPathLine);
    sacPathLine=line;
  }
}

/* ========== UI / ë§ˆìš°ìŠ¤ / ì¤Œ ========== */
const speed    = document.getElementById('speed');
const speedNum = document.getElementById('speedNum');
function setRate(v){
  const n=parseFloat(v);
  timeScale = Math.max(0,isNaN(n)?0:n);
  speed.value=String(timeScale);
  speedNum.value=String(timeScale);
}
speed.addEventListener('input',e=>setRate(e.target.value));
speedNum.addEventListener('input',()=>setRate(speedNum.value));
document.querySelectorAll('.btn[data-rate]').forEach(btn=>{
  btn.addEventListener('click',()=>setRate(btn.dataset.rate));
});

const focusSel = document.getElementById('focusSel');
function applyFocus(){
  const v=focusSel.value;
  if(v==='ììœ (ìˆ˜ë™)') focusTarget=null;
  else focusTarget=(bodies[v]?bodies[v].pivot:null)||bodies['íƒœì–‘'].pivot;
  updateCam();
}
focusSel.addEventListener('change',applyFocus);
axisList.forEach(a=>a.visible=true);

const gravToggle = document.getElementById('gravToggle');
let showGravityField=false;
let gravHelpers=[];
gravToggle.addEventListener('change',()=>{ showGravityField=gravToggle.checked; });

/* ë§ˆìš°ìŠ¤ ì»¨íŠ¸ë¡¤ */
let dragging=false, px=0, py=0, button=0;
const raycaster = new THREE.Raycaster();
const mouse     = new THREE.Vector2();
const clickPlane= new THREE.Plane(new THREE.Vector3(0,1,0),0);
let pendingSpawn=null;

function getClickPositionOnPlane(e){
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x=((e.clientX-rect.left)/rect.width)*2-1;
  mouse.y=-((e.clientY-rect.top)/rect.height)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const pos=new THREE.Vector3();
  const hit=raycaster.ray.intersectPlane(clickPlane,pos);
  if(!hit){
    const dir=new THREE.Vector3();
    camera.getWorldDirection(dir);
    pos.copy(camera.position).add(dir.multiplyScalar(30));
  }
  return pos;
}
app.addEventListener('mousedown',e=>{
  if(e.button===0 && pendingSpawn?.type==='asteroid'){
    const pos=getClickPositionOnPlane(e);
    const shipN = getNearestShip(pos);
    spawnAsteroidSwarm(pos,shipN);
    pendingSpawn=null;
    return;
  }
  dragging=true; px=e.clientX; py=e.clientY; button=e.button;
});
window.addEventListener('mouseup',()=>{dragging=false;});
app.addEventListener('contextmenu',e=>e.preventDefault());
window.addEventListener('mousemove',e=>{
  if(!dragging)return;
  const dx=e.clientX-px, dy=e.clientY-py;
  if(button===0){
    theta-=dx*0.005; phi-=dy*0.005;
    const eps=0.001;
    phi=Math.max(eps,Math.min(Math.PI-eps,phi));
  }else if(button===2 && !focusTarget){
    const s=radius*0.0012;
    camera.updateMatrixWorld();
    const fwd=new THREE.Vector3(); camera.getWorldDirection(fwd);
    const right=fwd.clone().cross(camera.up).normalize();
    const up=camera.up.clone().normalize();
    manualTarget.addScaledVector(right,-dx*s);
    manualTarget.addScaledVector(up,dy*s);
  }
  px=e.clientX; py=e.clientY;
  updateCam();
});
app.addEventListener('wheel',e=>{
  e.preventDefault();
  radius*=1+Math.sign(e.deltaY)*0.08;
  radius=Math.max(30,Math.min(5000,radius));
  updateCam();
},{passive:false});

/* ë²„íŠ¼ */
document.getElementById('spawnAst').addEventListener('click',()=>{
  pendingSpawn={type:'asteroid'};
  console.log('ì†Œí–‰ì„± êµ° ìƒì„± ëª¨ë“œ: í™”ë©´ì„ í´ë¦­í•˜ì„¸ìš”.');
});
document.getElementById('spawnField').addEventListener('click', ()=>{
  spawnWarpField();
  console.log('ì—­ì¥ ìƒì„±: ìš°ì£¼ì„ ê³¼ ëª©í‘œ ì§€ì  ì‚¬ì´ì— ìƒì„±.');
});
document.getElementById('clearObjs').addEventListener('click',()=>{
  dynamicObjects.forEach(o=>scene.remove(o.mesh));
  dynamicObjects.length=0;
  petsShip=null; sacShip=null; activeShip=null;
});

/* ========== PETS/SAC ìš°ì£¼ì„  + ì˜ˆì¸¡/ì„ íƒ/í†µê³„ ========== */
let petsShip=null, sacShip=null, activeShip=null;
let petsEnabled=true, sacEnabled=true;
let simulationPaused=false;
let episodeFinished=false;
let pathUpdateTimer = 0;

let totalAttempts=0, totalSuccess=0;

const choiceRow   = document.getElementById('choiceRow');
const resultOverlay = document.getElementById('resultOverlay');
const resultLine    = document.getElementById('resultLine');
const resultPercent = document.getElementById('resultPercent');
const logContent    = document.getElementById('logContent');

document.getElementById('petsEnable').addEventListener('change',e=>{
  petsEnabled=e.target.checked;
  if(petsShip) petsShip.mesh.visible=petsEnabled;
});
document.getElementById('sacEnable').addEventListener('change',e=>{
  sacEnabled=e.target.checked;
  if(sacShip) sacShip.mesh.visible=sacEnabled;
});
let episodeTime = 0;
/* ìš°ì£¼ì„  ì†Œí™˜ */
document.getElementById('spawnShip').addEventListener('click',()=>{
  if(petsShip){scene.remove(petsShip.mesh); petsShip.alive=false;}
  if(sacShip){ scene.remove(sacShip.mesh);  sacShip.alive=false;}
  petsShip=null; sacShip=null; activeShip=null;
  if(petsPathLine) scene.remove(petsPathLine);
  if(sacPathLine) scene.remove(sacPathLine);
  episodeFinished=false;
  simulationPaused=true;
  episodeTime = 0;

  let basePos;
  const earth = bodies['ì§€êµ¬'];
  if(earth){
    basePos = earth.pivot.getWorldPosition(new THREE.Vector3())
      .add(new THREE.Vector3(10,0,0));
  }else{
    basePos = new THREE.Vector3(30,0,0);
  }

  const vel = new THREE.Vector3(0,0,0.1);
  petsShip = spawnSpaceshipSimple(basePos.clone().add(new THREE.Vector3(0,0,-1.5)), vel, "PETS", 0xffdd33);
  sacShip  = spawnSpaceshipSimple(basePos.clone().add(new THREE.Vector3(0,0, 1.5)), vel, "SAC",  0x33aaff);

  showPredictedPath(petsShip,"PETS");
  showPredictedPath(sacShip,"SAC");
  pathUpdateTimer = 0;

  choiceRow.style.display='flex';
});

/* ì„ íƒ ë²„íŠ¼ */
document.getElementById('choosePETS').addEventListener('click',()=>{
  if(!petsShip) return;
  if(sacShip){ scene.remove(sacShip.mesh); sacShip.alive=false; sacShip=null; }
  if(sacPathLine){ scene.remove(sacPathLine); sacPathLine=null; }

  activeShip = petsShip;
  simulationPaused = false;
  choiceRow.style.display = 'none';
  pathUpdateTimer = 0;
});
document.getElementById('chooseSAC').addEventListener('click',()=>{
  if(!sacShip) return;
  if(petsShip){ scene.remove(petsShip.mesh); petsShip.alive=false; petsShip=null; }
  if(petsPathLine){ scene.remove(petsPathLine); petsPathLine=null; }

  activeShip = sacShip;
  simulationPaused = false;
  choiceRow.style.display = 'none';
  pathUpdateTimer = 0;
});

/* ì „ì²´ ì´ë²¤íŠ¸ ë¦¬ì…‹ */
function resetAllEvents() {
  for (let i = dynamicObjects.length - 1; i >= 0; i--) {
    scene.remove(dynamicObjects[i].mesh);
  }
  dynamicObjects.length = 0;

  if (petsShip) { scene.remove(petsShip.mesh); petsShip = null; }
  if (sacShip)  { scene.remove(sacShip.mesh);  sacShip  = null; }
  activeShip = null;

  if (petsPathLine) { scene.remove(petsPathLine); petsPathLine = null; }
  if (sacPathLine)  { scene.remove(sacPathLine);  sacPathLine  = null; }

  for (const p of thrustParticles) {
    scene.remove(p);
  }
  thrustParticles.length = 0;

  for (const f of warpFields) {
    if (f.sphere) scene.remove(f.sphere);
  }
  warpFields.length = 0;

  simulationPaused = false;
  episodeFinished  = false;
  pathUpdateTimer  = 0;
}

/* ì—í”¼ì†Œë“œ ì¢…ë£Œ ì²˜ë¦¬ */
function endEpisode(ship, success){
  if(episodeFinished) return;
  episodeFinished=true;
  simulationPaused=true;
  totalAttempts++;
  if(success) totalSuccess++;
  const percent = Math.round(totalSuccess*100/totalAttempts);
  const targetName = document.getElementById('autoTarget').value;
  const method = ship.policyType || 'UNKNOWN';
  resultLine.textContent = `${method}ê°€ ${targetName} í–¥í•´ ${success?"ì„±ê³µ":"ì‹¤íŒ¨"}í–ˆìŠµë‹ˆë‹¤.`;
  resultPercent.textContent = `ì„±ê³µë¥  ${percent}% (${totalSuccess}/${totalAttempts})`;
  resultOverlay.style.display='flex';

  const ts = new Date().toISOString().slice(11,19);
  const line = document.createElement('div');
  line.textContent = `[${ts}] ${method} â†’ ${targetName}: ${success?"ì„±ê³µ":"ì‹¤íŒ¨"}`;
  logContent.prepend(line);
}

/* ëª¨ë‹¬ ë°”ê¹¥ í´ë¦­ ì‹œ ì´ˆê¸°í™” */
resultOverlay.addEventListener('click',e=>{
  if(e.target===resultOverlay){
    resultOverlay.style.display = 'none';
    resetAllEvents();
  }
});


// ì£¼ì–´ì§„ í–‰ì„± bodyì™€ "ë¯¸ë˜ ì‹œê°„(ì¼)"ì— ëŒ€í•´, ê·¸ ì‹œì ì˜ ê³µì „ ìœ„ì¹˜ë¥¼ ê·¼ì‚¬í•´ì„œ êµ¬í•¨
function getFuturePlanetPos(body, deltaDays) {
  if (!body) return new THREE.Vector3(0, 0, 0);
  if (!body.orbitPeriodDays || body.orbitPeriodDays <= 0) {
    // íƒœì–‘ì²˜ëŸ¼ ê³µì „í•˜ì§€ ì•ŠëŠ” ê²½ìš°: ê·¸ëƒ¥ í˜„ì¬ ìœ„ì¹˜ ì‚¬ìš©
    return body.pivot.getWorldPosition(new THREE.Vector3());
  }

  const n   = (2 * Math.PI) / body.orbitPeriodDays;     // í‰ê·  ìš´ë™
  const M0  = body.meanAnomaly || 0;                    // í˜„ì¬ ì‹œì  í‰ê·  ê·¼ì ì´ê°
  const M   = M0 + n * deltaDays;                       // ë¯¸ë˜ ì‹œì  í‰ê·  ê·¼ì ì´ê°
  const e   = body.ecc || 0;
  const E   = solveKepler(M, e);
  const a   = body.semiMajor;
  const b   = a * Math.sqrt(Math.max(0, 1 - e * e));
  const x0  = a * (Math.cos(E) - e);
  const z0  = -b * Math.sin(E);
  const pos = new THREE.Vector3(x0, 0, z0);

  // ê¶¤ë„ ê²½ì‚¬ ë°˜ì˜
  const iRad = THREE.MathUtils.degToRad(body.orbitInc || 0);
  pos.applyAxisAngle(new THREE.Vector3(1, 0, 0), iRad);

  return pos;
}

/* ========== ì¼€í”ŒëŸ¬ E ========== */
function solveKepler(M,e){
  let E=M;
  for(let i=0;i<12;i++){
    const f=E-e*Math.sin(E)-M;
    const fp=1-e*Math.cos(E);
    E-=f/fp;
  }
  return E;
}

/* ========== ë©”ì¸ ë£¨í”„ ========== */
let last = performance.now();
const hudBox = document.getElementById('hudBox');

function tick(now) {
  const dtReal = (now - last) / 1000;
  last = now;

  // ì‹œë®¬ë ˆì´ì…˜ ìƒ "ë‚ ì§œ" ìŠ¤í…
  const dtDays = simulationPaused ? 0 : dtReal * timeScale;

  // ì—í”¼ì†Œë“œ ê²½ê³¼ ì‹œê°„ë§Œ ë”°ë¡œ ëˆ„ì 
  if (!simulationPaused && !episodeFinished && activeShip) {
    episodeTime += dtReal;
  }

  // ë‚ ì§œ/ì‹œê°„ í‘œì‹œ
  if (dtDays !== 0) {
    simDate = new Date(simDate.getTime() + dtDays * 24 * 3600 * 1000);
    document.getElementById("startTime").textContent =
      simDate.toISOString().replace("T", " ").slice(0, 19);
  }

  // ì„ íƒëœ ìš°ì£¼ì„ ì´ ìˆì„ ë•Œ, ì¼ì • ì£¼ê¸°ë¡œ ì˜ˆì¸¡ ê¶¤ë„ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
  if (activeShip && !episodeFinished) {
    pathUpdateTimer -= dtReal;
    if (pathUpdateTimer <= 0) {
      showPredictedPath(activeShip, activeShip.policyType);
      pathUpdateTimer = 0.7;
    }
  }

  // ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ìŠ¤í… (í–‰ì„±/ìš°ì£¼ì„  ëª¨ë‘)
  const physScale = Math.max(0, Math.min(timeScale, 100));
  const dtPhys = simulationPaused ? 0 : dtReal * physScale;

  // íƒœì–‘ ìì „
  const sunBody = bodies["íƒœì–‘"];
  if (sunBody && dtDays !== 0) {
    sunBody.spin.rotation.y += dtDays * (2 * Math.PI / defs[0].rotH);
  }

  // í–‰ì„± ê³µì „ + ìì „
  if (dtDays !== 0) {
    for (const ps of planetStates) {
      const node = ps.node;
      if (node.orbitPeriodDays > 0) {
        const n = (2 * Math.PI) / node.orbitPeriodDays;
        node.meanAnomaly = (node.meanAnomaly + n * dtDays) % (2 * Math.PI);

        const M = node.meanAnomaly,
          e = node.ecc || 0;
        const E = solveKepler(M, e);
        const a = node.semiMajor;
        const b = a * Math.sqrt(Math.max(0, 1 - e * e));
        const x0 = a * (Math.cos(E) - e);
        const z0 = -b * Math.sin(E);
        const pos = new THREE.Vector3(x0, 0, z0);
        const iRad = THREE.MathUtils.degToRad(node.orbitInc || 0);
        pos.applyAxisAngle(new THREE.Vector3(1, 0, 0), iRad);
        node.pivot.position.copy(pos);
      }
      const rotDays = Math.abs(node.rotPeriodHours) / 24;
      const rotSgn = node.rotPeriodHours >= 0 ? 1 : -1;
      if (rotDays > 0) {
        node.spin.rotation.y += rotSgn * dtDays * (2 * Math.PI / rotDays);
      }
    }
  }

  // ë‹¬/ìœ„ì„± ê³µì „ + ìì „
  if (dtDays !== 0) {
    for (const ps of planetStates) {
      for (const m of ps.moons) {
        if (!m.pivot || !m.spin) continue;

        if (m.orbitPeriodDays && m.orbitPeriodDays > 0) {
          const w = (2 * Math.PI) / m.orbitPeriodDays;
          m.orbitalAngle = (m.orbitalAngle || 0) + w * dtDays;
          const r = m.orbitDist || 0;
          const x = r * Math.cos(m.orbitalAngle);
          const z = r * Math.sin(m.orbitalAngle);
          m.pivot.position.set(x, 0, z);
        }

        const rotH = m.rotPeriodHours || 0;
        const rotDays = Math.abs(rotH) / 24;
        const rotSgn = rotH >= 0 ? 1 : -1;
        if (rotDays > 0) {
          m.spin.rotation.y += rotSgn * dtDays * (2 * Math.PI / rotDays);
        }
      }
    }
  }

  // ë™ì  ê°ì²´(ìš°ì£¼ì„ /ì†Œí–‰ì„±) ì—…ë°ì´íŠ¸
  if (dtPhys > 0 && dynamicObjects.length > 0) {
    for (let i = dynamicObjects.length - 1; i >= 0; i--) {
      const o = dynamicObjects[i];
      if (!o.alive) continue;

      // RL ì •ì±… ì ìš© (PETS/SAC)
      if (o.type === "ship" && !episodeFinished) {
        if (o.policyType === "PETS" && petsEnabled) stepPETS(o, dtPhys);
        else if (o.policyType === "SAC" && sacEnabled) stepSAC(o, dtPhys);
      }

      // ì¤‘ë ¥ + ìš´ë™ ì—…ë°ì´íŠ¸ (ë³´í†µì˜ Verlet / semi-implicit)
      const a0 = computeGravitationalAcceleration(o.pos);
      o.pos
        .addScaledVector(o.vel, dtPhys)
        .addScaledVector(a0, 0.5 * dtPhys * dtPhys);
      const a1 = computeGravitationalAcceleration(o.pos);
      o.vel.addScaledVector(a0.add(a1).multiplyScalar(0.5), dtPhys);
      o.mesh.position.copy(o.pos);

      // í–‰ì„±ê³¼ ì¶©ëŒ ì²´í¬
      for (const hb of heavyBodies) {
        const hp = hb.pivot.getWorldPosition(new THREE.Vector3());
        const dist = hp.distanceTo(o.pos);
        const rBody = hb.mesh.geometry.parameters.radius || 1;
        if (dist < rBody * 1.1 + (o.radius || 0.5)) {
          explodeAt(o.pos);
          if (o.type === "ship") {
            o.collided = true;
            o.totalReward -= 50;
            endEpisode(o, false);
          }
          scene.remove(o.mesh);
          o.alive = false;
          dynamicObjects.splice(i, 1);
          break;
        }
      }

      // === í•­í•´ ì„±ê³µ / ì‹¤íŒ¨ íŒì • ===
      if (o.type === "ship" && !episodeFinished && o.policyType) {
        const obs = getObservation(o);

        const targetName = document.getElementById("autoTarget").value;
        const targetBody = bodies[targetName];
        const targetR = targetBody
          ? targetBody.mesh.geometry.parameters.radius || 1
          : 1;

        const successDist = targetR * 4; // ëª©í‘œ ë°˜ì§€ë¦„ì˜ 4ë°° ì•ˆìª½ì´ë©´ "ë„ë‹¬"
        const outLimit = 500; // íƒœì–‘ê³„ ì´íƒˆ ê¸°ì¤€
        const fromSun = o.pos.length();

        if (obs.dist < successDist) {
          // ì¶©ë¶„íˆ ëª©í‘œ ê·¼ì²˜ì— ë„ë‹¬ â†’ ì„±ê³µ
          endEpisode(o, true);
        } else if (o.fuel <= 0 && obs.dist > successDist * 2.5) {
          // ì—°ë£Œê°€ ë‹¤ ë–¨ì–´ì§€ê³ , ì•„ì§ ë„ˆë¬´ ë©€ë‹¤ â†’ ì‹¤íŒ¨
          endEpisode(o, false);
        } else if (fromSun > outLimit) {
          // íƒœì–‘ì—ì„œ ë„ˆë¬´ ë©€ë¦¬ ì´íƒˆ â†’ ì‹¤íŒ¨
          endEpisode(o, false);
        } else if (episodeTime > 180) {
          // 3ë¶„(ì‹¤ì‹œê°„) ì´ìƒ ì œìë¦¬, ë§´ëŒê¸° ë“± â†’ ì‹¤íŒ¨ ì²˜ë¦¬
          endEpisode(o, false);
        }
      }
    }
  }

  // íŒŒí‹°í´ / ì—­ì¥ ì—…ë°ì´íŠ¸
  updateThrustParticles(dtReal);
  updateWarpFields(dtReal);

  // HUD ì¶œë ¥
  if (petsShip && sacShip) {
    const obsP = getObservation(petsShip);
    const obsS = getObservation(sacShip);
    hudBox.innerHTML =
      "PETS / SAC ìƒíƒœ<br>--------------------------<br>" +
      `Target: ${document.getElementById("autoTarget").value}<br>` +
      `PETS dist: ${obsP.dist.toFixed(1)}  v:${obsP.vel
        .length()
        .toFixed(2)} E:${obsP.totalE.toFixed(1)}<br>` +
      `PETS risk:${obsP.collisionRisk.toFixed(
        2
      )} fuel:${(petsShip.fuel * 100).toFixed(1)}%<br>` +
      `SAC  dist: ${obsS.dist.toFixed(1)}  v:${obsS.vel
        .length()
        .toFixed(2)} E:${obsS.totalE.toFixed(1)}<br>` +
      `SAC  risk:${obsS.collisionRisk.toFixed(
        2
      )} fuel:${(sacShip.fuel * 100).toFixed(1)}%<br>` +
      `(ìš°ì£¼ì„  ì†Œí™˜ â†’ ì˜ˆì¸¡ ê²½ë¡œ í™•ì¸ â†’ PETS/SAC ì„ íƒ)`;
  }

  updateCam();
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* ë¦¬ì‚¬ì´ì¦ˆ & ì´ˆê¸° UI */
window.addEventListener('resize',()=>{
  const w=app.clientWidth, h=app.clientHeight;
  renderer.setSize(w,h);
  camera.aspect=w/h;
  camera.updateProjectionMatrix();
});
document.getElementById('speed').value=String(timeScale);
document.getElementById('speedNum').value=String(timeScale);
focusSel.value='íƒœì–‘'; applyFocus(); radius=200; updateCam();
</script>
</body>
</html>







