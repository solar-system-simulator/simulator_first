<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>ÌÉúÏñëÍ≥Ñ + PETS / SAC RL</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #051022;
      color: #e9ecff;
      font: 13px/1.45 system-ui;
      overflow: hidden;
    }
    #app {
      position: fixed;
      inset: 0;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    .ui {
      position: fixed;
      left: 12px;
      top: 12px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
      padding: 10px;
      border-radius: 10px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      max-width: 96vw;
      z-index: 10;
    }
    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .btn {
      cursor: pointer;
      padding: 6px 9px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color: #e9ecff;
    }
    input[type=range] { width: 200px; }
    input[type=number],
    input[type=text] { width: 70px; }
    select {
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(0,0,0,.3);
      color: #e9ecff;
      font-size: 12px;
    }
    .small {
      font-size: 11px;
      opacity: .85;
    }
    .hud {
      position: fixed;
      right: 10px;
      bottom: 120px;
      padding: 8px 10px;
      background: rgba(0,0,0,.45);
      border-radius: 8px;
      font-family: monospace;
      font-size: 11px;
      max-width: 260px;
      line-height: 1.3;
      z-index: 10;
    }
    /* Í≤∞Í≥º Î™®Îã¨ Ïò§Î≤ÑÎ†àÏù¥ */
    #resultOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    #resultModal {
      background: #0b1220;
      border: 1px solid rgba(255,255,255,.3);
      border-radius: 14px;
      padding: 20px 36px;
      box-shadow: 0 18px 40px rgba(0,0,0,.7);
      text-align: center;
      min-width: 260px;
    }
    #resultModal h2 {
      margin: 0 0 6px;
      font-size: 20px;
    }
    #resultModal .percent {
      font-size: 32px;
      font-weight: bold;
      margin: 4px 0 12px;
      color: #ffe066;
    }
    #sideLog {
      position: fixed;
      right: 10px;
      bottom: 10px;
      padding: 8px 10px;
      background: rgba(0,0,0,.4);
      border-radius: 8px;
      font-size: 11px;
      max-width: 260px;
      max-height: 30vh;
      overflow-y: auto;
      z-index: 10;
    }
    #sideLog h3 {
      margin: 0 0 4px;
      font-size: 12px;
      opacity: .9;
    }
  </style>
</head>
<body>
<div id="app"></div>

<!-- UI Ìå®ÎÑê -->
<div class="ui">
  <div class="row">
    <label for="speed">ÏÜçÎèÑ (Ïùº/Ï¥à)</label>
    <input id="speed" type="range" min="0" max="500" step="0.1" value="0.3" />
    <input id="speedNum" type="text" value="0.3" />
    <button class="btn" data-rate="1">1√ó</button>
    <button class="btn" data-rate="10">10√ó</button>
    <button class="btn" data-rate="100">100√ó</button>
  </div>

  <div class="row">
    <label for="focusSel">Ï§ëÏã¨Ï†ê</label>
    <select id="focusSel">
      <option>ÏûêÏú†(ÏàòÎèô)</option>
      <option selected>ÌÉúÏñë</option>
      <option>ÏàòÏÑ±</option>
      <option>Í∏àÏÑ±</option>
      <option>ÏßÄÍµ¨</option>
      <option>Îã¨</option>
      <option>ÌôîÏÑ±</option>
      <option>Î™©ÏÑ±</option>
      <option>ÌÜ†ÏÑ±</option>
      <option>Ï≤úÏôïÏÑ±</option>
      <option>Ìï¥ÏôïÏÑ±</option>
      <option>Î™ÖÏôïÏÑ±</option>
    </select>
    <label>
      <input id="axisToggle" type="checkbox" checked />
      ÏûêÏ†ÑÏ∂ï ÌëúÏãú
    </label>
    <label>
      <input id="gravToggle" type="checkbox" />
      Ï§ëÎ†•Ïû• ÌëúÏãú(ÌñâÏÑ± Ìè¨Ìï®)
    </label>
  </div>

  <div class="row">
    <button class="btn" id="spawnShip">Ïö∞Ï£ºÏÑ† ÏÜåÌôò (PETS/SAC ÎπÑÍµê)</button>
    <button class="btn" id="spawnAst">ÏÜåÌñâÏÑ± Íµ∞ ÏÜåÌôò</button>
    <button class="btn" id="spawnField">Ïó≠Ïû• ÏÉùÏÑ±</button>
    <button class="btn" id="clearObjs">Î™®Îëê ÏÇ≠Ï†ú</button>
  </div>

  <!-- RL Í¥ÄÎ†® UI -->
  <div class="row">
    <label for="autoTarget">RL Î™©Ìëú</label>
    <select id="autoTarget">
      <option>ÏßÄÍµ¨</option>
      <option>Îã¨</option>
      <option>ÌôîÏÑ±</option>
      <option>Î™©ÏÑ±</option>
      <option>ÌÜ†ÏÑ±</option>
      <option>Ï≤úÏôïÏÑ±</option>
      <option>Ìï¥ÏôïÏÑ±</option>
      <option>Î™ÖÏôïÏÑ±</option>
      <option>ÌÉúÏñë</option>
      <option>ÏàòÏÑ±</option>
      <option>Í∏àÏÑ±</option>
    </select>
  </div>

  <div class="row small">
    <label><input id="petsEnable" type="checkbox" checked /> PETS</label>
    <label><input id="sacEnable" type="checkbox" checked /> SAC</label>
    <span>
      PETS F:<span id="petsFuel">-</span> R:<span id="petsRew">0</span> |
      SAC F:<span id="sacFuel">-</span> R:<span id="sacRew">0</span>
    </span>
  </div>

  <!-- PETS vs SAC ÏÑ†ÌÉù Î≤ÑÌäº -->
  <div class="row" id="choiceRow" style="display:none;">
    <button class="btn" id="choosePETS">PETS ÏÇ¨Ïö©</button>
    <button class="btn" id="chooseSAC">SAC ÏÇ¨Ïö©</button>
  </div>

  <div class="row small">
    <div>
      ÏãúÏûë ÏãúÍ∞Å:
      <span id="startTime">2025-01-01 00:00:00</span>
    </div>
    <div class="small">‚Ä¢ Ï¢åÌÅ¥Î¶≠: ÌöåÏ†Ñ ¬∑ Ìú†: Ï§å ¬∑ Ïö∞ÌÅ¥Î¶≠: Ìå¨</div>
  </div>
</div>

<div class="hud" id="hudBox">
  PETS / SAC ÏÉÅÌÉú<br>
  --------------------------<br>
  Ï¥àÍ∏∞Ìôî Ï§ë...
</div>

<!-- Í≤∞Í≥º Î™®Îã¨ -->
<div id="resultOverlay">
  <div id="resultModal">
    <h2>ÎπÑÌñâ Í≤∞Í≥º</h2>
    <div id="resultLine"></div>
    <div class="percent" id="resultPercent">ÏÑ±Í≥µÎ•† 0%</div>
    <div style="font-size:12px; opacity:.8;">(Î™®Îã¨ Î∞îÍπ•ÏùÑ ÌÅ¥Î¶≠ÌïòÎ©¥ Îã´ÌûàÍ≥† Ï¥àÍ∏∞Ìôî)</div>
  </div>
</div>

<!-- Í≤∞Í≥º Î°úÍ∑∏ -->
<div id="sideLog">
  <h3>Í≤∞Í≥º Î°úÍ∑∏</h3>
  <div id="logContent"></div>
</div>

<script src="./three.min.js"></script>
<!-- (No changes to HTML/CSS, showing only the <script> content with reorganized functions) -->
<script src="./three.min.js"></script>
<script>
// ========== Basic Three.js Setup ==========

const app = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(app.clientWidth, app.clientHeight);
renderer.setClearColor(0x051022, 1);
app.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  60,
  app.clientWidth / app.clientHeight,
  0.1,
  20000
);

// Camera orbit parameters
let radius = 260;
let phi    = THREE.MathUtils.degToRad(28);
let theta  = THREE.MathUtils.degToRad(40);
const manualTarget = new THREE.Vector3(0, 0, 0);
let focusTarget = null;

// =================================================================
// Utilities (Axis Creation, Camera Controls)
// =================================================================

function mkAxis(len) {
  const geo = new THREE.CylinderGeometry(0.04, 0.04, len, 8);
  const mat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.75,
  });
  const cyl = new THREE.Mesh(geo, mat);
  cyl.position.y = 0;
  return cyl;
}

function getTarget() {
  return focusTarget
    ? focusTarget.getWorldPosition(new THREE.Vector3())
    : manualTarget;
}

function updateCam() {
  const t = getTarget();
  const x = t.x + radius * Math.sin(phi) * Math.cos(theta);
  const y = t.y + radius * Math.cos(phi);
  const z = t.z + radius * Math.sin(phi) * Math.sin(theta);
  camera.position.set(x, y, z);
  camera.lookAt(t);
}
updateCam();

// ========== Time / Constants ==========

let simDate = new Date('2025-01-01T00:00:00Z');
let timeScale = 0.3;
const G = 5e-6;
const MAX_ACC = 0.3;

scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const sunLight = new THREE.PointLight(0xffffff, 2.2, 0, 2);
scene.add(sunLight);

const bodies          = {};
const heavyBodies     = [];
const axisList        = [];
const dynamicObjects  = [];
const lagrangeHelpers = [];
const warpFields      = [];   // Warp fields (distortion fields)
const thrustParticles = [];

const SIZE = 1;
const DIST = 1;

// =================================================================
// Celestial Body Creation and Orbits
// =================================================================

// Function to create a celestial body
function createBody({
  name,
  parent          = scene,
  size            = 1,
  color           = 0xffffff,
  orbitDist       = 0,
  orbitPeriodDays = 0,
  rotPeriodHours  = 24,
  axialTiltDeg    = 0,
  ecc             = 0,
  orbitInc        = 0,
  massScale       = 1,
} = {}) {
  const pivot = new THREE.Group();
  parent.add(pivot);
  pivot.rotation.x = THREE.MathUtils.degToRad(orbitInc || 0);

  const spin = new THREE.Group();
  spin.rotation.z = THREE.MathUtils.degToRad(axialTiltDeg || 0);
  pivot.add(spin);

  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(size * SIZE, 32, 32),
    new THREE.MeshStandardMaterial({ color, roughness: 0.85 })
  );
  spin.add(mesh);

  const axis = mkAxis(size * 3);
  spin.add(axis);
  axisList.push(axis);

  const mass = Math.max(1e-6, Math.pow(size, 3) * massScale);

  const body = {
    name,
    pivot,
    spin,
    mesh,
    orbitDist: orbitDist * DIST,
    orbitPeriodDays,
    rotPeriodHours,
    mass,
    ecc,
    orbitInc,
    meanAnomaly: Math.random() * Math.PI * 2,
    semiMajor: orbitDist * DIST,
  };

  bodies[name] = body;
  heavyBodies.push(body);
  return body;
}

// Planet and moon data
const defs = [
  { name: 'ÌÉúÏñë',   size: 10, dist: 0,    orbit: 0,         rotH: 25.38,           tilt: 7.25,  ecc: 0,          orbitInc: 0,    massScale: 1e6,   color: '#ffd54a' },
  { name: 'ÏàòÏÑ±',   size: 0.9, dist: 16,   orbit: 87.969,    rotH: 58.6462 * 24,    tilt: 0.01,  ecc: 0.205630,   orbitInc: 7.005, massScale: 0.055, color: '#555555' },
  { name: 'Í∏àÏÑ±',   size: 1.1, dist: 22,   orbit: 224.701,   rotH: -243.0185 * 24,  tilt: 177.36, ecc: 0.006772,   orbitInc: 3.394, massScale: 0.815, color: '#fff7c4' },
  { name: 'ÏßÄÍµ¨',   size: 1.2, dist: 30,   orbit: 365.256,   rotH: 0.99726963 * 24, tilt: 23.44,  ecc: 0.01671123, orbitInc: 0.0,   massScale: 1,     color: '#3a82ff' },
  { name: 'ÌôîÏÑ±',   size: 0.9, dist: 38,   orbit: 686.98,    rotH: 1.02595676 * 24, tilt: 25.19,  ecc: 0.0933941,  orbitInc: 1.85,  massScale: 0.107, color: '#d14b3a' },
  { name: 'Î™©ÏÑ±',   size: 4.0, dist: 60,   orbit: 4332.59,   rotH: 0.41354 * 24,    tilt: 3.13,   ecc: 0.04839266, orbitInc: 1.305, massScale: 318,   color: '#e6b56a' },
  { name: 'ÌÜ†ÏÑ±',   size: 3.6, dist: 78,   orbit: 10756.2,   rotH: 0.44401 * 24,    tilt: 26.73,  ecc: 0.055723,   orbitInc: 2.485, massScale: 95,    color: '#d2b48c' },
  { name: 'Ï≤úÏôïÏÑ±', size: 2.9, dist: 96,   orbit: 30707.49,  rotH: -0.71833 * 24,  tilt: 97.77,  ecc: 0.04565,    orbitInc: 0.77,  massScale: 14,    color: '#6ecff6' },
  { name: 'Ìï¥ÏôïÏÑ±', size: 2.8, dist: 112,  orbit: 60223.35,  rotH: 0.67125 * 24,   tilt: 28.32,  ecc: 0.00859048, orbitInc: 1.769, massScale: 17,    color: '#264bff' },
  { name: 'Î™ÖÏôïÏÑ±', size: 0.5, dist: 140,  orbit: 90560,     rotH: -6.3872 * 24,   tilt: 122.53, ecc: 0.24883,    orbitInc: 17.14, massScale: 0.0022, color: '#bbaea0' },
];

const planetStates = [];
for (const p of defs) {
  const body = createBody({
    name: p.name,
    size: p.size,
    orbitDist: p.dist,
    orbitPeriodDays: p.orbit,
    rotPeriodHours: p.rotH,
    axialTiltDeg: p.tilt,
    ecc: p.ecc,
    orbitInc: p.orbitInc,
    massScale: p.massScale,
    color: p.color,
  });
  planetStates.push({ def: p, node: body, moons: [] });
}

// Function to create orbit line
function createOrbitLine({a, e, iDeg, omegaDeg, OmegaDeg, color=0xffffff, opacity=0.25, segments=360}) {
  const pts = [];
  const iRad     = THREE.MathUtils.degToRad(iDeg || 0);
  const omegaRad = THREE.MathUtils.degToRad(omegaDeg || 0);
  const OmegaRad = THREE.MathUtils.degToRad(OmegaDeg || 0);
  for (let k = 0; k <= segments; k++) {
    const nu = (2 * Math.PI * k) / segments;
    const r = (a * (1 - e * e)) / (1 + e * Math.cos(nu));
    const v = new THREE.Vector3(r * Math.cos(nu), 0, r * Math.sin(nu));
    v.applyAxisAngle(new THREE.Vector3(0, 1, 0), omegaRad);
    v.applyAxisAngle(new THREE.Vector3(1, 0, 0), iRad);
    v.applyAxisAngle(new THREE.Vector3(0, 1, 0), OmegaRad);
    pts.push(v);
  }
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const mat = new THREE.LineBasicMaterial({color, transparent: true, opacity});
  const line = new THREE.Line(geo, mat);
  scene.add(line);
  return line;
}

// Draw orbits for each planet
for (const ps of planetStates) {
  const node = ps.node;
  if (node.orbitPeriodDays <= 0) continue;
  const name = ps.def.name;
  let col = 0x444c66;
  if (name === 'ÏàòÏÑ±') col = 0xaaaaaa;
  else if (name === 'Í∏àÏÑ±') col = 0xffc966;
  else if (name === 'ÏßÄÍµ¨') col = 0x3a82ff;
  else if (name === 'ÌôîÏÑ±') col = 0xff5533;
  else if (name === 'Î™©ÏÑ±') col = 0xe6b56a;
  else if (name === 'ÌÜ†ÏÑ±') col = 0xd2b48c;
  else if (name === 'Ï≤úÏôïÏÑ±') col = 0x6ecff6;
  else if (name === 'Ìï¥ÏôïÏÑ±') col = 0x264bff;
  else if (name === 'Î™ÖÏôïÏÑ±') col = 0xbbaea0;

  createOrbitLine({
    a: node.semiMajor,
    e: node.ecc || 0,
    iDeg: node.orbitInc || 0,
    omegaDeg: 0,
    OmegaDeg: 0,
    color: col,
    opacity: 0.25,
    segments: 400,
  });
}

// Moons and Saturn's rings
(() => {
  // Earth's moon
  const earth = bodies['ÏßÄÍµ¨'];
  if (!earth) return;
  const moon = createBody({
    name: 'Îã¨',
    parent: earth.pivot,
    size: 0.35,
    orbitDist: 4,
    orbitPeriodDays: 27.322,
    rotPeriodHours: 655.7,
    axialTiltDeg: 6.68,
    massScale: 0.0123,
    color: '#cfd6ff',
    showOrbit: false,
  });
  planetStates.find(x => x.def.name === 'ÏßÄÍµ¨').moons.push({
    ...moon,
    orbitDist: 4,
    orbitPeriodDays: 27.322,
    orbitalAngle: Math.random() * Math.PI * 2,
  });
})();

const majorMoons = {
  'Î™©ÏÑ±': [
    ['Ïù¥Ïò§',      7.0,   1.769,  '#ffd1a8'],
    ['Ïú†Î°úÌåå',    9.0,   3.551,  '#cfe8ff'],
    ['Í∞ÄÎãàÎ©îÎç∞', 11.0,   7.154,  '#e9d5b3'],
    ['ÏπºÎ¶¨Ïä§ÌÜ†', 14.0,  16.689,  '#c2b7a1'],
  ],
  'ÌÜ†ÏÑ±': [
    ['ÌÉÄÏù¥ÌÉÑ',    10.0,  15.95,  '#d9c28a'],
    ['ÏóîÏÖÄÎùºÎëêÏä§', 7.0,   1.37,  '#dfeaf7'],
  ],
  'Ï≤úÏôïÏÑ±': [
    ['Ìã∞ÌÉÄÎãàÏïÑ',  7.0,   8.7,   '#cfe6ff'],
    ['Ïò§Î≤†Î°†',    9.0,  13.5,   '#bfb8a6'],
  ],
  'Ìï¥ÏôïÏÑ±': [
    ['Ìä∏Î¶¨ÌÜ§',    7.0,   5.88,  '#98bfff'],
  ],
  'Î™ÖÏôïÏÑ±': [
    ['Ïπ¥Î°†',      3.0,   6.387, '#b0a59a'],
  ],
};

// Create moons for Jupiter, Saturn, etc.
for (const ps of planetStates) {
  const name   = ps.def.name;
  const planet = ps.node;
  const list   = majorMoons[name];
  if (!list) continue;

  for (const [mName, mDist, mPeriod, mColor] of list) {
    const moonBody = createBody({
      name: mName,
      parent: planet.pivot,
      size: 0.25,
      color: mColor,
      orbitDist: mDist,
      orbitPeriodDays: mPeriod,
      rotPeriodHours: mPeriod * 24,
      massScale: 0.01,
    });
    ps.moons.push({
      ...moonBody,
      orbitDist: mDist,
      orbitPeriodDays: mPeriod,
      orbitalAngle: Math.random() * Math.PI * 2,
    });
  }
}

// Saturn's rings
(() => {
  const saturn = bodies['ÌÜ†ÏÑ±'];
  if (!saturn) return;
  const r = 3.6 * 2;
  const geo = new THREE.RingGeometry(r, r * 1.6, 128);
  geo.rotateX(-Math.PI / 2);
  const mat = new THREE.MeshStandardMaterial({
    color: 0xd8cfae,
    roughness: 0.95,
    transparent: true,
    opacity: 0.6,
    side: THREE.DoubleSide,
  });
  const ring = new THREE.Mesh(geo, mat);
  saturn.pivot.add(ring);
})();

// =================================================================
// Physics & Observation Functions
// =================================================================

// Compute raw gravitational acceleration (planets only)
function computeGravitationalAccelerationRaw(pos) {
  const acc = new THREE.Vector3();
  for (const b of heavyBodies) {
    const bp = b.pivot.getWorldPosition(new THREE.Vector3());
    const rVec = new THREE.Vector3().subVectors(bp, pos);
    const r = rVec.length();
    if (r === 0) continue;

    const baseR = b.mesh.geometry.parameters.radius || 1;
    let maxRangeMul = 16;
    let effMass = b.mass;
    if (b.name === 'ÌÉúÏñë') effMass *= 0.0002;

    const rMax = baseR * maxRangeMul;
    if (r > rMax) continue;

    const r2 = Math.max(100, r * r);
    let accMag = (G * effMass) / r2;
    if (accMag > MAX_ACC) accMag = MAX_ACC;

    acc.addScaledVector(rVec.normalize(), accMag);
  }
  return acc;
}

// Compute gravitational acceleration (with warp effects)
function computeGravitationalAcceleration(pos) {
  const acc = new THREE.Vector3();
  for (const b of heavyBodies) {
    const bp = b.pivot.getWorldPosition(new THREE.Vector3());
    const rVec = new THREE.Vector3().subVectors(bp, pos);
    const r = rVec.length();
    if (r === 0) continue;

    const baseR = b.mesh.geometry.parameters.radius || 1;
    let maxRangeMul = 16;
    let effMass = b.mass;
    if (b.name === 'ÌÉúÏñë') effMass *= 0.0002;

    const rMax = baseR * maxRangeMul;
    if (r > rMax) continue;

    const r2 = Math.max(100, r * r);
    let accMag = (G * effMass) / r2;
    if (accMag > MAX_ACC) accMag = MAX_ACC;

    acc.addScaledVector(rVec.normalize(), accMag);
  }
  return applyWarpFieldsToAcceleration(pos, acc);
}

// Compute potential energy at a position
function computePotentialEnergy(pos, mass = 1) {
  let pe = 0;
  for (const b of heavyBodies) {
    const bp = b.pivot.getWorldPosition(new THREE.Vector3());
    const r = bp.distanceTo(pos);
    if (r > 0) pe += -G * b.mass * mass / r;
  }
  return pe;
}

// Compute collision risk at a position
function computeCollisionRisk(pos) {
  let risk = 0;

  // Planet collision risk
  for (const b of heavyBodies) {
    const bp = b.pivot.getWorldPosition(new THREE.Vector3());
    const r = bp.distanceTo(pos);
    const baseR = b.mesh.geometry.parameters.radius || 1;
    const safe  = baseR * 5;
    if (r < safe) {
      risk = Math.max(risk, (safe - r) / safe);
    }
  }

  // Asteroid collision risk
  for (const o of dynamicObjects) {
    if (!o.alive || o.type !== 'asteroid') continue;
    const r = o.pos.distanceTo(pos);
    const safe = (o.radius || 0.5) * 4;
    if (r < safe) {
      risk = Math.max(risk, (safe - r) / safe);
    }
  }

  return Math.min(1, risk);
}

// Compute avoidance vector for hazardous areas
function computeAvoidanceVector(pos) {
  const dir = new THREE.Vector3();

  // Avoid planets
  for (const b of heavyBodies) {
    const bp = b.pivot.getWorldPosition(new THREE.Vector3());
    const v = new THREE.Vector3().subVectors(pos, bp); // from planet to ship
    v.y *= 0.2;
    const d = v.length();
    const baseR = b.mesh.geometry.parameters.radius || 1;
    const safe = baseR * 5;
    if (d < safe && d > 1e-3) {
      const w = (safe - d) / safe;
      dir.addScaledVector(v.normalize(), w / d);
    }
  }

  // Avoid asteroids
  for (const o of dynamicObjects) {
    if (!o.alive || o.type !== 'asteroid') continue;
    const v = new THREE.Vector3().subVectors(pos, o.pos);
    v.y *= 0.2;
    const d = v.length();
    const safe = (o.radius || 0.5) * 4;
    if (d < safe && d > 1e-3) {
      const w = (safe - d) / safe;
      dir.addScaledVector(v.normalize(), w / d);
    }
  }

  return dir;
}

// Get warp field influence and nearest direction
function computeWarpFieldInfo(pos) {
  let maxInfluence = 0;
  let nearestDir = new THREE.Vector3(0, 0, 0);
  for (const f of warpFields) {
    const d = f.center.distanceTo(pos);
    if (d > f.radius) continue;
    const inf = 1 - d / f.radius;
    if (inf > maxInfluence) {
      maxInfluence = inf;
      nearestDir.subVectors(f.center, pos).normalize();
    }
  }
  return { influence: maxInfluence, dir: nearestDir };
}

// Get target planet position for RL
function getRLTargetPos() {
  const sel = document.getElementById('autoTarget').value;
  const b = bodies[sel];
  if (!b) return new THREE.Vector3(0, 0, 0);
  return b.pivot.getWorldPosition(new THREE.Vector3());
}

// Get observation for a ship
function getObservation(ship) {
  const targetPos = getRLTargetPos();
  const g = computeGravitationalAcceleration(ship.pos);
  const toTarget = new THREE.Vector3().subVectors(targetPos, ship.pos);
  const dist = toTarget.length();
  const vel = ship.vel.clone();
  const ke = 0.5 * ship.mass * vel.lengthSq();
  const pe = computePotentialEnergy(ship.pos, ship.mass);
  const totalE = ke + pe;
  const angMom = ship.pos.clone().cross(vel);
  const collisionRisk = computeCollisionRisk(ship.pos);
  const warpInfo = computeWarpFieldInfo(ship.pos);

  return {
    pos: ship.pos.clone(),
    vel,
    grav: g,
    toTarget,
    dist,
    fuel: ship.fuel,
    kinetic: ke,
    potential: pe,
    totalE,
    angMom,
    collisionRisk,
    warpInfluence: warpInfo.influence,
    warpDir: warpInfo.dir
  };
}

// =================================================================
// Spaceship and Asteroid Spawning
// =================================================================

function getNearestShip(pos) {
  let best = null, bestDist = Infinity;
  for (const o of dynamicObjects) {
    if (o.type !== 'ship') continue;
    const d = o.pos.distanceTo(pos);
    if (d < bestDist) { bestDist = d; best = o; }
  }
  return best;
}

function spawnSpaceshipSimple(pos, vel, policyType, color) {
  const geo = new THREE.ConeGeometry(0.3, 0.8, 8);
  geo.rotateX(Math.PI / 2);
  const mat = new THREE.MeshStandardMaterial({ color });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(pos);
  scene.add(mesh);
  const ship = {
    type: 'ship',
    mesh,
    pos: mesh.position.clone(),
    vel: vel.clone(),
    mass: 0.05,
    radius: 0.4,
    fuel: 1.0,
    maxThrust: 0.22,
    lastFuelUsed: 0,
    prevGoalDist: null,
    totalReward: 0,
    collided: false,
    policyType,
    alive: true
  };
  dynamicObjects.push(ship);
  return ship;
}

function spawnAsteroid(pos, vel) {
  const sBase = Math.random()*0.6+0.2;
  const s = sBase * 0.5;
  const geo = new THREE.DodecahedronGeometry(s, 0);
  const mat = new THREE.MeshStandardMaterial({ color: 0x999999 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(pos);
  scene.add(mesh);
  const obj = {
    type: 'asteroid',
    mesh,
    pos: mesh.position.clone(),
    vel: vel.clone(),
    mass: Math.pow(s, 3) * 0.2,
    radius: s,
    alive: true
  };
  dynamicObjects.push(obj);
  return obj;
}

function spawnAsteroidSwarm(centerPos, ship) {
  const pos = centerPos.clone();
  let dirToShip = new THREE.Vector3(0, 0, 0);
  if (ship) {
    pos.y = ship.pos.y;
    dirToShip.subVectors(ship.pos, pos);
    if (dirToShip.lengthSq() > 0) dirToShip.normalize();
  }
  const baseSpeed = ship ? 0.25 : 0.0;
  const baseVel = dirToShip.clone().multiplyScalar(baseSpeed);
  spawnAsteroid(pos, baseVel);
  const count = 6;
  for (let i = 0; i < count; i++) {
    const offset = new THREE.Vector3(
      (Math.random()-0.5)*4, 0, (Math.random()-0.5)*4
    );
    const p = pos.clone().add(offset);
    let v = baseVel.clone();
    if (ship && baseSpeed > 0) {
      const randomDir = new THREE.Vector3(
        (Math.random()-0.5)*0.3,
        (Math.random()-0.5)*0.05,
        (Math.random()-0.5)*0.3
      );
      v.add(randomDir).multiplyScalar(0.8 + Math.random()*0.6);
    }
    spawnAsteroid(p, v);
  }
}

// =================================================================
// Warp Field (Distortion Field) Creation & Updates
// =================================================================

function spawnWarpField() {
  const targetPos = getRLTargetPos();
  const mainShip  = activeShip || getNearestShip(targetPos);
  if (!mainShip) {
    console.warn('Ïó≠Ïû•ÏùÑ ÎßåÎì§ Ïö∞Ï£ºÏÑ†Ïù¥ ÏóÜÏäµÎãàÎã§.');
    return;
  }
  const center = new THREE.Vector3().lerpVectors(mainShip.pos, targetPos, 0.5);
  const radius   = 40;
  const strength = 0.8;
  const life     = 80;

  const sGeo = new THREE.SphereGeometry(radius, 32, 32);
  const sMat = new THREE.MeshBasicMaterial({
    color: 0x8844ff,
    transparent: true,
    opacity: 0.06,
    wireframe: true,
  });
  const sphere = new THREE.Mesh(sGeo, sMat);
  sphere.position.copy(center);
  scene.add(sphere);

  warpFields.push({ center, radius, strength, life, maxLife: life, sphere });
}

function updateWarpFields(dtReal) {
  for (let i = warpFields.length - 1; i >= 0; i--) {
    const f = warpFields[i];
    f.life -= dtReal;
    if (f.life <= 0) {
      scene.remove(f.sphere);
      warpFields.splice(i, 1);
      continue;
    }
    const t = f.life / f.maxLife;
    f.sphere.material.opacity = 0.06 * t;
  }
}

// Apply warp field distortion to acceleration
function applyWarpFieldsToAcceleration(pos, acc) {
  if (!warpFields.length) return acc;

  const sunBody = bodies['ÌÉúÏñë'];
  const sunPos = sunBody
    ? sunBody.pivot.getWorldPosition(new THREE.Vector3())
    : new THREE.Vector3(0, 0, 0);
  const targetPos = getRLTargetPos();

  for (const f of warpFields) {
    const d = f.center.distanceTo(pos);
    if (d > f.radius) continue;
    const falloff = 1 - d / f.radius;
    const strength = f.strength * falloff;
    const weaken = 1 - 0.4 * strength;
    acc.multiplyScalar(weaken);

    const toTarget = new THREE.Vector3().subVectors(targetPos, pos).normalize();
    const toSun    = new THREE.Vector3().subVectors(sunPos, pos).normalize();
    const lateral  = new THREE.Vector3().crossVectors(toSun, new THREE.Vector3(0,1,0)).normalize();
    const warpDir = new THREE.Vector3()
      .addScaledVector(toTarget, 0.8)
      .addScaledVector(lateral, 0.4)
      .normalize();
    const baseMag  = acc.length();
    const extraMag = baseMag * 1.2 * strength;
    acc.addScaledVector(warpDir, extraMag);
  }
  return acc;
}

// =================================================================
// Effects: Explosions and Thrust Particles
// =================================================================

function explodeAt(pos) {
  const group = new THREE.Group();
  for (let i = 0; i < 18; i++) {
    const geo = new THREE.SphereGeometry(0.06, 6, 6);
    const mat = new THREE.MeshBasicMaterial({color: 0xffaa44});
    const p = new THREE.Mesh(geo, mat);
    p.position.copy(pos);
    p.userData.v = new THREE.Vector3(
      (Math.random()-0.5)*2,
      (Math.random()-0.5)*2,
      (Math.random()-0.5)*2
    ).multiplyScalar(0.6);
    group.add(p);
  }
  scene.add(group);
  const t0 = performance.now();
  const id = setInterval(() => {
    const dt = (performance.now() - t0) / 1000;
    group.children.forEach(ch => {
      ch.position.addScaledVector(ch.userData.v, 0.04);
    });
    if (dt > 1.5) {
      clearInterval(id);
      scene.remove(group);
    }
  }, 50);
}

// Thrust particle effect
function spawnThrustParticle(ship, dir) {
  const geo = new THREE.SphereGeometry(0.15, 8, 8);
  const mat = new THREE.MeshBasicMaterial({
    color: ship.policyType === "PETS" ? 0xffdd66 : 0x66c0ff,
    transparent: true,
    opacity: 0.9
  });
  const p = new THREE.Mesh(geo, mat);
  const back = dir.clone().multiplyScalar(-1);
  p.position.copy(ship.pos).addScaledVector(back, ship.radius || 0.8);
  p.userData.vel = back.multiplyScalar(0.6);
  p.userData.life = 0.6;
  scene.add(p);
  thrustParticles.push(p);
}

function updateThrustParticles(dt) {
  for (let i = thrustParticles.length - 1; i >= 0; i--) {
    const p = thrustParticles[i];
    p.userData.life -= dt;
    p.position.addScaledVector(p.userData.vel, dt);
    p.material.opacity = Math.max(0, p.userData.life / 0.6);
    if (p.userData.life <= 0) {
      scene.remove(p);
      thrustParticles.splice(i, 1);
    }
  }
}

// =================================================================
// Reinforcement Learning Action Application (PETS / SAC)
// =================================================================

function applyRLAction(ship, action, dt) {
  const dir = action.dir.clone().normalize();
  const thrustOn = !!action.thrustOn;
  const fuelRatio = Math.max(0, Math.min(1, action.fuelRatio ?? 0.5));
  ship.lastFuelUsed = 0;
  if (thrustOn && ship.fuel > 0) {
    const thrustMag = ship.maxThrust * fuelRatio;
    ship.vel.addScaledVector(dir, thrustMag * dt);
    const fuelUsed = fuelRatio * dt * 0.9;
    ship.fuel = Math.max(0, ship.fuel - fuelUsed);
    ship.lastFuelUsed = fuelUsed;
    spawnThrustParticle(ship, dir);
  }
}

function stepPETS(ship, dt) {
  const obs = getObservation(ship);
  if (obs.dist < 1 || ship.fuel <= 0.01) return;

  const baseDir = obs.toTarget.clone().normalize();

  // Adjust for warp fields
  if (obs.warpInfluence > 0) {
    baseDir.addScaledVector(obs.warpDir, 0.4 * obs.warpInfluence);
  }

  // Avoid hazards
  const avoidDir = computeAvoidanceVector(obs.pos);
  if (avoidDir.lengthSq() > 1e-6) {
    baseDir.addScaledVector(avoidDir.normalize(), 0.8);
  }
  baseDir.normalize();

  let bestScore = -Infinity, bestDir = baseDir.clone();
  const horizon = 8, candCount = 16;
  for (let i = 0; i < candCount; i++) {
    const jitter = new THREE.Vector3(
      (Math.random()-0.5)*0.4,
      (Math.random()-0.5)*0.2,
      (Math.random()-0.5)*0.4
    );
    const candDir = baseDir.clone().add(jitter).normalize();
    let pos = obs.pos.clone();
    let vel = obs.vel.clone();
    let score = 0;
    for (let t = 0; t < horizon; t++) {
      const g = computeGravitationalAcceleration(pos);
      vel.addScaledVector(g, dt);
      vel.addScaledVector(candDir, ship.maxThrust * 0.5 * dt);
      pos.addScaledVector(vel, dt);

      const d = pos.distanceTo(getRLTargetPos());
      score -= d * 0.02;
      // Penalize strong gravity (near Sun)
      const gMag = g.length();
      score -= gMag * 1.2;
    }
    const risk = computeCollisionRisk(pos);
    score -= risk * 3;

    if (score > bestScore) {
      bestScore = score;
      bestDir.copy(candDir);
    }
  }

  applyRLAction(ship, {
    thrustOn: obs.dist > 1 && ship.fuel > 0.02,
    dir: bestDir,
    fuelRatio: 0.7
  }, dt);

  const progress = (ship.prevGoalDist ?? obs.dist) - obs.dist;
  const planePenalty = Math.abs(ship.pos.y) * 0.03;
  const gravPenalty  = obs.grav.length() * 6.0;
  ship.totalReward += progress * 15
                    - ship.lastFuelUsed * 20
                    - dt * 0.4
                    - planePenalty * dt
                    - gravPenalty  * dt;
  ship.prevGoalDist = obs.dist;

  document.getElementById('petsFuel').textContent = (ship.fuel*100).toFixed(1);
  document.getElementById('petsRew').textContent = ship.totalReward.toFixed(1);
}

function stepSAC(ship, dt) {
  const obs = getObservation(ship);
  if (obs.dist < 1 || ship.fuel <= 0.01) return;
  const toTargetDir = obs.toTarget.clone().normalize();
  const velDir = obs.vel.length() > 1e-3 ? obs.vel.clone().normalize() : new THREE.Vector3();
  const gravDir = obs.grav.length() > 1e-4 ? obs.grav.clone().normalize() : new THREE.Vector3();

  let baseDir = new THREE.Vector3()
    .addScaledVector(toTargetDir, 1.0)
    .addScaledVector(velDir, -0.5)
    .addScaledVector(gravDir, -0.2);

  if (obs.warpInfluence > 0) {
    baseDir.addScaledVector(obs.warpDir, 0.6 * obs.warpInfluence);
  }

  const avoidDir = computeAvoidanceVector(obs.pos);
  if (avoidDir.lengthSq() > 1e-6) {
    baseDir.addScaledVector(avoidDir.normalize(), 1.0);
  }

  // Add noise
  const noise = new THREE.Vector3(
    (Math.random()-0.5)*0.3,
    (Math.random()-0.5)*0.2,
    (Math.random()-0.5)*0.3
  );
  baseDir.add(noise.multiplyScalar(0.3));

  applyRLAction(ship, {
    thrustOn: obs.dist > 1 && ship.fuel > 0.02,
    dir: baseDir,
    fuelRatio: 0.5
  }, dt);

  const progress = (ship.prevGoalDist ?? obs.dist) - obs.dist;
  const planePenalty = Math.abs(ship.pos.y) * 0.025;
  const gravPenalty  = obs.grav.length() * 4.0;
  ship.totalReward += progress * 10
                    - ship.lastFuelUsed * 10
                    - dt * 0.3
                    - planePenalty * dt
                    - gravPenalty * dt;
  ship.prevGoalDist = obs.dist;

  document.getElementById('sacFuel').textContent = (ship.fuel*100).toFixed(1);
  document.getElementById('sacRew').textContent = ship.totalReward.toFixed(1);
}

// =================================================================
// Trajectory Prediction
// =================================================================

function predictTrajectory(ship, policyType, steps = 220, dtSec = 0.35) {
  const pts = [];
  let pos  = ship.pos.clone();
  let vel  = ship.vel.clone();
  let fuel = ship.fuel;

  const targetName = document.getElementById("autoTarget").value;
  const targetBody = bodies[targetName];

  let ghostDays = 0;
  const daysPerSec = Math.max(0.5, timeScale || 1);

  for (let i = 0; i < steps; i++) {
    const dDays = dtSec * daysPerSec;
    ghostDays += dDays;

    const targetPos = getFuturePlanetPos(targetBody, ghostDays);
    const toTarget = new THREE.Vector3().subVectors(targetPos, pos);
    const dist = toTarget.length();
    if (dist < 1.0) break;

    const g = computeGravitationalAccelerationRaw(pos);
    const toDir = toTarget.clone().normalize();
    let dir;
    if (policyType === "PETS") {
      const jitter = new THREE.Vector3(
        (Math.random()-0.5)*0.2,
        (Math.random()-0.5)*0.2,
        (Math.random()-0.5)*0.2
      );
      dir = toDir.clone().add(jitter).normalize();
    } else {
      const velDir = vel.length() > 1e-3 ? vel.clone().normalize() : new THREE.Vector3();
      const gravDir = g.length() > 1e-4 ? g.clone().normalize() : new THREE.Vector3();
      dir = new THREE.Vector3()
        .addScaledVector(toDir, 1.0)
        .addScaledVector(velDir, -0.4)
        .addScaledVector(gravDir, -0.2);
    }
    if (dir.lengthSq() > 1e-6) dir.normalize();

    const thrustOn = fuel > 0 && dist > 1.0;
    const fuelRatio = policyType === "PETS" ? 0.7 : 0.5;
    if (thrustOn) {
      const thrustMag = ship.maxThrust * fuelRatio;
      vel.addScaledVector(dir, thrustMag * dtSec);
      const fuelUsed = fuelRatio * dtSec * 0.6;
      fuel = Math.max(0, fuel - fuelUsed);
    }

    vel.addScaledVector(g, dtSec);
    pos.addScaledVector(vel, dtSec);
    pts.push(pos.clone());
  }
  return pts;
}

let petsPathLine = null, sacPathLine = null;
  
function showPredictedPath(ship, policyType, targetName) {
  // ‚ú® 1. pts Î®ºÏ†Ä Í≥ÑÏÇ∞
  const pts = predictTrajectoryWithAvoidance(ship, targetName);

  // ‚ú® 2. ptsÍ∞Ä ÏóÜÏúºÎ©¥ Ï¢ÖÎ£å
  if (!pts || !pts.length) return;

  // ‚ú® 3. ÎùºÏù∏ ÏÉùÏÑ±
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const color = policyType === "PETS" ? 0xffdd33 : 0x33aaff;
  const mat = new THREE.LineBasicMaterial({color, transparent: true, opacity: 0.8});
  const line = new THREE.Line(geo, mat);

  scene.add(line);

  // ‚ú® 4. Í∏∞Ï°¥ ÎùºÏù∏ Ï†úÍ±∞ ÌõÑ Í∞±Ïã†
  if (policyType === "PETS") {
    if (petsPathLine) scene.remove(petsPathLine);
    petsPathLine = line;
  } else {
    if (sacPathLine) scene.remove(sacPathLine);
    sacPathLine = line;
  }
}

// =================================================================
// UI Controls (Speed, Focus, etc.)
// =================================================================

const speed    = document.getElementById('speed');
const speedNum = document.getElementById('speedNum');

function setRate(v) {
  const n = parseFloat(v);
  timeScale = Math.max(0, isNaN(n)? 0 : n);
  speed.value = String(timeScale);
  speedNum.value = String(timeScale);
}
speed.addEventListener('input', e => setRate(e.target.value));
speedNum.addEventListener('input', () => setRate(speedNum.value));
document.querySelectorAll('.btn[data-rate]').forEach(btn => {
  btn.addEventListener('click', () => setRate(btn.dataset.rate));
});

const focusSel = document.getElementById('focusSel');
function applyFocus() {
  const v = focusSel.value;
  if (v === 'ÏûêÏú†(ÏàòÎèô)') focusTarget = null;
  else focusTarget = (bodies[v] ? bodies[v].pivot : null) || bodies['ÌÉúÏñë'].pivot;
  updateCam();
}
focusSel.addEventListener('change', applyFocus);
axisList.forEach(a => a.visible = true);

const gravToggle = document.getElementById('gravToggle');
let showGravityField = false;
let gravHelpers = [];
gravToggle.addEventListener('change', () => {
  showGravityField = gravToggle.checked;
});

// =================================================================
// Mouse Controls (Rotation, Panning, Click to Spawn)
// =================================================================

let dragging = false, px = 0, py = 0, button = 0;
const raycaster = new THREE.Raycaster();
const mouseVec  = new THREE.Vector2();
const clickPlane= new THREE.Plane(new THREE.Vector3(0,1,0), 0);
let pendingSpawn = null;

function getClickPositionOnPlane(e) {
  const rect = renderer.domElement.getBoundingClientRect();
  mouseVec.x = ((e.clientX - rect.left)/rect.width)*2 - 1;
  mouseVec.y = -((e.clientY - rect.top)/rect.height)*2 + 1;
  raycaster.setFromCamera(mouseVec, camera);
  const pos = new THREE.Vector3();
  const hit = raycaster.ray.intersectPlane(clickPlane, pos);
  if (!hit) {
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    pos.copy(camera.position).add(dir.multiplyScalar(30));
  }
  return pos;
}
app.addEventListener('mousedown', e => {
  if (e.button === 0 && pendingSpawn?.type === 'asteroid') {
    const pos = getClickPositionOnPlane(e);
    const shipN = getNearestShip(pos);
    spawnAsteroidSwarm(pos, shipN);
    pendingSpawn = null;
    return;
  }
  dragging = true;
  px = e.clientX;
  py = e.clientY;
  button = e.button;
});
window.addEventListener('mouseup', () => { dragging = false; });
app.addEventListener('contextmenu', e => e.preventDefault());
window.addEventListener('mousemove', e => {
  if (!dragging) return;
  const dx = e.clientX - px, dy = e.clientY - py;
  if (button === 0) {
    theta -= dx * 0.005;
    phi   -= dy * 0.005;
    const eps = 0.001;
    phi = Math.max(eps, Math.min(Math.PI - eps, phi));
  } else if (button === 2 && !focusTarget) {
    const s = radius * 0.0012;
    camera.updateMatrixWorld();
    const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd);
    const right = fwd.clone().cross(camera.up).normalize();
    const up = camera.up.clone().normalize();
    manualTarget.addScaledVector(right, -dx * s);
    manualTarget.addScaledVector(up, dy * s);
  }
  px = e.clientX; py = e.clientY;
  updateCam();
});
app.addEventListener('wheel', e => {
  e.preventDefault();
  radius *= 1 + Math.sign(e.deltaY) * 0.08;
  radius = Math.max(30, Math.min(5000, radius));
  updateCam();
}, {passive: false});

// =================================================================
// Button Events
// =================================================================

document.getElementById('spawnAst').addEventListener('click', () => {
  pendingSpawn = {type: 'asteroid'};
  console.log('ÏÜåÌñâÏÑ± Íµ∞ ÏÉùÏÑ± Î™®Îìú: ÌôîÎ©¥ÏùÑ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî.');
});
document.getElementById('spawnField').addEventListener('click', () => {
  spawnWarpField();
  console.log('Ïó≠Ïû• ÏÉùÏÑ±: Ïö∞Ï£ºÏÑ†Í≥º Î™©Ìëú ÏßÄÏ†ê ÏÇ¨Ïù¥Ïóê ÏÉùÏÑ±.');
});
document.getElementById('clearObjs').addEventListener('click', () => {
  dynamicObjects.forEach(o => scene.remove(o.mesh));
  dynamicObjects.length = 0;
  petsShip = null; sacShip = null; activeShip = null;
});

// =================================================================
// PETS/SAC Ship Spawning and Controls
// =================================================================

let petsShip = null, sacShip = null, activeShip = null;
let petsEnabled = true, sacEnabled = true;
let simulationPaused = false;
let episodeFinished = false;
let pathUpdateTimer = 0;

let totalAttempts = 0, totalSuccess = 0;

const choiceRow = document.getElementById('choiceRow');
const resultOverlay = document.getElementById('resultOverlay');
const resultLine = document.getElementById('resultLine');
const resultPercent = document.getElementById('resultPercent');
const logContent = document.getElementById('logContent');

document.getElementById('petsEnable').addEventListener('change', e => {
  petsEnabled = e.target.checked;
  if (petsShip) petsShip.mesh.visible = petsEnabled;
});
document.getElementById('sacEnable').addEventListener('change', e => {
  sacEnabled = e.target.checked;
  if (sacShip) sacShip.mesh.visible = sacEnabled;
});

let episodeTime = 0;

document.getElementById('spawnShip').addEventListener('click', () => {
  if (petsShip) { scene.remove(petsShip.mesh); petsShip.alive = false; }
  if (sacShip)  { scene.remove(sacShip.mesh); sacShip.alive = false; }
  petsShip = null; sacShip = null; activeShip = null;
  if (petsPathLine) scene.remove(petsPathLine);
  if (sacPathLine) scene.remove(sacPathLine);
  episodeFinished = false;
  simulationPaused = true;
  episodeTime = 0;

  let basePos;
  const earth = bodies['ÏßÄÍµ¨'];
  if (earth) {
    basePos = earth.pivot.getWorldPosition(new THREE.Vector3()).add(new THREE.Vector3(4, 0, 0));
  } else {
    basePos = new THREE.Vector3(30, 0, 0);
  }

  const vel = new THREE.Vector3(0, 0, 0.1);
  petsShip = spawnSpaceshipSimple(basePos.clone().add(new THREE.Vector3(0,0,-1.5)), vel, "PETS", 0xffdd33);
  sacShip  = spawnSpaceshipSimple(basePos.clone().add(new THREE.Vector3(0,0, 1.5)), vel, "SAC", 0x33aaff);

  showPredictedPath(petsShip, "PETS");
  showPredictedPath(sacShip, "SAC");
  pathUpdateTimer = 0;

  choiceRow.style.display = 'flex';
});

document.getElementById('choosePETS').addEventListener('click', () => {
  if (!petsShip) return;
  if (sacShip) { scene.remove(sacShip.mesh); sacShip.alive = false; sacShip = null; }
  if (sacPathLine) { scene.remove(sacPathLine); sacPathLine = null; }

  activeShip = petsShip;
  simulationPaused = false;
  choiceRow.style.display = 'none';
  pathUpdateTimer = 0;
});

document.getElementById('chooseSAC').addEventListener('click', () => {
  if (!sacShip) return;
  if (petsShip) { scene.remove(petsShip.mesh); petsShip.alive = false; petsShip = null; }
  if (petsPathLine) { scene.remove(petsPathLine); petsPathLine = null; }

  activeShip = sacShip;
  simulationPaused = false;
  choiceRow.style.display = 'none';
  pathUpdateTimer = 0;
});

// =================================================================
// Reset and Episode Management
// =================================================================

function resetAllEvents() {
  for (let i = dynamicObjects.length - 1; i >= 0; i--) {
    scene.remove(dynamicObjects[i].mesh);
  }
  dynamicObjects.length = 0;
  if (petsShip) { scene.remove(petsShip.mesh); petsShip = null; }
  if (sacShip)  { scene.remove(sacShip.mesh);  sacShip  = null; }
  activeShip = null;
  if (petsPathLine) { scene.remove(petsPathLine); petsPathLine = null; }
  if (sacPathLine)  { scene.remove(sacPathLine);  sacPathLine  = null; }
  thrustParticles.forEach(p => scene.remove(p));
  thrustParticles.length = 0;
  warpFields.forEach(f => { if (f.sphere) scene.remove(f.sphere); });
  warpFields.length = 0;
  simulationPaused = false;
  episodeFinished = false;
  pathUpdateTimer = 0;
}

function endEpisode(ship, success) {
  if (episodeFinished) return;
  episodeFinished = true;
  simulationPaused = true;
  totalAttempts++;
  if (success) totalSuccess++;
  const percent = Math.round(totalSuccess * 100 / totalAttempts);
  const targetName = document.getElementById('autoTarget').value;
  const method = ship.policyType || 'UNKNOWN';
  resultLine.textContent = `${method}Í∞Ä ${targetName} Ìñ•Ìï¥ ${success ? "ÏÑ±Í≥µ" : "Ïã§Ìå®"}ÌñàÏäµÎãàÎã§.`;
  resultPercent.textContent = `ÏÑ±Í≥µÎ•† ${percent}% (${totalSuccess}/${totalAttempts})`;
  resultOverlay.style.display = 'flex';

  const ts = new Date().toISOString().slice(11, 19);
  const line = document.createElement('div');
  line.textContent = `[${ts}] ${method} ‚Üí ${targetName}: ${success ? "ÏÑ±Í≥µ" : "Ïã§Ìå®"}`;
  logContent.prepend(line);
}

resultOverlay.addEventListener('click', e => {
  if (e.target === resultOverlay) {
    resultOverlay.style.display = 'none';
    resetAllEvents();
  }
});

// =================================================================
// Kepler and Future Position
// =================================================================

function getFuturePlanetPos(body, deltaDays) {
  if (!body) return new THREE.Vector3(0, 0, 0);
  if (!body.orbitPeriodDays || body.orbitPeriodDays <= 0) {
    return body.pivot.getWorldPosition(new THREE.Vector3());
  }
  const n = (2 * Math.PI) / body.orbitPeriodDays;
  const M0 = body.meanAnomaly || 0;
  const M = M0 + n * deltaDays;
  const e = body.ecc || 0;
  const E = solveKepler(M, e);
  const a = body.semiMajor;
  const b = a * Math.sqrt(Math.max(0, 1 - e*e));
  const x0 = a * (Math.cos(E) - e);
  const z0 = -b * Math.sin(E);
  const pos = new THREE.Vector3(x0, 0, z0);
  const iRad = THREE.MathUtils.degToRad(body.orbitInc || 0);
  pos.applyAxisAngle(new THREE.Vector3(1, 0, 0), iRad);
  return pos;
}

// üîπ Í∞úÏÑ†Îêú ÏòàÏ∏° Í∂§ÎèÑ ÏÉùÏÑ± Ìï®Ïàò: Î™©Ìëú Ïù¥Îèô + ÌöåÌîº Ìè¨Ìï®
function predictTrajectoryWithAvoidance(ship, targetName) {
  const steps = 300;
  const dtSec = 3 * 3600;
  const dtDay = dtSec / 86400;

  const ghostShip = {
    pos: ship.pos.clone(),
    vel: ship.vel.clone(),
    alive: true
  };

  const pathPts = [];
  let t = 0;

  const targetBody = bodies[targetName];
  const targetR = targetBody?.mesh?.geometry?.parameters?.radius || 1;

  for (let i = 0; i < steps; i++) {
    const p = ghostShip.pos.clone();
    pathPts.push(p);

    t += dtDay;

    const futureTargetPos = getFuturePlanetPos(targetBody, t);
    const toTarget = futureTargetPos.clone().sub(ghostShip.pos);

    let dir = toTarget.clone().normalize();

    const avoid = computeAvoidanceVector(ghostShip.pos);
    dir.addScaledVector(avoid, 0.7).normalize();

    const thrustAcc = dir.clone().multiplyScalar(ship.maxThrust * 0.003);
    ghostShip.vel.add(thrustAcc);

    const g = computeGravitationalAccelerationRaw(ghostShip.pos);
    ghostShip.vel.addScaledVector(g, dtSec);

    ghostShip.pos.addScaledVector(ghostShip.vel, dtSec);

    const dist = ghostShip.pos.distanceTo(futureTargetPos);
    if (dist < targetR * 4) break;
  }

  return pathPts;
}

  
function solveKepler(M, e) {
  let E = M;
  for (let i = 0; i < 12; i++) {
    const f = E - e * Math.sin(E) - M;
    const fp = 1 - e * Math.cos(E);
    E -= f / fp;
  }
  return E;
}

// =================================================================
// Main Simulation Loop
// =================================================================

let last = performance.now();
const hudBox = document.getElementById('hudBox');

function tick(now) {
  const dtReal = (now - last) / 1000;
  last = now;

  const dtDays = simulationPaused ? 0 : dtReal * timeScale;

  if (!simulationPaused && !episodeFinished && activeShip) {
    episodeTime += dtReal;
  }

  if (dtDays !== 0) {
    simDate = new Date(simDate.getTime() + dtDays * 24 * 3600 * 1000);
    document.getElementById("startTime").textContent =
      simDate.toISOString().replace("T", " ").slice(0, 19);
  }

  if (activeShip && !episodeFinished) {
    pathUpdateTimer -= dtReal;
    if (pathUpdateTimer <= 0) {
      showPredictedPath(activeShip, activeShip.policyType);
      pathUpdateTimer = 0.7;
    }
  }

  const physScale = Math.max(0, Math.min(timeScale, 100));
  const dtPhys = simulationPaused ? 0 : dtReal * physScale;

  // Sun rotation
  const sunBody = bodies["ÌÉúÏñë"];
  if (sunBody && dtDays !== 0) {
    sunBody.spin.rotation.y += dtDays * (2 * Math.PI / defs[0].rotH);
  }

  // Planet revolution and rotation
  if (dtDays !== 0) {
    for (const ps of planetStates) {
      const node = ps.node;
      if (node.orbitPeriodDays > 0) {
        const n = (2 * Math.PI) / node.orbitPeriodDays;
        node.meanAnomaly = (node.meanAnomaly + n * dtDays) % (2 * Math.PI);
        const M = node.meanAnomaly, e = node.ecc || 0;
        const E = solveKepler(M, e);
        const a = node.semiMajor;
        const b = a * Math.sqrt(Math.max(0, 1 - e*e));
        const x0 = a * (Math.cos(E) - e);
        const z0 = -b * Math.sin(E);
        const pos = new THREE.Vector3(x0, 0, z0);
        const iRad = THREE.MathUtils.degToRad(node.orbitInc || 0);
        pos.applyAxisAngle(new THREE.Vector3(1, 0, 0), iRad);
        node.pivot.position.copy(pos);
      }
      const rotDays = Math.abs(node.rotPeriodHours) / 24;
      const rotSgn = node.rotPeriodHours >= 0 ? 1 : -1;
      if (rotDays > 0) {
        node.spin.rotation.y += rotSgn * dtDays * (2 * Math.PI / rotDays);
      }
    }
  }

  // Moons revolution and rotation
  if (dtDays !== 0) {
    for (const ps of planetStates) {
      for (const m of ps.moons) {
        if (!m.pivot || !m.spin) continue;
        if (m.orbitPeriodDays && m.orbitPeriodDays > 0) {
          const w = (2 * Math.PI) / m.orbitPeriodDays;
          m.orbitalAngle = (m.orbitalAngle || 0) + w * dtDays;
          const r = m.orbitDist || 0;
          const x = r * Math.cos(m.orbitalAngle);
          const z = r * Math.sin(m.orbitalAngle);
          m.pivot.position.set(x, 0, z);
        }
        const rotH = m.rotPeriodHours || 0;
        const rotDays = Math.abs(rotH) / 24;
        const rotSgn = rotH >= 0 ? 1 : -1;
        if (rotDays > 0) {
          m.spin.rotation.y += rotSgn * dtDays * (2 * Math.PI / rotDays);
        }
      }
    }
  }

  // Dynamic objects update (ships and asteroids)
  if (dtPhys > 0 && dynamicObjects.length > 0) {
    for (let i = dynamicObjects.length - 1; i >= 0; i--) {
      const o = dynamicObjects[i];
      if (!o.alive) continue;

      // Apply RL policy if ship
      if (o.type === "ship" && !episodeFinished) {
        if (o.policyType === "PETS" && petsEnabled) stepPETS(o, dtPhys);
        else if (o.policyType === "SAC" && sacEnabled) stepSAC(o, dtPhys);
      }

      // Update physics (semi-implicit integration)
      const a0 = computeGravitationalAcceleration(o.pos);
      o.pos.addScaledVector(o.vel, dtPhys).addScaledVector(a0, 0.5 * dtPhys * dtPhys);
      const a1 = computeGravitationalAcceleration(o.pos);
      o.vel.addScaledVector(a0.add(a1).multiplyScalar(0.5), dtPhys);
      o.mesh.position.copy(o.pos);

      // Collision with planets
      for (const hb of heavyBodies) {
        const hp = hb.pivot.getWorldPosition(new THREE.Vector3());
        const dist = hp.distanceTo(o.pos);
        const rBody = hb.mesh.geometry.parameters.radius || 1;
        if (dist < rBody * 1.1 + (o.radius || 0.5)) {
          explodeAt(o.pos);
          if (o.type === "ship") {
            o.collided = true;
            o.totalReward -= 50;
            endEpisode(o, false);
          }
          scene.remove(o.mesh);
          o.alive = false;
          dynamicObjects.splice(i, 1);
          break;
        }
      }

      // Check success/failure for ships
      if (o.type === "ship" && !episodeFinished && o.policyType) {
        const obs = getObservation(o);
        const targetName = document.getElementById("autoTarget").value;
        const targetBody = bodies[targetName];
        const targetR = targetBody
          ? targetBody.mesh.geometry.parameters.radius || 1
          : 1;
        const successDist = targetR * 4;
        const outLimit = 500;
        const fromSun = o.pos.length();

        if (obs.dist < successDist) {
          endEpisode(o, true);
        } else if (o.fuel <= 0 && obs.dist > successDist * 2.5) {
          endEpisode(o, false);
        } else if (fromSun > outLimit) {
          endEpisode(o, false);
        } else if (episodeTime > 180) {
          endEpisode(o, false);
        }
      }
    }
  }

  // Particle and warp field updates
  updateThrustParticles(dtReal);
  updateWarpFields(dtReal);

  // HUD display
  if (petsShip && sacShip) {
    const obsP = getObservation(petsShip);
    const obsS = getObservation(sacShip);
    hudBox.innerHTML =
      "PETS / SAC ÏÉÅÌÉú<br>--------------------------<br>" +
      `Target: ${document.getElementById("autoTarget").value}<br>` +
      `PETS dist: ${obsP.dist.toFixed(1)}  v:${obsP.vel.length().toFixed(2)} E:${obsP.totalE.toFixed(1)}<br>` +
      `PETS risk:${obsP.collisionRisk.toFixed(2)} fuel:${(petsShip.fuel * 100).toFixed(1)}%<br>` +
      `SAC  dist: ${obsS.dist.toFixed(1)}  v:${obsS.vel.length().toFixed(2)} E:${obsS.totalE.toFixed(1)}<br>` +
      `SAC  risk:${obsS.collisionRisk.toFixed(2)} fuel:${(sacShip.fuel * 100).toFixed(1)}%<br>` +
      `(Ïö∞Ï£ºÏÑ† ÏÜåÌôò ‚Üí ÏòàÏ∏° Í≤ΩÎ°ú ÌôïÏù∏ ‚Üí PETS/SAC ÏÑ†ÌÉù)`;
  }

  updateCam();
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);
</script>

</body>
</html>





