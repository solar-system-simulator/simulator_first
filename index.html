<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Three.js 태양계 (중력 시뮬레이션 + 타원궤도 · 위성 · 라그랑주)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #051022;
      color: #e9ecff;
      font: 13px/1.45 system-ui;
    }
    #app {
      position: fixed;
      inset: 0;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    .ui {
      position: fixed;
      left: 12px;
      top: 12px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
      padding: 10px;
      border-radius: 10px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      max-width: 96vw;
    }
    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .btn {
      cursor: pointer;
      padding: 6px 9px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
    }
    input[type=range] { width: 200px; }
    input[type=number],
    input[type=text] { width: 70px; }
    .small {
      font-size: 11px;
      opacity: .85;
    }
  </style>
</head>
<body>
<div id="app"></div>

<!-- UI 패널 -->
<div class="ui">
  <div class="row">
    <label for="speed">속도 (일/초)</label>
    <input id="speed" type="range" min="0" max="500" step="0.1" value="0.3" />
    <input id="speedNum" type="text" value="0.3" />
    <button class="btn" data-rate="1">1×</button>
    <button class="btn" data-rate="10">10×</button>
    <button class="btn" data-rate="100">100×</button>
  </div>

  <div class="row">
    <label for="focusSel">중심점</label>
    <select id="focusSel">
      <option>자유(수동)</option>
      <option selected>태양</option>
      <option>수성</option>
      <option>금성</option>
      <option>지구</option>
      <option>달</option>
      <option>화성</option>
      <option>목성</option>
      <option>토성</option>
      <option>천왕성</option>
      <option>해왕성</option>
      <option>명왕성</option>
    </select>
    <label>
      <input id="axisToggle" type="checkbox" checked />
      자전축 표시
    </label>
    <label>
      <input id="gravToggle" type="checkbox" />
      중력장 표시(행성 포함)
    </label>
  </div>

  <div class="row">
    <button class="btn" id="spawnShip">우주선 소환</button>
    <button class="btn" id="delShip">우주선 삭제</button>
    <button class="btn" id="spawnAst">소행성 소환</button>
    <button class="btn" id="clearObjs">모두 삭제</button>
  </div>

  <div class="row small">
    <div>
      시작 시각:
      <span id="startTime">2025-01-01 00:00:00</span>
    </div>
    <div class="small">• 좌클릭: 회전 · 휠: 줌 · 우클릭: 팬</div>
  </div>
</div>

<script src="./three.min.js"></script>
<script>
/*
 * 전체 기능 요약
 *  - 케플러 방정식을 이용한 타원 궤도 (이심률 포함)
 *  - 행성별 대표 위성 생성
 *  - 라그랑주 포인트(L1, L2, L4, L5) 시각화
 *  - 우주선/소행성: 중력 영향을 받는 동적 객체 (velocity verlet 적분)
 *  - 속도 조절, 중심점 변경, 자전축/중력장 토글
 */

/* -------------------------------------------------
 * 기본 Three.js 설정
 * ------------------------------------------------- */
const app = document.getElementById('app');

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(app.clientWidth, app.clientHeight);
renderer.setClearColor(0x051022, 1);
app.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  60,
  app.clientWidth / app.clientHeight,
  0.1,
  20000
);

// 카메라 궤도 파라미터
let radius = 220;
let phi    = THREE.MathUtils.degToRad(28);
let theta  = THREE.MathUtils.degToRad(40);

const manualTarget = new THREE.Vector3(0, 0, 0);
let focusTarget = null;

function getTarget() {
  return focusTarget
    ? focusTarget.getWorldPosition(new THREE.Vector3())
    : manualTarget;
}

function updateCam() {
  const t = getTarget();

  const x = t.x + radius * Math.sin(phi) * Math.cos(theta);
  const y = t.y + radius * Math.cos(phi);
  const z = t.z + radius * Math.sin(phi) * Math.sin(theta);

  camera.position.set(x, y, z);
  camera.lookAt(t);
}
updateCam();

/* -------------------------------------------------
 * 시뮬레이션 시간 / 상수
 * ------------------------------------------------- */
let simDate   = new Date('2025-01-01T00:00:00Z');
let timeScale = 0.3;       // 일/초 (기본 속도)
const G       = 5e-6;      // 동적 객체용 중력 상수
const MAX_ACC = 0.3;       // 한 번에 너무 큰 가속도 방지

scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const sunLight = new THREE.PointLight(0xffffff, 2.2, 0, 2);
scene.add(sunLight);

/* -------------------------------------------------
 * 전역 컨테이너
 * ------------------------------------------------- */
const bodies          = {};  // 이름 -> 천체 정보
const heavyBodies     = [];  // 중력에 참여하는 천체
const axisList        = [];  // 자전축 메쉬
const dynamicObjects  = [];  // 우주선/소행성
const lagrangeHelpers = [];  // 라그랑주 포인트 표시

const SIZE = 1;
const DIST = 1;

/* -------------------------------------------------
 * 유틸 함수
 * ------------------------------------------------- */
function mkRing(r, color = 0x2a3355, opacity = 0.8) {
  const geo = new THREE.RingGeometry(r - 0.12, r + 0.12, 256);
  geo.rotateX(-Math.PI / 2);
  const mat = new THREE.MeshBasicMaterial({
    color,
    transparent: true,
    opacity,
    side: THREE.DoubleSide,
  });
  return new THREE.Mesh(geo, mat);
}

function mkAxis(len) {
  const geo = new THREE.CylinderGeometry(0.04, 0.04, len, 8);
  const mat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.75,
  });
  const cyl = new THREE.Mesh(geo, mat);
  cyl.position.y = 0;
  return cyl;
}

/* -------------------------------------------------
 * 천체 생성 함수
 * ------------------------------------------------- */
function createBody({
  name,
  parent          = scene,
  size            = 1,
  color           = 0xffffff,
  orbitDist       = 0,
  orbitPeriodDays = 0,
  rotPeriodHours  = 24,
  axialTiltDeg    = 0,
  ecc             = 0,
  orbitInc        = 0,
  massScale       = 1,
  showOrbit       = true,
  primary         = null,
} = {}) {
  // 공전용 pivot
  const pivot = new THREE.Group();
  parent.add(pivot);
  pivot.rotation.x = THREE.MathUtils.degToRad(orbitInc || 0);

  // 자전축 기울기용 그룹
  const spin = new THREE.Group();
  spin.rotation.z = THREE.MathUtils.degToRad(axialTiltDeg || 0);
  pivot.add(spin);

  // 행성 메쉬
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(size * SIZE, 32, 32),
    new THREE.MeshStandardMaterial({
      color,
      roughness: 0.85,
    })
  );
  spin.add(mesh);

  // 자전축
  const axis = mkAxis(size * 3);
  spin.add(axis);
  axisList.push(axis);

  // 공전 궤도 링 (태양 중심만)
  if (showOrbit && parent === scene && orbitDist > 0) {
    scene.add(mkRing(orbitDist * DIST, 0x335577, 0.12));
  }

  const mass = Math.max(1e-6, Math.pow(size, 3) * massScale);

  const body = {
    name,
    pivot,
    spin,
    mesh,
    orbitDist: orbitDist * DIST,
    orbitPeriodDays,
    rotPeriodHours,
    mass,
    ecc,
    orbitInc,
    primary,
    meanAnomaly: Math.random() * Math.PI * 2,
    semiMajor: orbitDist * DIST,
  };

  bodies[name] = body;
  heavyBodies.push(body);

  return body;
}

/* -------------------------------------------------
 * 행성 데이터 정의
 * ------------------------------------------------- */
const defs = [
  { name: '태양', size: 10,   dist: 0,   orbit: 0,       rotH: 25.38,         tilt: 7.25,  ecc: 0,          orbitInc: 0,    massScale: 1e6,   color: '#ffd54a' },
  { name: '수성', size: 0.9,  dist: 16,  orbit: 87.969,  rotH: 58.6462 * 24, tilt: 0.01,  ecc: 0.205630,   orbitInc: 7.005, massScale: 0.055, color: '#555555' },
  { name: '금성', size: 1.1,  dist: 22,  orbit: 224.701, rotH: -243.0185 * 24, tilt: 177.36, ecc: 0.006772, orbitInc: 3.394, massScale: 0.815, color: '#fff7c4' },
  { name: '지구', size: 1.2,  dist: 30,  orbit: 365.256, rotH: 0.99726963 * 24, tilt: 23.44, ecc: 0.01671123, orbitInc: 0.0,   massScale: 1,     color: '#3a82ff' },
  { name: '화성', size: 0.9,  dist: 38,  orbit: 686.98,  rotH: 1.02595676 * 24, tilt: 25.19, ecc: 0.0933941, orbitInc: 1.85,  massScale: 0.107, color: '#d14b3a' },
  { name: '목성', size: 4.0,  dist: 60,  orbit: 4332.59, rotH: 0.41354 * 24, tilt: 3.13,  ecc: 0.04839266, orbitInc: 1.305, massScale: 318,   color: '#e6b56a' },
  { name: '토성', size: 3.6,  dist: 78,  orbit: 10756.2, rotH: 0.44401 * 24, tilt: 26.73, ecc: 0.055723,   orbitInc: 2.485, massScale: 95,    color: '#d2b48c' },
  { name: '천왕성', size: 2.9, dist: 96,  orbit: 30707.49, rotH: -0.71833 * 24, tilt: 97.77, ecc: 0.04565, orbitInc: 0.77,  massScale: 14,    color: '#6ecff6' },
  { name: '해왕성', size: 2.8, dist: 112, orbit: 60223.35, rotH: 0.67125 * 24, tilt: 28.32, ecc: 0.00859048, orbitInc: 1.769, massScale: 17,   color: '#264bff' },
  { name: '명왕성', size: 0.5, dist: 140, orbit: 90560,   rotH: -6.3872 * 24, tilt: 122.53, ecc: 0.24883, orbitInc: 17.14, massScale: 0.0022, color: '#bbaea0' },
];

// 행성 및 상태 배열
const planetStates = [];
for (const p of defs) {
  const body = createBody({
    name: p.name,
    size: p.size,
    orbitDist: p.dist,
    orbitPeriodDays: p.orbit,
    rotPeriodHours: p.rotH,
    axialTiltDeg: p.tilt,
    ecc: p.ecc,
    orbitInc: p.orbitInc,
    massScale: p.massScale,
    color: p.color,
  });
  planetStates.push({ def: p, node: body, moons: [] });
}

/* -------------------------------------------------
 * 위성 추가 (달 + 주요 위성)
 * ------------------------------------------------- */
// 지구의 달
(() => {
  const earth = bodies['지구'];
  if (!earth) return;

  const moon = createBody({
    name: '달',
    parent: earth.pivot,
    size: 0.35,
    orbitDist: 4,
    orbitPeriodDays: 27.322,
    rotPeriodHours: 655.7,
    axialTiltDeg: 6.68,
    massScale: 0.0123,
    color: '#cfd6ff',
    showOrbit: false,
  });

  planetStates
    .find((x) => x.def.name === '지구')
    .moons.push({
      ...moon,
      orbitDist: 4,
      orbitPeriodDays: 27.322,
      orbitalAngle: Math.random() * Math.PI * 2,
    });
})();

// 기타 행성 주요 위성
const majorMoons = {
  '목성': [
    ['이오',      0.7,  1.769, '#ffd1a8'],
    ['유로파',    1.3,  3.551, '#cfe8ff'],
    ['가니메데',  2.1,  7.154, '#e9d5b3'],
    ['칼리스토',  3.0, 16.689, '#c2b7a1'],
  ],
  '토성': [
    ['타이탄',     3.5, 15.95, '#d9c28a'],
    ['엔셀라두스', 1.1,  1.37, '#dfeaf7'],
  ],
  '천왕성': [
    ['티타니아', 1.6,  8.7, '#cfe6ff'],
    ['오베론',   2.0, 13.5, '#bfb8a6'],
  ],
  '해왕성': [
    ['트리톤', 2.1, 5.88, '#98bfff'],
  ],
  '명왕성': [
    ['카론', 1.2, 6.387, '#b0a59a'],
  ],
};

for (const ps of planetStates) {
  const name = ps.def.name;
  if (!majorMoons[name]) continue;

  for (const [mName, mDist, mPeriod, mColor] of majorMoons[name]) {
    const moon = createBody({
      name: mName,
      parent: ps.node.pivot,
      size: 0.25,
      color: mColor,
      orbitDist: mDist,
      orbitPeriodDays: mPeriod,
      massScale: 0.01,
      showOrbit: false,
    });

    ps.moons.push({
      ...moon,
      orbitDist: mDist,
      orbitPeriodDays: mPeriod,
      orbitalAngle: Math.random() * Math.PI * 2,
    });
  }
}

// 토성 고리
(() => {
  const sat = bodies['토성'];
  if (!sat) return;

  const r = 3.6 * 2;
  const geo = new THREE.RingGeometry(r, r * 1.6, 128);
  geo.rotateX(-Math.PI / 2);
  const mat = new THREE.MeshStandardMaterial({
    color: 0xd8cfae,
    roughness: 0.95,
    transparent: true,
    opacity: 0.6,
    side: THREE.DoubleSide,
  });
  const ring = new THREE.Mesh(geo, mat);
  sat.pivot.add(ring);
})();

/* -------------------------------------------------
 * 동적 객체 (우주선, 소행성)
 * ------------------------------------------------- */
function spawnSpaceship(pos, vel) {
  const geo = new THREE.ConeGeometry(0.6, 1.6, 8);
  geo.rotateX(Math.PI / 2);
  const mat = new THREE.MeshStandardMaterial({ color: 0x88ffdd });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(pos);
  scene.add(mesh);

  const obj = {
    type: 'ship',
    mesh,
    pos: mesh.position.clone(),
    vel: vel.clone(),
    mass: 0.01,
    radius: 0.8,
  };
  dynamicObjects.push(obj);
  return obj;
}

function spawnAsteroid(pos, vel) {
  const s = Math.random() * 0.6 + 0.2;
  const geo = new THREE.DodecahedronGeometry(s, 0);
  const mat = new THREE.MeshStandardMaterial({ color: 0x999999 });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(pos);
  scene.add(mesh);

  const obj = {
    type: 'asteroid',
    mesh,
    pos: mesh.position.clone(),
    vel: vel.clone(),
    mass: Math.pow(s, 3) * 0.2,
    radius: s,
  };
  dynamicObjects.push(obj);
  return obj;
}

// 간단한 폭발 이펙트
function explodeAt(pos) {
  const group = new THREE.Group();

  for (let i = 0; i < 18; i++) {
    const geo = new THREE.SphereGeometry(0.06, 6, 6);
    const mat = new THREE.MeshBasicMaterial({ color: 0xffaa44 });
    const p   = new THREE.Mesh(geo, mat);

    p.position.copy(pos);
    p.userData.v = new THREE.Vector3(
      (Math.random() - 0.5) * 2,
      (Math.random() - 0.5) * 2,
      (Math.random() - 0.5) * 2,
    ).multiplyScalar(0.6);

    group.add(p);
  }

  scene.add(group);

  const t0 = performance.now();
  const id = setInterval(() => {
    const dt = (performance.now() - t0) / 1000;
    group.children.forEach((ch) => {
      ch.position.addScaledVector(ch.userData.v, 0.04);
    });
    if (dt > 1.5) {
      clearInterval(id);
      scene.remove(group);
    }
  }, 50);
}

/* -------------------------------------------------
 * 중력 계산
 * ------------------------------------------------- */
function computeGravitationalAcceleration(pos, ignoreBody = null) {
  const acc = new THREE.Vector3();

  for (const b of heavyBodies) {
    if (b === ignoreBody) continue;

    const bp   = b.pivot.getWorldPosition(new THREE.Vector3());
    const rVec = new THREE.Vector3().subVectors(bp, pos);
    const r2   = Math.max(25, rVec.lengthSq());  // 너무 가까울 때 폭주 방지

    let accMag = (G * b.mass) / r2;
    if (accMag > MAX_ACC) accMag = MAX_ACC;

    acc.addScaledVector(rVec.normalize(), accMag);
  }

  return acc;
}

/* -------------------------------------------------
 * 라그랑주 포인트 표시
 * ------------------------------------------------- */
function updateLagrangeFor(planet) {
  // 이전 표시 삭제
  for (let i = lagrangeHelpers.length - 1; i >= 0; i--) {
    if (lagrangeHelpers[i].userData.parent === planet) {
      scene.remove(lagrangeHelpers[i]);
      lagrangeHelpers.splice(i, 1);
    }
  }

  const sun = bodies['태양'];
  if (!sun) return;

  const rp = planet.pivot.getWorldPosition(new THREE.Vector3());
  const rs = sun.pivot.getWorldPosition(new THREE.Vector3());
  const r  = rp.distanceTo(rs);
  const mu = planet.mass / (sun.mass + planet.mass);

  // L1, L2 근사 거리: r * (mu/3)^(1/3)
  const d  = r * Math.pow(mu / 3, 1 / 3);
  const d1 = d;
  const d2 = d;

  const dir = new THREE.Vector3().subVectors(rs, rp).normalize();

  const pL1 = rp.clone().addScaledVector(dir, d1);
  const pL2 = rp.clone().addScaledVector(dir, -d2);

  // L4, L5: 행성 궤도에서 ±60°
  const up    = new THREE.Vector3(0, 1, 0);
  const toSun = new THREE.Vector3().subVectors(rp, rs).normalize();
  const ort   = new THREE.Vector3().crossVectors(up, toSun).normalize();

  const pL4 = rp
    .clone()
    .addScaledVector(toSun, Math.cos(Math.PI / 3) * r)
    .addScaledVector(ort,  Math.sin(Math.PI / 3) * r);

  const pL5 = rp
    .clone()
    .addScaledVector(toSun, Math.cos(Math.PI / 3) * r)
    .addScaledVector(ort, -Math.sin(Math.PI / 3) * r);

  const points = [pL1, pL2, pL4, pL5];

  for (const pt of points) {
    const geo = new THREE.SphereGeometry(0.18, 8, 8);
    const mat = new THREE.MeshBasicMaterial({
      color: 0x66ffcc,
      transparent: true,
      opacity: 0.9,
    });
    const s = new THREE.Mesh(geo, mat);
    s.position.copy(pt);
    s.userData.parent = planet;
    scene.add(s);
    lagrangeHelpers.push(s);
  }
}

/* -------------------------------------------------
 * UI 바인딩 (속도, 중심점, 토글)
 * ------------------------------------------------- */
const speed    = document.getElementById('speed');
const speedNum = document.getElementById('speedNum');

function setRate(v) {
  const n = parseFloat(v);
  timeScale = Math.max(0, isNaN(n) ? 0 : n);
  speed.value    = String(timeScale);
  speedNum.value = String(timeScale);
}

// 슬라이더
speed.addEventListener('input', (e) => {
  setRate(e.target.value);
});

// 텍스트 입력 (0.1, 0.05 등)
speedNum.addEventListener('input', () => {
  setRate(speedNum.value);
});

// 1×, 10×, 100× 버튼
document.querySelectorAll('.btn[data-rate]').forEach((btn) => {
  btn.addEventListener('click', () => {
    setRate(btn.dataset.rate);
  });
});

// 중심점
const focusSel = document.getElementById('focusSel');

function applyFocus() {
  const v = focusSel.value;
  if (v === '자유(수동)') {
    focusTarget = null;
  } else {
    focusTarget = (bodies[v] ? bodies[v].pivot : null) || bodies['태양'].pivot;
  }
  updateCam();
}
focusSel.addEventListener('change', applyFocus);

// 자전축 토글
const axisToggle = document.getElementById('axisToggle');
axisToggle.addEventListener('change', () => {
  axisList.forEach((a) => (a.visible = axisToggle.checked));
});
axisList.forEach((a) => (a.visible = true));

// 중력장 토글
const gravToggle = document.getElementById('gravToggle');
let showGravityField = false;
let gravHelpers = [];

gravToggle.addEventListener('change', () => {
  showGravityField = gravToggle.checked;
  updateGravityHelpers();
});

function updateGravityHelpers() {
  gravHelpers.forEach((h) => scene.remove(h));
  gravHelpers.length = 0;
  if (!showGravityField) return;

  for (const b of heavyBodies) {
    const center = b.pivot.getWorldPosition(new THREE.Vector3());
    const baseR  = b.mesh.geometry.parameters.radius || 1;
    const rVals  = [2, 4, 8, 12].map((x) => x * baseR);

    for (const r of rVals) {
      const geo = new THREE.RingGeometry(r - 0.06, r + 0.06, 64);
      geo.rotateX(-Math.PI / 2);
      const mat = new THREE.MeshBasicMaterial({
        color: 0x66ccff,
        transparent: true,
        opacity: 0.06,
        side: THREE.DoubleSide,
      });
      const ring = new THREE.Mesh(geo, mat);
      ring.position.copy(center);
      gravHelpers.push(ring);
      scene.add(ring);
    }

    // 라그랑주 포인트
    updateLagrangeFor(b);
  }
}

/* -------------------------------------------------
 * 마우스 카메라 컨트롤
 * ------------------------------------------------- */
let dragging = false;
let px = 0;
let py = 0;
let button = 0;

app.addEventListener('mousedown', (e) => {
  dragging = true;
  px = e.clientX;
  py = e.clientY;
  button = e.button;
});
window.addEventListener('mouseup', () => {
  dragging = false;
});
app.addEventListener('contextmenu', (e) => e.preventDefault());

window.addEventListener('mousemove', (e) => {
  if (!dragging) return;

  const dx = e.clientX - px;
  const dy = e.clientY - py;

  if (button === 0) {
    // 회전
    theta -= dx * 0.005;
    phi   -= dy * 0.005;
    const eps = 0.001;
    phi = Math.max(eps, Math.min(Math.PI - eps, phi));
  } else if (button === 2) {
    // 팬 (자유 모드에서만)
    if (!focusTarget) {
      const s = radius * 0.0012;
      camera.updateMatrixWorld();
      const fwd   = new THREE.Vector3();
      camera.getWorldDirection(fwd);
      const right = fwd.clone().cross(camera.up).normalize();
      const up    = camera.up.clone().normalize();

      manualTarget.addScaledVector(right, -dx * s);
      manualTarget.addScaledVector(up,    dy * s);
    }
  }

  px = e.clientX;
  py = e.clientY;
  updateCam();
});

// 줌
app.addEventListener('wheel', (e) => {
  e.preventDefault();
  radius *= 1 + Math.sign(e.deltaY) * 0.08;
  radius  = Math.max(30, Math.min(5000, radius));
  updateCam();
}, { passive: false });

/* -------------------------------------------------
 * 버튼 액션 (우주선/소행성)
 * ------------------------------------------------- */
document.getElementById('spawnShip').addEventListener('click', () => {
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);

  const pos = camera.position.clone().add(dir.clone().multiplyScalar(12));
  const vel = dir.clone().multiplyScalar(0.06);

  spawnSpaceship(pos, vel);
});

document.getElementById('delShip').addEventListener('click', () => {
  for (let i = dynamicObjects.length - 1; i >= 0; i--) {
    if (dynamicObjects[i].type === 'ship') {
      scene.remove(dynamicObjects[i].mesh);
      dynamicObjects.splice(i, 1);
    }
  }
});

document.getElementById('spawnAst').addEventListener('click', () => {
  const dir = new THREE.Vector3();
  camera.getWorldDirection(dir);

  const pos = camera.position.clone().add(dir.clone().multiplyScalar(12));
  const vel = dir.clone().multiplyScalar(
    Math.random() * 0.04 + 0.02
  );

  spawnAsteroid(pos, vel);
});

document.getElementById('clearObjs').addEventListener('click', () => {
  dynamicObjects.forEach((o) => scene.remove(o.mesh));
  dynamicObjects.length = 0;
});

/* -------------------------------------------------
 * 케플러 방정식 풀이 (E)
 * ------------------------------------------------- */
function solveKepler(M, e) {
  let E = M;
  for (let i = 0; i < 12; i++) {
    const f  = E - e * Math.sin(E) - M;
    const fp = 1 - e * Math.cos(E);
    E -= f / fp;
  }
  return E;
}

/* -------------------------------------------------
 * 애니메이션 루프
 * ------------------------------------------------- */
let last = performance.now();

function tick(now) {
  const dtReal = (now - last) / 1000;  // 실제 초
  last = now;

  // 천체(행성/위성)용 시간 (일 단위)
  const dtDays = dtReal * timeScale;
  simDate = new Date(
    simDate.getTime() + dtDays * 24 * 3600 * 1000
  );
  document.getElementById('startTime').textContent =
    simDate.toISOString().replace('T', ' ').slice(0, 19);

  // 동적 객체(우주선/소행성)용 시간 스케일
  const physScale = Math.max(0, Math.min(timeScale, 100));
  const dtPhys    = dtReal * physScale;

  // 태양 자전
  const sunBody = bodies['태양'];
  if (sunBody) {
    sunBody.spin.rotation.y +=
      dtDays * (2 * Math.PI / defs[0].rotH);
  }

  // 행성 공전/자전 + 위성 공전
  for (const ps of planetStates) {
    const def  = ps.def;
    const node = ps.node;

    // 공전 (케플러 타원 궤도)
    if (node.orbitPeriodDays > 0) {
      const n = (2 * Math.PI) / node.orbitPeriodDays;
      node.meanAnomaly =
        (node.meanAnomaly + n * dtDays) % (2 * Math.PI);

      const M = node.meanAnomaly;
      const e = node.ecc || 0;
      const E = solveKepler(M, e);

      const a = node.semiMajor;
      const b = a * Math.sqrt(Math.max(0, 1 - e * e));

      const x = a * (Math.cos(E) - e);
      const y = b * Math.sin(E);

      node.pivot.position.set(x, 0, -y);
    }

    // 자전 (항상 spin의 로컬 Y축 기준)
    const rotDays = Math.abs(node.rotPeriodHours) / 24;
    const rotSgn  = node.rotPeriodHours >= 0 ? 1 : -1;

    if (rotDays > 0) {
      node.spin.rotation.y +=
        rotSgn * dtDays * (2 * Math.PI / rotDays);
    }

    // 위성 공전 (간단한 원형 궤도)
    if (ps.moons && ps.moons.length > 0) {
      for (const m of ps.moons) {
        if (m.orbitPeriodDays <= 0) continue;

        const nm = (2 * Math.PI) / m.orbitPeriodDays;
        m.orbitalAngle =
          (m.orbitalAngle + nm * dtDays) % (2 * Math.PI);

        const ca = Math.cos(m.orbitalAngle);
        const sa = Math.sin(m.orbitalAngle);

        m.pivot.position.set(
          ca * m.orbitDist,
          0,
          -sa * m.orbitDist
        );
      }
    }
  }

  // 중력장/라그랑주 포인트 업데이트
  if (showGravityField) updateGravityHelpers();

  // 동적 객체 물리 (velocity verlet)
  if (dtPhys > 0 && dynamicObjects.length > 0) {
    for (let i = dynamicObjects.length - 1; i >= 0; i--) {
      const o  = dynamicObjects[i];
      const a0 = computeGravitationalAcceleration(o.pos);

      // 위치 업데이트
      o.pos
        .addScaledVector(o.vel, dtPhys)
        .addScaledVector(a0, 0.5 * dtPhys * dtPhys);

      const a1 = computeGravitationalAcceleration(o.pos);

      // 속도 업데이트
      o.vel.addScaledVector(
        a0.add(a1).multiplyScalar(0.5),
        dtPhys
      );

      o.mesh.position.copy(o.pos);

      // 충돌 검사
      for (const hb of heavyBodies) {
        const hp = hb.pivot.getWorldPosition(
          new THREE.Vector3()
        );
        const dist = hp.distanceTo(o.pos);
        const rBody =
          hb.mesh.geometry.parameters.radius ||
          hb.mesh.geometry.parameters.width ||
          1;

        if (dist < rBody * 1.1 + (o.radius || 0.5)) {
          explodeAt(o.pos);
          scene.remove(o.mesh);
          dynamicObjects.splice(i, 1);
          break;
        }
      }
    }
  }

  updateCam();
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* -------------------------------------------------
 * 리사이즈 대응 & 초기 UI 설정
 * ------------------------------------------------- */
window.addEventListener('resize', () => {
  const w = app.clientWidth;
  const h = app.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
});

// 초기 UI 세팅
document.getElementById('speed').value    = String(timeScale);
document.getElementById('speedNum').value = String(timeScale);
focusSel.value = '태양';
applyFocus();
radius = 200;
updateCam();
</script>
</body>
</html>
