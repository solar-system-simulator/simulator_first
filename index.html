<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>3D Solar System (Realistic Tilt, Rotation, Saturn Ring, Earth-Moon)</title>
<style>
  html, body { margin:0; padding:0; overflow:hidden; background:black; }
  canvas { display:block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>

<script>
// ======================================================
// Planetary data with realistic parameters
// ======================================================
const planetData = [
  { name:'Mercury', color:0xb4b4b4, radius:0.38, a:0.387, v:47.87, e:0.2056, i:7.0, Ω:48.3, rotH:1407.6, tilt:0.03 },
  { name:'Venus',  color:0xd8b47d, radius:0.95, a:0.723, v:35.02, e:0.0068, i:3.39, Ω:76.7, rotH:-5832.5, tilt:177.36 },
  { name:'Earth',  color:0x5fa8ff, radius:1.00, a:1.000, v:29.78, e:0.0167, i:0.00, Ω:-11.26, rotH:23.934, tilt:23.44 },
  { name:'Mars',   color:0xff6b6b, radius:0.53, a:1.524, v:24.07, e:0.0934, i:1.85, Ω:49.6, rotH:24.623, tilt:25.19 },
  { name:'Jupiter',color:0xc89f68, radius:11.21, a:5.203, v:13.07, e:0.0489, i:1.30, Ω:100.6, rotH:9.925, tilt:3.13 },
  { name:'Saturn', color:0xd8cfae, radius:9.45, a:9.537, v:9.69,  e:0.0565, i:2.49, Ω:113.7, rotH:10.656, tilt:26.73, ring:true },
  { name:'Uranus', color:0x9bd7ff, radius:4.01, a:19.191, v:6.81, e:0.0457, i:0.77, Ω:74.0, rotH:-17.24, tilt:97.77 },
  { name:'Neptune',color:0x6aa7ff, radius:3.88, a:30.068, v:5.43, e:0.0113, i:1.77, Ω:131.8, rotH:16.11, tilt:28.32 }
];

// ======================================================
// Scene setup
// ======================================================
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 6000);
camera.position.set(0, 300, 600);
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// Lighting
scene.add(new THREE.PointLight(0xffffff, 2, 0));
scene.add(new THREE.AmbientLight(0x222222));

// ======================================================
// Sun
// ======================================================
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(8, 48, 48),
  new THREE.MeshBasicMaterial({ color:0xffcc33 })
);
scene.add(sun);

// ======================================================
// Constants
// ======================================================
const AU_SCALE = 60;           // 1 AU visual scale
const EARTH_VELOCITY = 29.78;  // km/s
const TIME_SCALE = 0.0004;     // simulation speed

// ======================================================
// Planet creation
// ======================================================
const planets = [];

planetData.forEach(def => {
  const planetGroup = new THREE.Group();

  // Planet sphere
  const planetMesh = new THREE.Mesh(
    new THREE.SphereGeometry(Math.cbrt(def.radius)*0.6, 32, 32),
    new THREE.MeshPhongMaterial({ color:def.color })
  );
  planetMesh.rotation.z = THREE.MathUtils.degToRad(def.tilt); // axial tilt

  // Saturn ring
  if (def.ring) {
    const ringGeom = new THREE.RingGeometry(planetMesh.geometry.parameters.radius*1.4, planetMesh.geometry.parameters.radius*2.4, 64);
    const ringMat = new THREE.MeshBasicMaterial({
      color:0xd8cfae,
      side:THREE.DoubleSide,
      transparent:true,
      opacity:0.6
    });
    const ring = new THREE.Mesh(ringGeom, ringMat);
    ring.rotation.x = THREE.MathUtils.degToRad(90 - def.tilt);
    planetMesh.add(ring);
  }

  // Orbit path (ellipse)
  const orbitLine = createOrbitPath(def);
  planetGroup.add(orbitLine);
  planetGroup.add(planetMesh);
  scene.add(planetGroup);

  // Orbit plane rotation
  const i = THREE.MathUtils.degToRad(def.i);
  const Ω = THREE.MathUtils.degToRad(def.Ω);
  planetGroup.rotation.set(0, Ω, 0);
  orbitLine.rotation.x = i;

  planets.push({
    def,
    group:planetGroup,
    mesh:planetMesh,
    angle:Math.random()*Math.PI*2,
    rotationSpeed:360/def.rotH // degrees/hour
  });
});

// ======================================================
// Earth-Moon system
// ======================================================
const earth = planets.find(p=>p.def.name==='Earth');
const moonGroup = new THREE.Group();
const moonOrbitRadius = 0.00257 * AU_SCALE; // 384,400 km in AU
const moon = new THREE.Mesh(
  new THREE.SphereGeometry(0.17, 16, 16),
  new THREE.MeshPhongMaterial({ color:0xcfd6ff })
);
moonGroup.add(moon);
earth.mesh.add(moonGroup);
moonGroup.rotation.x = THREE.MathUtils.degToRad(5.145); // Moon orbit inclination

// ======================================================
// Orbit path generator
// ======================================================
function createOrbitPath(def){
  const e = def.e;
  const a = def.a * AU_SCALE;
  const b = a * Math.sqrt(1 - e*e);
  const points = [];
  for(let θ=0; θ<=Math.PI*2; θ+=Math.PI/256){
    const x = a*(Math.cos(θ)-e);
    const z = b*Math.sin(θ);
    points.push(new THREE.Vector3(x, 0, z));
  }
  const geom = new THREE.BufferGeometry().setFromPoints(points);
  const mat = new THREE.LineBasicMaterial({ color:0x888888, transparent:true, opacity:0.5 });
  return new THREE.LineLoop(geom, mat);
}

// ======================================================
// Animation loop
// ======================================================
let moonAngle = 0;
function animate(){
  requestAnimationFrame(animate);

  planets.forEach(p=>{
    const def = p.def;
    const e = def.e;
    const a = def.a * AU_SCALE;
    const b = a * Math.sqrt(1 - e*e);
    const vRatio = def.v / EARTH_VELOCITY;

    // 공전
    p.angle += TIME_SCALE * vRatio * 500;
    const θ = p.angle;
    const x = a*(Math.cos(θ)-e);
    const z = b*Math.sin(θ);
    p.mesh.position.set(x, 0, z);

    // 자전
    p.mesh.rotation.y += TIME_SCALE * (360/def.rotH);
  });

  // 달 공전
  moonAngle += TIME_SCALE * 200;
  moon.position.set(Math.cos(moonAngle)*moonOrbitRadius, 0, Math.sin(moonAngle)*moonOrbitRadius);

  renderer.render(scene, camera);
}
animate();

// ======================================================
// Resize
// ======================================================
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>








