<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>3D íƒœì–‘ê³„ â€” ì‹¤ì‚¬ ê¶¤ë„ë©´ í¬í•¨ (ëª…ì™•ì„±ê¹Œì§€)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#061024;color:#e9f2ff;font:12px/1.4 system-ui}
  #app{position:fixed; inset:0}
  canvas{display:block; width:100%; height:100%}
  .ui{
    position:fixed; left:12px; top:12px; background:rgba(255,255,255,.04);
    border:1px solid rgba(255,255,255,.06); padding:8px 10px; border-radius:10px;
    display:flex; gap:10px; flex-wrap:wrap; align-items:center; max-width:96vw; z-index:20;
  }
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .btn{cursor:pointer; padding:4px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.02)}
  .btn:hover{background:rgba(255,255,255,.04)}
  input[type="range"]{width:200px}
  select,input[type="number"]{background:transparent; color:#e9f2ff; border:1px solid rgba(255,255,255,.06); border-radius:6px; padding:4px}
  .hint{opacity:.7;font-size:12px;color:#bcd}
</style>
</head>
<body>
<div id="app"></div>
<div class="ui">
  <div class="row">
    <label for="speed">ì†ë„</label>
    <input id="speed" type="range" min="0" max="8" step="0.1" value="2">
    <input id="speedNum" type="number" min="0" max="8" step="0.1" value="2" style="width:60px">
    <button class="btn" data-rate="1">1Ã—</button>
    <button class="btn" data-rate="2">2Ã—</button>
    <button class="btn" data-rate="3">3Ã—</button>
  </div>

  <div class="row">
    <label for="focusSel">ì¤‘ì‹¬ì </label>
    <select id="focusSel">
      <option>ììœ (ìˆ˜ë™)</option>
      <option>íƒœì–‘</option>
      <option selected>ì§€êµ¬</option>
      <option>ìˆ˜ì„±</option><option>ê¸ˆì„±</option><option>ë‹¬</option><option>í™”ì„±</option>
      <option>ëª©ì„±</option><option>í† ì„±</option><option>ì²œì™•ì„±</option><option>í•´ì™•ì„±</option><option>ëª…ì™•ì„±</option>
    </select>
    <label><input id="axisToggle" type="checkbox" checked> ìì „ì¶• í‘œì‹œ</label>
    <span class="hint">â€¢ ì¢Œí´ë¦­: íšŒì „ Â· íœ : ì¤Œ Â· ìš°í´ë¦­: íŒ¬(ììœ  ëª¨ë“œ)</span>
  </div>

  <div class="row">
    <button class="btn" id="spawnAsteroidBtn">â˜„ï¸ ì†Œí–‰ì„± ì†Œí™˜ (ì•)</button>
    <button class="btn" id="spawnShipBtn">ğŸš€ ìš°ì£¼ì„  ì†Œí™˜ (ì•)</button>
    <button class="btn" id="clearShipsBtn">ğŸ—‘ï¸ ìš°ì£¼ì„  ì‚­ì œ</button>
    <label style="margin-left:8px"><input id="showGravity" type="checkbox" checked> ì¤‘ë ¥ê¶Œ ì‹œê°í™”</label>
  </div>
</div>

<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
<script>
const app = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(app.clientWidth, app.clientHeight);
renderer.setClearColor(0x061024, 1);
app.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, app.clientWidth/app.clientHeight, 0.1, 20000);

// orbit camera (manual)
let radius = 220, phi = THREE.MathUtils.degToRad(25), theta = THREE.MathUtils.degToRad(30);
const manualTarget = new THREE.Vector3(0,0,0);
let focusTarget = null;
function getTarget(){ return focusTarget ? focusTarget.getWorldPosition(new THREE.Vector3()) : manualTarget; }
function updateCam(){
  const t = getTarget();
  const x = t.x + radius * Math.sin(phi) * Math.cos(theta);
  const y = t.y + radius * Math.cos(phi);
  const z = t.z + radius * Math.sin(phi) * Math.sin(theta);
  camera.position.set(x,y,z);
  camera.lookAt(t);
}
updateCam();

// lights
scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const sunLight = new THREE.PointLight(0xffffff, 2.6, 0, 2);
scene.add(sunLight);

// helpers
function axisMesh(len, thick=0.06){
  const g = new THREE.CylinderGeometry(thick, thick, len, 12);
  const m = new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.7, depthWrite:false });
  const cyl = new THREE.Mesh(g, m);
  cyl.position.y = 0;
  return cyl;
}

// containers
const bodies = {};
const axisList = [];

// scale/time
const SIZE = 1.0;
let timeScale = 2; // day/sec

// Sun
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(10*SIZE, 64, 64),
  new THREE.MeshBasicMaterial({ color: 0xffd97a })
);
scene.add(sun);
sunLight.position.copy(sun.position);

// createBody
function createBodySimple({ name, size=1, color=0xffffff, axialTiltDeg=0 } = {}) {
  const group = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.7 });
  const sphere = new THREE.Mesh(new THREE.SphereGeometry(size*SIZE, 32,32), mat);
  group.add(sphere);
  const ax = axisMesh(size*SIZE*3.0, Math.max(0.03, size*SIZE*0.06));
  group.add(ax); axisList.push(ax);
  return { name, group, sphere, axis: ax, size };
}

// createOrbitPlane: ì‹¤ì‚¬ ê¶¤ë„ë©´
function createOrbitPlane(def){
  const e = def.e || 0;
  const a = def.a;
  const b = a * Math.sqrt(1 - e*e);
  const segments = 128;
  const points = [];
  for (let i=0;i<=segments;i++){
    const theta = (i/segments)*2*Math.PI;
    const x = a*Math.cos(theta) - e*a;
    const z = b*Math.sin(theta);
    points.push(new THREE.Vector3(x,0,z));
  }
  const shape = new THREE.Shape(points.map(p=>new THREE.Vector2(p.x,p.z)));
  const geometry = new THREE.ShapeGeometry(shape);
  const material = new THREE.MeshBasicMaterial({ color:def.color, transparent:true, opacity:0.08, side:THREE.DoubleSide });
  const mesh = new THREE.Mesh(geometry, material);
  const iRad = THREE.MathUtils.degToRad(def.i||0);
  mesh.rotation.x = iRad;
  scene.add(mesh);
  return mesh;
}

// í–‰ì„± ì •ì˜ (ëª…ì™•ì„± í¬í•¨)
const planetDefs = [
  { name:'ìˆ˜ì„±', color:0xb4b4b4, size:0.9, a:16, orbit:87.969, rotH:1407.6, tilt:0.03, e:0.2056, i:7.0 },
  { name:'ê¸ˆì„±', color:0xd8b47d, size:1.1, a:22, orbit:224.701, rotH:-5832.5, tilt:177.36, e:0.0068, i:3.4 },
  { name:'ì§€êµ¬', color:0x5fa8ff, size:1.2, a:30, orbit:365.256, rotH:23.934, tilt:23.44, e:0.0167, i:0.0,
    moons:[{ name:'ë‹¬', color:0xcfd6ff, size:0.35, a:4.0, orbit:27.322, rotH:655.7, tilt:6.68 }] },
  { name:'í™”ì„±', color:0xff6b6b, size:0.9, a:38, orbit:686.980, rotH:24.623, tilt:25.19, e:0.0934, i:1.85,
    moons:[ { name:'í¬ë³´ìŠ¤', color:0xaaaaaa, size:0.12, a:2.5, orbit:0.3189, rotH:7.65, tilt:0 },
            { name:'ë°ì´ëª¨ìŠ¤', color:0xcccccc, size:0.08, a:3.2, orbit:1.263, rotH:30.3, tilt:0 } ] },
  { name:'ëª©ì„±', color:0xc89f68, size:4.0, a:60, orbit:4332.589, rotH:9.925, tilt:3.13, e:0.0489, i:1.3,
    moons:[ { name:'ì´ì˜¤', color:0xe6d27c, size:0.25, a:6.0, orbit:1.769, rotH:42.46, tilt:0 },
            { name:'ìœ ë¡œíŒŒ', color:0xdddddd, size:0.22, a:7.5, orbit:3.551, rotH:85.2, tilt:0.1 } ] },
  { name:'í† ì„±', color:0xd8cfae, size:3.6, a:78, orbit:10759.22, rotH:10.656, tilt:26.73, e:0.0565, i:2.48, ring:true,
    moons:[{ name:'íƒ€ì´íƒ„', color:0xcab47a, size:0.28, a:8.0, orbit:15.945, rotH:382.7, tilt:0.3 }] },
  { name:'ì²œì™•ì„±', color:0x9bd7ff, size:2.9, a:96, orbit:30688.5, rotH:-17.24, tilt:97.77, e:0.0457, i:0.77,
    moons:[{ name:'í‹°íƒ€ë‹ˆì•„', color:0xcccccc, size:0.18, a:6.0, orbit:8.706, rotH:208.9, tilt:0 }] },
  { name:'í•´ì™•ì„±', color:0x6aa7ff, size:2.8, a:112, orbit:60182.0, rotH:16.11, tilt:28.32, e:0.0113, i:1.77,
    moons:[{ name:'íŠ¸ë¦¬í†¤', color:0xcfd6ff, size:0.22, a:6.5, orbit:5.877, rotH:141.0, tilt:0, retrogradeOrbit:true }] },
  { name:'ëª…ì™•ì„±', color:0x9999cc, size:0.6, a:140, orbit:90560, rotH:-153.3, tilt:122.5, e:0.2488, i:17.16 }
];

// planetStates ìƒì„±
const planetStates = [];
for(const def of planetDefs){
  const b = def.a * Math.sqrt(1-(def.e||0)*(def.e||0));
  const body = createBodySimple({ name:def.name, size:def.size, color:def.color, axialTiltDeg:def.tilt });
  scene.add(body.group);

  // ê¶¤ë„ë©´
  createOrbitPlane(def);

  // í† ì„± ë§
  if(def.ring){
    const ringGeom = new THREE.RingGeometry((def.size*SIZE)*2.0,(def.size*SIZE)*2.8,128);
    ringGeom.rotateX(-Math.PI/2);
    const ringMat = new THREE.MeshStandardMaterial({ color:0xd8cfae, roughness:0.9, metalness:0, transparent:true, opacity:0.7, side:THREE.DoubleSide });
    const ring = new THREE.Mesh(ringGeom, ringMat);
    body.group.add(ring);
  }

  // moons
  const moons=[];
  if(def.moons){
    for(const m of def.moons){
      const mBody = createBodySimple({ name:m.name, size:m.size, color:m.color, axialTiltDeg:m.tilt });
      body.group.add(mBody.group);
      moons.push({ def:m, node:mBody, orbitAngle:0 });
    }
  }

  const MASS_RATIO = { 'ìˆ˜ì„±':0.055,'ê¸ˆì„±':0.815,'ì§€êµ¬':1.0,'í™”ì„±':0.107,'ëª©ì„±':317.8,'í† ì„±':95.2,'ì²œì™•ì„±':14.5,'í•´ì™•ì„±':17.1,'ëª…ì™•ì„±':0.0022 };
  const massRatio = MASS_RATIO[def.name] || 0.2;
  const MAX_MASS = 317.8;
  const gravityRadius = Math.max(20, def.a*0.25 + (massRatio/MAX_MASS)*def.a*2.0);

  planetStates.push({
    def, node:body, moons, a:def.a, b:b, e:def.e||0,
    orbitAngle:Math.random()*Math.PI*2, rotPeriodHours:def.rotH,
    gravityRadius, massRatio, _gravRing:null, _destroyed:false
  });

  bodies[def.name] = body.group;
}

// === UI, mouse, entities, tick ë“±ì€ ê¸°ì¡´ ì½”ë“œ ê·¸ëŒ€ë¡œ ì‚¬ìš© ===
// ê¸°ì¡´ tick(), updateEntities(), spawnShipAt(), spawnAsteroidAt(), UI ë°”ì¸ë”© ëª¨ë‘ ê·¸ëŒ€ë¡œ ìœ ì§€

</script>
</body>
</html>

