<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>태양계 + PETS / SAC RL</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #051022;
      color: #e9ecff;
      font: 13px/1.45 system-ui;
      overflow: hidden;
    }
    #app {
      position: fixed;
      inset: 0;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    .ui {
      position: fixed;
      left: 12px;
      top: 12px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
      padding: 10px;
      border-radius: 10px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      max-width: 96vw;
      z-index: 10;
    }
    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .btn {
      cursor: pointer;
      padding: 6px 9px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      color: #e9ecff;
    }
    input[type=range] { width: 200px; }
    input[type=number],
    input[type=text] { width: 70px; }
    select {
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,.2);
      background: rgba(0,0,0,.3);
      color: #e9ecff;
      font-size: 12px;
    }
    .small {
      font-size: 11px;
      opacity: .85;
    }
    .hud {
      position: fixed;
      right: 10px;
      top: 10px;
      padding: 8px 10px;
      background: rgba(0,0,0,.45);
      border-radius: 8px;
      font-family: monospace;
      font-size: 11px;
      max-width: 260px;
      line-height: 1.3;
      z-index: 10;
    }
    /* 결과 모달 오버레이 */
    #resultOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    #resultModal {
      background: #0b1220;
      border: 1px solid rgba(255,255,255,.3);
      border-radius: 14px;
      padding: 20px 36px;
      box-shadow: 0 18px 40px rgba(0,0,0,.7);
      text-align: center;
      min-width: 260px;
    }
    #resultModal h2 {
      margin: 0 0 6px;
      font-size: 20px;
    }
    #resultModal .percent {
      font-size: 32px;
      font-weight: bold;
      margin: 4px 0 12px;
      color: #ffe066;
    }
    #sideLog {
      position: fixed;
      right: 10px;
      bottom: 10px;
      padding: 8px 10px;
      background: rgba(0,0,0,.4);
      border-radius: 8px;
      font-size: 11px;
      max-width: 260px;
      max-height: 30vh;
      overflow-y: auto;
      z-index: 10;
    }
    #sideLog h3 {
      margin: 0 0 4px;
      font-size: 12px;
      opacity: .9;
    }
  </style>
</head>
<body>
<div id="app"></div>

<!-- UI 패널 -->
<div class="ui">
  <div class="row">
    <label for="speed">속도 (일/초)</label>
    <input id="speed" type="range" min="0" max="500" step="0.1" value="0.3" />
    <input id="speedNum" type="text" value="0.3" />
    <button class="btn" data-rate="1">1×</button>
    <button class="btn" data-rate="10">10×</button>
    <button class="btn" data-rate="100">100×</button>
  </div>

  <div class="row">
    <label for="focusSel">중심점</label>
    <select id="focusSel">
      <option>자유(수동)</option>
      <option selected>태양</option>
      <option>수성</option>
      <option>금성</option>
      <option>지구</option>
      <option>달</option>
      <option>화성</option>
      <option>목성</option>
      <option>토성</option>
      <option>천왕성</option>
      <option>해왕성</option>
      <option>명왕성</option>
    </select>
    <label>
      <input id="axisToggle" type="checkbox" checked />
      자전축 표시
    </label>
    <label>
      <input id="gravToggle" type="checkbox" />
      중력장 표시(행성 포함)
    </label>
  </div>

  <div class="row">
    <button class="btn" id="spawnShip">우주선 소환 (PETS/SAC 비교)</button>
    <button class="btn" id="spawnAst">소행성 군 소환</button>
    <button class="btn" id="clearObjs">모두 삭제</button>
  </div>

  <!-- RL 관련 UI -->
  <div class="row">
    <label for="autoTarget">RL 목표</label>
    <select id="autoTarget">
      <option>지구</option>
      <option>달</option>
      <option>화성</option>
      <option>목성</option>
      <option>토성</option>
      <option>천왕성</option>
      <option>해왕성</option>
      <option>명왕성</option>
      <option>태양</option>
      <option>수성</option>
      <option>금성</option>
    </select>
  </div>

  <div class="row small">
    <label><input id="petsEnable" type="checkbox" checked /> PETS</label>
    <label><input id="sacEnable" type="checkbox" checked /> SAC</label>
    <span>
      PETS F:<span id="petsFuel">-</span> R:<span id="petsRew">0</span> |
      SAC F:<span id="sacFuel">-</span> R:<span id="sacRew">0</span>
    </span>
  </div>

  <!-- PETS vs SAC 선택 버튼 -->
  <div class="row" id="choiceRow" style="display:none;">
    <button class="btn" id="choosePETS">PETS 사용</button>
    <button class="btn" id="chooseSAC">SAC 사용</button>
  </div>

  <div class="row small">
    <div>
      시작 시각:
      <span id="startTime">2025-01-01 00:00:00</span>
    </div>
    <div class="small">• 좌클릭: 회전 · 휠: 줌 · 우클릭: 팬</div>
  </div>
</div>

<div class="hud" id="hudBox">
  PETS / SAC 상태<br>
  --------------------------<br>
  초기화 중...
</div>

<!-- 결과 모달 -->
<div id="resultOverlay">
  <div id="resultModal">
    <h2>비행 결과</h2>
    <div id="resultLine"></div>
    <div class="percent" id="resultPercent">성공률 0%</div>
    <div style="font-size:12px; opacity:.8;">(모달 바깥을 클릭하면 닫히고 초기화)</div>
  </div>
</div>

<!-- 결과 로그 -->
<div id="sideLog">
  <h3>결과 로그</h3>
  <div id="logContent"></div>
</div>

<script src="./three.min.js"></script>
<script>
/* ========== 기본 Three.js 세팅 ========== */
const app = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(app.clientWidth, app.clientHeight);
renderer.setClearColor(0x051022, 1);
app.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  60,
  app.clientWidth / app.clientHeight,
  0.1,
  20000
);

// 카메라 궤도 파라미터
let radius = 260;
let phi    = THREE.MathUtils.degToRad(28);
let theta  = THREE.MathUtils.degToRad(40);

const manualTarget = new THREE.Vector3(0, 0, 0);
let focusTarget = null;

function getTarget() {
  return focusTarget
    ? focusTarget.getWorldPosition(new THREE.Vector3())
    : manualTarget;
}
function updateCam() {
  const t = getTarget();
  const x = t.x + radius * Math.sin(phi) * Math.cos(theta);
  const y = t.y + radius * Math.cos(phi);
  const z = t.z + radius * Math.sin(phi) * Math.sin(theta);
  camera.position.set(x, y, z);
  camera.lookAt(t);
}
updateCam();

/* ========== 시간 / 상수 ========== */
let simDate   = new Date('2025-01-01T00:00:00Z');
let timeScale = 0.3;
const G       = 5e-6;
const MAX_ACC = 0.3;

scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const sunLight = new THREE.PointLight(0xffffff, 2.2, 0, 2);
scene.add(sunLight);

const bodies          = {};
const heavyBodies     = [];
const axisList        = [];
const dynamicObjects  = [];
const lagrangeHelpers = [];
const thrustParticles = [];

const SIZE = 1;
const DIST = 1;

/* ========== 유틸 ========== */
function mkAxis(len) {
  const geo = new THREE.CylinderGeometry(0.04, 0.04, len, 8);
  const mat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.75,
  });
  const cyl = new THREE.Mesh(geo, mat);
  cyl.position.y = 0;
  return cyl;
}

/* ========== 천체 생성 ========== */
function createBody({
  name,
  parent          = scene,
  size            = 1,
  color           = 0xffffff,
  orbitDist       = 0,
  orbitPeriodDays = 0,
  rotPeriodHours  = 24,
  axialTiltDeg    = 0,
  ecc             = 0,
  orbitInc        = 0,
  massScale       = 1,
} = {}) {
  const pivot = new THREE.Group();
  parent.add(pivot);
  pivot.rotation.x = THREE.MathUtils.degToRad(orbitInc || 0);

  const spin = new THREE.Group();
  spin.rotation.z = THREE.MathUtils.degToRad(axialTiltDeg || 0);
  pivot.add(spin);

  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(size * SIZE, 32, 32),
    new THREE.MeshStandardMaterial({
      color,
      roughness: 0.85,
    })
  );
  spin.add(mesh);

  const axis = mkAxis(size * 3);
  spin.add(axis);
  axisList.push(axis);

  const mass = Math.max(1e-6, Math.pow(size, 3) * massScale);

  const body = {
    name,
    pivot,
    spin,
    mesh,
    orbitDist: orbitDist * DIST,
    orbitPeriodDays,
    rotPeriodHours,
    mass,
    ecc,
    orbitInc,
    meanAnomaly: Math.random() * Math.PI * 2,
    semiMajor: orbitDist * DIST,
  };

  bodies[name] = body;
  heavyBodies.push(body);
  return body;
}

/* ========== 행성 데이터 ========== */
const defs = [
  { name: '태양', size: 10,   dist: 0,   orbit: 0,       rotH: 25.38,           tilt: 7.25,  ecc: 0,          orbitInc: 0,    massScale: 1e6,   color: '#ffd54a' },
  { name: '수성', size: 0.9,  dist: 16,  orbit: 87.969,  rotH: 58.6462 * 24,    tilt: 0.01,  ecc: 0.205630,   orbitInc: 7.005, massScale: 0.055, color: '#555555' },
  { name: '금성', size: 1.1,  dist: 22,  orbit: 224.701, rotH: -243.0185 * 24,  tilt: 177.36, ecc: 0.006772, orbitInc: 3.394, massScale: 0.815, color: '#fff7c4' },
  { name: '지구', size: 1.2,  dist: 30,  orbit: 365.256, rotH: 0.99726963 * 24, tilt: 23.44, ecc: 0.01671123, orbitInc: 0.0,   massScale: 1,     color: '#3a82ff' },
  { name: '화성', size: 0.9,  dist: 38,  orbit: 686.98,  rotH: 1.02595676 * 24, tilt: 25.19, ecc: 0.0933941, orbitInc: 1.85,  massScale: 0.107, color: '#d14b3a' },
  { name: '목성', size: 4.0,  dist: 60,  orbit: 4332.59, rotH: 0.41354 * 24,    tilt: 3.13,  ecc: 0.04839266, orbitInc: 1.305, massScale: 318,   color: '#e6b56a' },
  { name: '토성', size: 3.6,  dist: 78,  orbit: 10756.2, rotH: 0.44401 * 24,    tilt: 26.73, ecc: 0.055723,   orbitInc: 2.485, massScale: 95,    color: '#d2b48c' },
  { name: '천왕성', size: 2.9, dist: 96,  orbit: 30707.49, rotH: -0.71833 * 24, tilt: 97.77, ecc: 0.04565, orbitInc: 0.77,  massScale: 14,    color: '#6ecff6' },
  { name: '해왕성', size: 2.8, dist: 112, orbit: 60223.35, rotH: 0.67125 * 24,  tilt: 28.32, ecc: 0.00859048, orbitInc: 1.769, massScale: 17,   color: '#264bff' },
  { name: '명왕성', size: 0.5, dist: 140, orbit: 90560,   rotH: -6.3872 * 24,   tilt: 122.53, ecc: 0.24883, orbitInc: 17.14, massScale: 0.0022, color: '#bbaea0' },
];

const planetStates = [];
for (const p of defs) {
  const body = createBody({
    name: p.name,
    size: p.size,
    orbitDist: p.dist,
    orbitPeriodDays: p.orbit,
    rotPeriodHours: p.rotH,
    axialTiltDeg: p.tilt,
    ecc: p.ecc,
    orbitInc: p.orbitInc,
    massScale: p.massScale,
    color: p.color,
  });
  planetStates.push({ def: p, node: body, moons: [] });
}

/* ========== 궤도 타원 ========== */
function createOrbitLine({a,e,iDeg,omegaDeg,OmegaDeg,color=0xffffff,opacity=0.25,segments=360}) {
  const pts = [];
  const iRad      = THREE.MathUtils.degToRad(iDeg || 0);
  const omegaRad  = THREE.MathUtils.degToRad(omegaDeg || 0);
  const OmegaRad  = THREE.MathUtils.degToRad(OmegaDeg || 0);
  for (let k = 0; k <= segments; k++) {
    const nu = (2 * Math.PI * k) / segments;
    const r = (a * (1 - e * e)) / (1 + e * Math.cos(nu));
    const v = new THREE.Vector3(r * Math.cos(nu),0,r * Math.sin(nu));
    v.applyAxisAngle(new THREE.Vector3(0, 1, 0), omegaRad);
    v.applyAxisAngle(new THREE.Vector3(1, 0, 0), iRad);
    v.applyAxisAngle(new THREE.Vector3(0, 1, 0), OmegaRad);
    pts.push(v);
  }
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const mat = new THREE.LineBasicMaterial({color,transparent:true,opacity});
  const line = new THREE.Line(geo, mat);
  scene.add(line);
  return line;
}

for (const ps of planetStates) {
  const node = ps.node;
  if (node.orbitPeriodDays <= 0) continue;
  const name = ps.def.name;
  let col = 0x444c66;
  if (name === '수성') col = 0xaaaaaa;
  else if (name === '금성') col = 0xffc966;
  else if (name === '지구') col = 0x3a82ff;
  else if (name === '화성') col = 0xff5533;
  else if (name === '목성') col = 0xe6b56a;
  else if (name === '토성') col = 0xd2b48c;
  else if (name === '천왕성') col = 0x6ecff6;
  else if (name === '해왕성') col = 0x264bff;
  else if (name === '명왕성') col = 0xbbaea0;
  createOrbitLine({
    a: node.semiMajor,
    e: node.ecc || 0,
    iDeg: node.orbitInc || 0,
    omegaDeg: 0,
    OmegaDeg: 0,
    color: col,
    opacity: 0.25,
    segments: 400,
  });
}

/* ========== 달/위성 + 토성 고리 (생략 설명) ========== */
// ... (원래 코드와 동일, 길이 줄이려고 요약 가능하지만 여기선 핵심만 유지)
(() => {
  const earth = bodies['지구'];
  if (!earth) return;
  const moon = createBody({
    name: '달',
    parent: earth.pivot,
    size: 0.35,
    orbitDist: 4,
    orbitPeriodDays: 27.322,
    rotPeriodHours: 655.7,
    axialTiltDeg: 6.68,
    massScale: 0.0123,
    color: '#cfd6ff'
  });
  planetStates.find(x=>x.def.name==='지구').moons.push({
    ...moon,
    orbitDist: 4,
    orbitPeriodDays: 27.322,
    orbitalAngle: Math.random() * Math.PI * 2,
  });
})();
// (나머지 위성들도 필요하면 그대로 추가, 생략)

/* ========== 중력 / 관측 ========== */
function computeGravitationalAcceleration(pos) {
  const acc = new THREE.Vector3();
  for (const b of heavyBodies) {
    const bp   = b.pivot.getWorldPosition(new THREE.Vector3());
    const rVec = new THREE.Vector3().subVectors(bp, pos);
    const r    = rVec.length();
    if (r === 0) continue;
    const baseR = b.mesh.geometry.parameters.radius || 1;
    let maxRangeMul = 16;
    let effMass     = b.mass;
    if (b.name === '태양') effMass *= 0.0002;
    const rMax = baseR * maxRangeMul;
    if (r > rMax) continue;
    const r2 = Math.max(100, r * r);
    let accMag = (G * effMass) / r2;
    if (accMag > MAX_ACC) accMag = MAX_ACC;
    acc.addScaledVector(rVec.normalize(), accMag);
  }
  return acc;
}
function computePotentialEnergy(pos, mass=1) {
  let pe = 0;
  for (const b of heavyBodies) {
    const bp = b.pivot.getWorldPosition(new THREE.Vector3());
    const r  = bp.distanceTo(pos);
    if (r>0) pe += -G * b.mass * mass / r;
  }
  return pe;
}
function computeCollisionRisk(pos) {
  let risk = 0;
  for (const b of heavyBodies) {
    const bp = b.pivot.getWorldPosition(new THREE.Vector3());
    const r  = bp.distanceTo(pos);
    const baseR = b.mesh.geometry.parameters.radius || 1;
    const safe = baseR * 5;
    if (r < safe) risk = Math.max(risk, (safe - r)/safe);
  }
  return Math.min(1,risk);
}
function getRLTargetPos() {
  const sel = document.getElementById('autoTarget').value;
  const b = bodies[sel];
  if (!b) return new THREE.Vector3(0,0,0);
  return b.pivot.getWorldPosition(new THREE.Vector3());
}
function getObservation(ship) {
  const targetPos = getRLTargetPos();
  const g = computeGravitationalAcceleration(ship.pos);
  const toTarget = new THREE.Vector3().subVectors(targetPos, ship.pos);
  const dist = toTarget.length();
  const vel = ship.vel.clone();
  const ke = 0.5 * ship.mass * vel.lengthSq();
  const pe = computePotentialEnergy(ship.pos, ship.mass);
  const totalE = ke + pe;
  const angMom = ship.pos.clone().cross(vel);
  const collisionRisk = computeCollisionRisk(ship.pos);
  return {pos: ship.pos.clone(), vel, grav: g, toTarget, dist, fuel: ship.fuel,
          kinetic: ke, potential: pe, totalE, angMom, collisionRisk};
}

/* ========== 소행성/우주선 ========== */
function getNearestShip(pos) {
  let best = null, bestDist = Infinity;
  for (const o of dynamicObjects) {
    if (o.type !== 'ship') continue;
    const d = o.pos.distanceTo(pos);
    if (d < bestDist) { bestDist=d; best=o; }
  }
  return best;
}

function spawnSpaceshipSimple(pos, vel, policyType, color) {
  const geo = new THREE.ConeGeometry(0.3, 0.8, 8);
  geo.rotateX(Math.PI / 2);
  const mat = new THREE.MeshStandardMaterial({ color });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(pos);
  scene.add(mesh);
  const ship = {
    type:'ship',
    mesh,
    pos: mesh.position.clone(),
    vel: vel.clone(),
    mass: 0.05,
    radius: 0.4,
    fuel: 1.0,
    maxThrust: 0.22,   // 출력 크게 ↑
    lastFuelUsed:0,
    prevGoalDist:null,
    totalReward:0,
    collided:false,
    policyType,
    alive:true
  };
  dynamicObjects.push(ship);
  return ship;
}

function spawnAsteroid(pos, vel) {
  const sBase = Math.random()*0.6+0.2;
  const s = sBase*0.5;
  const geo = new THREE.DodecahedronGeometry(s,0);
  const mat = new THREE.MeshStandardMaterial({color:0x999999});
  const mesh = new THREE.Mesh(geo,mat);
  mesh.position.copy(pos);
  scene.add(mesh);
  const obj = {
    type:'asteroid',
    mesh,
    pos: mesh.position.clone(),
    vel: vel.clone(),
    mass: Math.pow(s,3)*0.2,
    radius:s,
    alive:true
  };
  dynamicObjects.push(obj);
  return obj;
}
function spawnAsteroidSwarm(centerPos, ship) {
  const pos = centerPos.clone();
  let dirToShip = new THREE.Vector3(0,0,0);
  if (ship) {
    pos.y = ship.pos.y;
    dirToShip.subVectors(ship.pos,pos);
    if (dirToShip.lengthSq()>0) dirToShip.normalize();
  }
  const baseSpeed = ship ? 0.25 : 0.0;
  const baseVel = dirToShip.clone().multiplyScalar(baseSpeed);
  spawnAsteroid(pos,baseVel);
  const count = 6;
  for(let i=0;i<count;i++){
    const offset = new THREE.Vector3(
      (Math.random()-0.5)*4,0,(Math.random()-0.5)*4
    );
    const p = pos.clone().add(offset);
    let v = baseVel.clone();
    if (ship && baseSpeed>0){
      const randomDir = new THREE.Vector3(
        (Math.random()-0.5)*0.3,
        (Math.random()-0.5)*0.05,
        (Math.random()-0.5)*0.3
      );
      v.add(randomDir).multiplyScalar(0.8+Math.random()*0.6);
    }
    spawnAsteroid(p,v);
  }
}

/* 폭발 이펙트 */
function explodeAt(pos) {
  const group = new THREE.Group();
  for (let i=0;i<18;i++){
    const geo = new THREE.SphereGeometry(0.06,6,6);
    const mat = new THREE.MeshBasicMaterial({color:0xffaa44});
    const p = new THREE.Mesh(geo,mat);
    p.position.copy(pos);
    p.userData.v = new THREE.Vector3(
      (Math.random()-0.5)*2,
      (Math.random()-0.5)*2,
      (Math.random()-0.5)*2
    ).multiplyScalar(0.6);
    group.add(p);
  }
  scene.add(group);
  const t0 = performance.now();
  const id = setInterval(()=>{
    const dt=(performance.now()-t0)/1000;
    group.children.forEach(ch=>{
      ch.position.addScaledVector(ch.userData.v,0.04);
    });
    if(dt>1.5){
      clearInterval(id);
      scene.remove(group);
    }
  },50);
}

/* 추력 파티클 */
function spawnThrustParticle(ship,dir){
  const geo = new THREE.SphereGeometry(0.15,8,8);
  const mat = new THREE.MeshBasicMaterial({
    color: ship.policyType==="PETS"?0xffdd66:0x66c0ff,
    transparent:true,
    opacity:0.9
  });
  const p = new THREE.Mesh(geo,mat);
  const back = dir.clone().multiplyScalar(-1);
  p.position.copy(ship.pos).addScaledVector(back, ship.radius||0.8);
  p.userData.vel = back.multiplyScalar(0.6);
  p.userData.life=0.6;
  scene.add(p);
  thrustParticles.push(p);
}
function updateThrustParticles(dt){
  for(let i=thrustParticles.length-1;i>=0;i--){
    const p = thrustParticles[i];
    p.userData.life-=dt;
    p.position.addScaledVector(p.userData.vel,dt);
    p.material.opacity = Math.max(0,p.userData.life/0.6);
    if(p.userData.life<=0){
      scene.remove(p);
      thrustParticles.splice(i,1);
    }
  }
}

/* ========== RL 액션 적용 + PETS/SAC 정책 ========== */
function applyRLAction(ship, action, dt) {
  const dir = action.dir.clone().normalize();
  const thrustOn = !!action.thrustOn;
  const fuelRatio = Math.max(0,Math.min(1,action.fuelRatio ?? 0.5));
  ship.lastFuelUsed=0;
  if(thrustOn && ship.fuel>0){
    const thrustMag = ship.maxThrust*fuelRatio;
    ship.vel.addScaledVector(dir, thrustMag*dt);
    const fuelUsed = fuelRatio*dt*0.9;
    ship.fuel = Math.max(0, ship.fuel-fuelUsed);
    ship.lastFuelUsed = fuelUsed;
    spawnThrustParticle(ship,dir);
  }
}
function stepPETS(ship,dt){
  const obs = getObservation(ship);
  if (obs.dist<1 || ship.fuel<=0.01) return;
  const baseDir = obs.toTarget.clone().normalize();
  let bestScore=-Infinity, bestDir=baseDir.clone();
  const horizon=8, candCount=16;
  for(let i=0;i<candCount;i++){
    const jitter = new THREE.Vector3(
      (Math.random()-0.5)*0.4,
      (Math.random()-0.5)*0.2,
      (Math.random()-0.5)*0.4
    );
    const candDir = baseDir.clone().add(jitter).normalize();
    let pos = obs.pos.clone();
    let vel = obs.vel.clone();
    let score=0;
    for(let t=0;t<horizon;t++){
      const g = computeGravitationalAcceleration(pos);
      vel.addScaledVector(g,dt);
      vel.addScaledVector(candDir, ship.maxThrust*0.5*dt);
      pos.addScaledVector(vel,dt);
      const d = pos.distanceTo(getRLTargetPos());
      score-=d*0.02;
    }
    const risk = computeCollisionRisk(pos);
    score-=risk*3;
    if(score>bestScore){bestScore=score; bestDir.copy(candDir);}
  }
  applyRLAction(ship,{
    thrustOn: obs.dist>1 && ship.fuel>0.02,
    dir:bestDir,
    fuelRatio:0.7
  },dt);
  const progress = (ship.prevGoalDist ?? obs.dist)-obs.dist;
  ship.totalReward += progress*15 - ship.lastFuelUsed*20 - dt*0.4;
  ship.prevGoalDist = obs.dist;
  document.getElementById('petsFuel').textContent=(ship.fuel*100).toFixed(1);
  document.getElementById('petsRew').textContent=ship.totalReward.toFixed(1);
}
function stepSAC(ship,dt){
  const obs = getObservation(ship);
  if (obs.dist<1 || ship.fuel<=0.01) return;
  const toTargetDir = obs.toTarget.clone().normalize();
  const velDir = obs.vel.length()>1e-3 ? obs.vel.clone().normalize() : new THREE.Vector3();
  const gravDir= obs.grav.length()>1e-4 ? obs.grav.clone().normalize() : new THREE.Vector3();
  let baseDir = new THREE.Vector3()
    .addScaledVector(toTargetDir,1.0)
    .addScaledVector(velDir,-0.5)
    .addScaledVector(gravDir,-0.2);
  if(baseDir.length()<1e-3) baseDir = toTargetDir.clone();
  const noise = new THREE.Vector3(
    (Math.random()-0.5)*0.3,
    (Math.random()-0.5)*0.2,
    (Math.random()-0.5)*0.3
  );
  baseDir.add(noise.multiplyScalar(0.3)).normalize();
  applyRLAction(ship,{
    thrustOn: obs.dist>1 && ship.fuel>0.02,
    dir:baseDir,
    fuelRatio:0.5
  },dt);
  const progress = (ship.prevGoalDist ?? obs.dist)-obs.dist;
  ship.totalReward += progress*10 - ship.lastFuelUsed*10 - dt*0.3;
  ship.prevGoalDist = obs.dist;
  document.getElementById('sacFuel').textContent=(ship.fuel*100).toFixed(1);
  document.getElementById('sacRew').textContent=ship.totalReward.toFixed(1);
}

/* ========== PETS/SAC 예측 경로 계산 ========== */
function predictTrajectory(ship, policyType, steps=140, dt=0.7){
  const pts=[];
  let pos = ship.pos.clone();
  let vel = ship.vel.clone();
  let fuel = ship.fuel;
  for(let i=0;i<steps;i++){
    const targetPos = getRLTargetPos();
    const toTarget  = new THREE.Vector3().subVectors(targetPos,pos);
    const dist      = toTarget.length();
    if (dist<1) break;
    const g = computeGravitationalAcceleration(pos);
    let dir;
    if(policyType==="PETS"){
      const baseDir = toTarget.clone().normalize();
      const jitter = new THREE.Vector3(
        (Math.random()-0.5)*0.3,
        (Math.random()-0.5)*0.15,
        (Math.random()-0.5)*0.3
      );
      dir = baseDir.add(jitter).normalize();
    }else{
      const toDir = toTarget.clone().normalize();
      const velDir= vel.length()>1e-3?vel.clone().normalize():new THREE.Vector3();
      dir = new THREE.Vector3()
        .addScaledVector(toDir,1.0)
        .addScaledVector(velDir,-0.3)
        .addScaledVector(g.clone().normalize(),-0.1)
        .normalize();
    }
    if(fuel>0){
      const thrustMag = ship.maxThrust*(policyType==="PETS"?0.6:0.45);
      vel.addScaledVector(dir,thrustMag*dt);
      fuel-=0.003;
      if(fuel<0) fuel=0;
    }
    vel.addScaledVector(g,dt);
    pos.addScaledVector(vel,dt);
    pts.push(pos.clone());
  }
  return pts;
}
let petsPathLine=null, sacPathLine=null;
function showPredictedPath(ship, policyType){
  const pts = predictTrajectory(ship, policyType);
  const geo = new THREE.BufferGeometry().setFromPoints(pts);
  const color = policyType==="PETS"?0xffdd33:0x33aaff;
  const mat = new THREE.LineBasicMaterial({color,transparent:true,opacity:0.8});
  const line = new THREE.Line(geo,mat);
  scene.add(line);
  if(policyType==="PETS"){
    if(petsPathLine) scene.remove(petsPathLine);
    petsPathLine=line;
  }else{
    if(sacPathLine) scene.remove(sacPathLine);
    sacPathLine=line;
  }
}

/* ========== UI / 마우스 / 줌 ========== */
const speed    = document.getElementById('speed');
const speedNum = document.getElementById('speedNum');
function setRate(v){
  const n=parseFloat(v);
  timeScale = Math.max(0,isNaN(n)?0:n);
  speed.value=String(timeScale);
  speedNum.value=String(timeScale);
}
speed.addEventListener('input',e=>setRate(e.target.value));
speedNum.addEventListener('input',()=>setRate(speedNum.value));
document.querySelectorAll('.btn[data-rate]').forEach(btn=>{
  btn.addEventListener('click',()=>setRate(btn.dataset.rate));
});

const focusSel = document.getElementById('focusSel');
function applyFocus(){
  const v=focusSel.value;
  if(v==='자유(수동)') focusTarget=null;
  else focusTarget=(bodies[v]?bodies[v].pivot:null)||bodies['태양'].pivot;
  updateCam();
}
focusSel.addEventListener('change',applyFocus);
axisList.forEach(a=>a.visible=true);

const gravToggle = document.getElementById('gravToggle');
let showGravityField=false;
let gravHelpers=[];
gravToggle.addEventListener('change',()=>{
  showGravityField=gravToggle.checked;
});

/* 마우스 컨트롤 */
let dragging=false, px=0, py=0, button=0;
const raycaster = new THREE.Raycaster();
const mouse     = new THREE.Vector2();
const clickPlane= new THREE.Plane(new THREE.Vector3(0,1,0),0);
let pendingSpawn=null;

function getClickPositionOnPlane(e){
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x=((e.clientX-rect.left)/rect.width)*2-1;
  mouse.y=-((e.clientY-rect.top)/rect.height)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const pos=new THREE.Vector3();
  const hit=raycaster.ray.intersectPlane(clickPlane,pos);
  if(!hit){
    const dir=new THREE.Vector3();
    camera.getWorldDirection(dir);
    pos.copy(camera.position).add(dir.multiplyScalar(30));
  }
  return pos;
}
app.addEventListener('mousedown',e=>{
  if(e.button===0 && pendingSpawn?.type==='asteroid'){
    const pos=getClickPositionOnPlane(e);
    const shipN = getNearestShip(pos);
    spawnAsteroidSwarm(pos,shipN);
    pendingSpawn=null;
    return;
  }
  dragging=true; px=e.clientX; py=e.clientY; button=e.button;
});
window.addEventListener('mouseup',()=>{dragging=false;});
app.addEventListener('contextmenu',e=>e.preventDefault());
window.addEventListener('mousemove',e=>{
  if(!dragging)return;
  const dx=e.clientX-px, dy=e.clientY-py;
  if(button===0){
    theta-=dx*0.005; phi-=dy*0.005;
    const eps=0.001;
    phi=Math.max(eps,Math.min(Math.PI-eps,phi));
  }else if(button===2 && !focusTarget){
    const s=radius*0.0012;
    camera.updateMatrixWorld();
    const fwd=new THREE.Vector3(); camera.getWorldDirection(fwd);
    const right=fwd.clone().cross(camera.up).normalize();
    const up=camera.up.clone().normalize();
    manualTarget.addScaledVector(right,-dx*s);
    manualTarget.addScaledVector(up,dy*s);
  }
  px=e.clientX; py=e.clientY;
  updateCam();
});
app.addEventListener('wheel',e=>{
  e.preventDefault();
  radius*=1+Math.sign(e.deltaY)*0.08;
  radius=Math.max(30,Math.min(5000,radius));
  updateCam();
},{passive:false});

/* 버튼 */
document.getElementById('spawnAst').addEventListener('click',()=>{
  pendingSpawn={type:'asteroid'};
  console.log('소행성 군 생성 모드: 화면을 클릭하세요.');
});
document.getElementById('clearObjs').addEventListener('click',()=>{
  dynamicObjects.forEach(o=>scene.remove(o.mesh));
  dynamicObjects.length=0;
  petsShip=null; sacShip=null; activeShip=null;
});

/* ========== PETS/SAC 우주선 + 예측/선택/통계 ========== */
let petsShip=null, sacShip=null, activeShip=null;
let petsEnabled=true, sacEnabled=true;
let simulationPaused=false;
let episodeFinished=false;

let totalAttempts=0, totalSuccess=0;

const choiceRow   = document.getElementById('choiceRow');
const resultOverlay = document.getElementById('resultOverlay');
const resultLine    = document.getElementById('resultLine');
const resultPercent = document.getElementById('resultPercent');
const logContent    = document.getElementById('logContent');

document.getElementById('petsEnable').addEventListener('change',e=>{
  petsEnabled=e.target.checked;
  if(petsShip) petsShip.mesh.visible=petsEnabled;
});
document.getElementById('sacEnable').addEventListener('change',e=>{
  sacEnabled=e.target.checked;
  if(sacShip) sacShip.mesh.visible=sacEnabled;
});

/* 우주선 소환 (PETS/SAC 동시에 + 시간 멈춤 + 예측 경로) */
document.getElementById('spawnShip').addEventListener('click',()=>{
  // 이전 에피소드 정리
  if(petsShip){scene.remove(petsShip.mesh); petsShip.alive=false;}
  if(sacShip){ scene.remove(sacShip.mesh);  sacShip.alive=false;}
  petsShip=null; sacShip=null; activeShip=null;
  if(petsPathLine) scene.remove(petsPathLine);
  if(sacPathLine) scene.remove(sacPathLine);
  episodeFinished=false;

  // 시간 멈추기
  simulationPaused=true;

  // 스폰 위치: 지구 근처 약간 바깥
  let basePos;
  const earth = bodies['지구'];
  if(earth){
    basePos = earth.pivot.getWorldPosition(new THREE.Vector3())
      .add(new THREE.Vector3(4,0,0)); // 지구보다 약간 바깥
  }else{
    basePos = new THREE.Vector3(30,0,0);
  }

  const vel = new THREE.Vector3(0,0.7,0);
  petsShip = spawnSpaceshipSimple(basePos.clone().add(new THREE.Vector3(0,0,-1.5)), vel, "PETS", 0xffdd33);
  sacShip  = spawnSpaceshipSimple(basePos.clone().add(new THREE.Vector3(0,0, 1.5)), vel, "SAC",  0x33aaff);

  showPredictedPath(petsShip,"PETS");
  showPredictedPath(sacShip,"SAC");

  choiceRow.style.display='flex';
});

/* 선택 버튼 */
document.getElementById('choosePETS').addEventListener('click',()=>{
  if(!petsShip) return;
  if(sacShip){scene.remove(sacShip.mesh); sacShip.alive=false; sacShip=null;}
  if(sacPathLine){scene.remove(sacPathLine); sacPathLine=null;}
  if(petsPathLine){scene.remove(petsPathLine); petsPathLine=null;}
  activeShip=petsShip;
  simulationPaused=false;
  choiceRow.style.display='none';
});
document.getElementById('chooseSAC').addEventListener('click',()=>{
  if(!sacShip) return;
  if(petsShip){scene.remove(petsShip.mesh); petsShip.alive=false; petsShip=null;}
  if(petsPathLine){scene.remove(petsPathLine); petsPathLine=null;}
  if(sacPathLine){scene.remove(sacPathLine); sacPathLine=null;}
  activeShip=sacShip;
  simulationPaused=false;
  choiceRow.style.display='none';
});

/* 에피소드 종료 처리 */
function endEpisode(ship, success){
  if(episodeFinished) return;
  episodeFinished=true;
  simulationPaused=true;
  totalAttempts++;
  if(success) totalSuccess++;
  const percent = Math.round(totalSuccess*100/totalAttempts);
  const targetName = document.getElementById('autoTarget').value;
  const method = ship.policyType || 'UNKNOWN';
  resultLine.textContent = `${method}가 ${targetName} 향해 ${success?"성공":"실패"}했습니다.`;
  resultPercent.textContent = `성공률 ${percent}% (${totalSuccess}/${totalAttempts})`;
  resultOverlay.style.display='flex';

  const ts = new Date().toISOString().slice(11,19);
  const line = document.createElement('div');
  line.textContent = `[${ts}] ${method} → ${targetName}: ${success?"성공":"실패"}`;
  logContent.prepend(line);
}

/* 모달 바깥 클릭 시 초기화 */
resultOverlay.addEventListener('click',e=>{
  if(e.target===resultOverlay){
    resultOverlay.style.display='none';
    // 우주선/경로 제거
    if(activeShip){scene.remove(activeShip.mesh); activeShip.alive=false;}
    if(petsShip && petsShip!==activeShip){scene.remove(petsShip.mesh);}
    if(sacShip && sacShip!==activeShip){scene.remove(sacShip.mesh);}
    if(petsPathLine){scene.remove(petsPathLine);}
    if(sacPathLine){scene.remove(sacPathLine);}
    petsShip=sacShip=activeShip=null;
    petsPathLine=sacPathLine=null;
    simulationPaused=false;
    episodeFinished=false;
  }
});

/* ========== 케플러 E ========== */
function solveKepler(M,e){
  let E=M;
  for(let i=0;i<12;i++){
    const f=E-e*Math.sin(E)-M;
    const fp=1-e*Math.cos(E);
    E-=f/fp;
  }
  return E;
}

/* ========== 메인 루프 ========== */
let last=performance.now();
const hudBox = document.getElementById('hudBox');

function tick(now){
  const dtReal=(now-last)/1000; last=now;
  const dtDays = simulationPaused ? 0 : dtReal*timeScale;
  if(dtDays!==0){
    simDate = new Date(simDate.getTime() + dtDays*24*3600*1000);
    document.getElementById('startTime').textContent=
      simDate.toISOString().replace('T',' ').slice(0,19);
  }

  const physScale = Math.max(0,Math.min(timeScale,100));
  const dtPhys = simulationPaused ? 0 : dtReal*physScale;

  // 태양/행성/위성
  const sunBody = bodies['태양'];
  if (sunBody && dtDays!==0){
    sunBody.spin.rotation.y += dtDays*(2*Math.PI/defs[0].rotH);
  }
  if(dtDays!==0){
    for(const ps of planetStates){
      const node=ps.node;
      if(node.orbitPeriodDays>0){
        const n=(2*Math.PI)/node.orbitPeriodDays;
        node.meanAnomaly = (node.meanAnomaly+n*dtDays)%(2*Math.PI);
        const M=node.meanAnomaly, e=node.ecc||0;
        const E=solveKepler(M,e);
        const a=node.semiMajor;
        const b=a*Math.sqrt(Math.max(0,1-e*e));
        const x0=a*(Math.cos(E)-e);
        const z0=-b*Math.sin(E);
        const pos=new THREE.Vector3(x0,0,z0);
        const iRad=THREE.MathUtils.degToRad(node.orbitInc||0);
        pos.applyAxisAngle(new THREE.Vector3(1,0,0),iRad);
        node.pivot.position.copy(pos);
      }
      const rotDays=Math.abs(node.rotPeriodHours)/24;
      const rotSgn=node.rotPeriodHours>=0?1:-1;
      if(rotDays>0){
        node.spin.rotation.y += rotSgn*dtDays*(2*Math.PI/rotDays);
      }
    }
  }

  // 동적 객체 (중력 + RL + 충돌)
  if(dtPhys>0 && dynamicObjects.length>0){
    for(let i=dynamicObjects.length-1;i>=0;i--){
      const o=dynamicObjects[i];
      if(!o.alive) continue;
      if(o.type==='ship' && !episodeFinished){
        if(o.policyType==="PETS" && petsEnabled) stepPETS(o,dtPhys);
        else if(o.policyType==="SAC" && sacEnabled) stepSAC(o,dtPhys);
      }
      const a0=computeGravitationalAcceleration(o.pos);
      o.pos.addScaledVector(o.vel,dtPhys)
           .addScaledVector(a0,0.5*dtPhys*dtPhys);
      const a1=computeGravitationalAcceleration(o.pos);
      o.vel.addScaledVector(a0.add(a1).multiplyScalar(0.5),dtPhys);
      o.mesh.position.copy(o.pos);

      // 충돌 체크
      for(const hb of heavyBodies){
        const hp = hb.pivot.getWorldPosition(new THREE.Vector3());
        const dist=hp.distanceTo(o.pos);
        const rBody=hb.mesh.geometry.parameters.radius||1;
        if(dist<rBody*1.1+(o.radius||0.5)){
          explodeAt(o.pos);
          if(o.type==='ship'){
            o.collided=true;
            o.totalReward-=50;
            endEpisode(o,false);
          }
          scene.remove(o.mesh);
          o.alive=false;
          dynamicObjects.splice(i,1);
          break;
        }
      }

      // 도착 판정
      if(o.type==='ship' && !episodeFinished && o.policyType){
        const obs = getObservation(o);
        const successDist=2.0;
        if(obs.dist<successDist){
          endEpisode(o,true);
        }else if(o.fuel<=0){
          endEpisode(o,false);
        }
      }
    }
  }

  updateThrustParticles(dtReal);

  // HUD
  if(petsShip && sacShip){
    const obsP = getObservation(petsShip);
    const obsS = getObservation(sacShip);
    hudBox.innerHTML =
      "PETS / SAC 상태<br>--------------------------<br>" +
      `Target: ${document.getElementById('autoTarget').value}<br>` +
      `PETS dist: ${obsP.dist.toFixed(1)}  v:${obsP.vel.length().toFixed(2)} E:${obsP.totalE.toFixed(1)}<br>`+
      `PETS risk:${obsP.collisionRisk.toFixed(2)} fuel:${(petsShip.fuel*100).toFixed(1)}%<br>`+
      `SAC  dist: ${obsS.dist.toFixed(1)}  v:${obsS.vel.length().toFixed(2)} E:${obsS.totalE.toFixed(1)}<br>`+
      `SAC  risk:${obsS.collisionRisk.toFixed(2)} fuel:${(sacShip.fuel*100).toFixed(1)}%<br>`+
      `(우주선 소환 → 예측 경로 확인 → PETS/SAC 선택)`;
  }

  updateCam();
  renderer.render(scene,camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* 리사이즈 & 초기 UI */
window.addEventListener('resize',()=>{
  const w=app.clientWidth, h=app.clientHeight;
  renderer.setSize(w,h);
  camera.aspect=w/h;
  camera.updateProjectionMatrix();
});
document.getElementById('speed').value=String(timeScale);
document.getElementById('speedNum').value=String(timeScale);
focusSel.value='태양'; applyFocus(); radius=200; updateCam();

</script>
</body>
</html>
