<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>3D íƒœì–‘ê³„ â€” ì´ì‹¬ë¥ (e) : íƒœì–‘ì„ íƒ€ì› ì´ˆì ìœ¼ë¡œ (ì´ë²¤íŠ¸ í¬í•¨)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#061024;color:#e9f2ff;font:12px/1.4 system-ui}
  #app{position:fixed; inset:0}
  canvas{display:block; width:100%; height:100%}
  .ui{
    position:fixed; left:12px; top:12px; background:rgba(255,255,255,.04);
    border:1px solid rgba(255,255,255,.06); padding:8px 10px; border-radius:10px;
    display:flex; gap:10px; flex-wrap:wrap; align-items:center; max-width:96vw; z-index:20;
  }
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .btn{cursor:pointer; padding:4px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.02)}
  .btn:hover{background:rgba(255,255,255,.04)}
  input[type="range"]{width:200px}
  select,input[type="number"]{background:transparent; color:#e9f2ff; border:1px solid rgba(255,255,255,.06); border-radius:6px; padding:4px}
  .hint{opacity:.7;font-size:12px;color:#bcd}
</style>
</head>
<body>
<div id="app"></div>

<div class="ui">
  <div class="row">
    <label for="speed">ì†ë„</label>
    <input id="speed" type="range" min="0" max="8" step="0.1" value="2">
    <input id="speedNum" type="number" min="0" max="8" step="0.1" value="2" style="width:60px">
    <button class="btn" data-rate="1">1Ã—</button>
    <button class="btn" data-rate="2">2Ã—</button>
    <button class="btn" data-rate="3">3Ã—</button>
  </div>

  <div class="row">
    <label for="focusSel">ì¤‘ì‹¬ì </label>
    <select id="focusSel">
      <option>ììœ (ìˆ˜ë™)</option>
      <option>íƒœì–‘</option>
      <option selected>ì§€êµ¬</option>
      <option>ìˆ˜ì„±</option><option>ê¸ˆì„±</option><option>ë‹¬</option><option>í™”ì„±</option>
      <option>ëª©ì„±</option><option>í† ì„±</option><option>ì²œì™•ì„±</option><option>í•´ì™•ì„±</option>
    </select>
    <label><input id="axisToggle" type="checkbox" checked> ìì „ì¶• í‘œì‹œ</label>
    <span class="hint">â€¢ ì¢Œí´ë¦­: íšŒì „ Â· íœ : ì¤Œ Â· ìš°í´ë¦­: íŒ¬(ììœ  ëª¨ë“œ)</span>
  </div>

  <div class="row">
    <button class="btn" id="spawnAsteroidBtn">â˜„ï¸ ì†Œí–‰ì„± ì†Œí™˜ (ì•)</button>
    <button class="btn" id="spawnShipBtn">ğŸš€ ìš°ì£¼ì„  ì†Œí™˜ (ì•)</button>
    <button class="btn" id="clearShipsBtn">ğŸ—‘ï¸ ìš°ì£¼ì„  ì‚­ì œ</button>
    <label style="margin-left:8px"><input id="showGravity" type="checkbox" checked> ì¤‘ë ¥ê¶Œ ì‹œê°í™”</label>
  </div>
</div>

<!-- Three.js UMD -->
<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>

<script>
/*
  3D íƒœì–‘ê³„ (íƒœì–‘ì„ íƒ€ì›ì˜ ì´ˆì ìœ¼ë¡œ í•˜ëŠ” ì´ì‹¬ë¥  ì ìš©)
  + ì†Œí–‰ì„±/ìš°ì£¼ì„  ì´ë²¤íŠ¸, ì¤‘ë ¥ê¶Œ, ì¶©ëŒ/í­ë°œ, AI ìŠ¬ë¡¯ í†µí•©
  ì£¼ì„: í•µì‹¬ ë¡œì§ì€ tick() ë‚´ì—ì„œ ì´ì‹¬ë¥  ê¸°ë°˜ ìœ„ì¹˜ ê³„ì‚° ë° ì´ë²¤íŠ¸ ì—…ë°ì´íŠ¸
*/

// ---------- ê¸°ë³¸ ë Œë”ëŸ¬/ì”¬/ì¹´ë©”ë¼ ----------
const app = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(app.clientWidth, app.clientHeight);
renderer.setClearColor(0x061024, 1);
app.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, app.clientWidth/app.clientHeight, 0.1, 20000);

// orbit camera (manual)
let radius = 220, phi = THREE.MathUtils.degToRad(25), theta = THREE.MathUtils.degToRad(30);
const manualTarget = new THREE.Vector3(0,0,0);
let focusTarget = null;
function getTarget(){ return focusTarget ? focusTarget.getWorldPosition(new THREE.Vector3()) : manualTarget; }
function updateCam(){
  const t = getTarget();
  const x = t.x + radius * Math.sin(phi) * Math.cos(theta);
  const y = t.y + radius * Math.cos(phi);
  const z = t.z + radius * Math.sin(phi) * Math.sin(theta);
  camera.position.set(x,y,z);
  camera.lookAt(t);
}
updateCam();

// lights
scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const sunLight = new THREE.PointLight(0xffffff, 2.6, 0, 2);
scene.add(sunLight);

// helpers
function axisMesh(len, thick=0.06){
  const g = new THREE.CylinderGeometry(thick, thick, len, 12);
  const m = new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.7, depthWrite:false });
  const cyl = new THREE.Mesh(g, m);
  cyl.position.y = 0;
  return cyl;
}

// containers
const bodies = {}; // name -> pivot
const axisList = [];

// scale/time
const SIZE = 1.0;
const DIST = 1.0;
let timeScale = 2; // day / sec

// ---------- Sun ----------
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(10*SIZE, 64, 64),
  new THREE.MeshBasicMaterial({ color: 0xffd97a })
);
scene.add(sun);
sunLight.position.copy(sun.position);

// ---------- createBody (êµ¬ì¡°ëŠ” pivot ëŒ€ì‹ , ìœ„ì¹˜ëŠ” ìˆ˜ì‹ìœ¼ë¡œ ì§ì ‘ ì„¤ì •) ----------
function createBodySimple({ name, size=1, color=0xffffff, axialTiltDeg=0 } = {}) {
  // Each body has a group used to hold the mesh (for axis)
  const group = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.7 });
  const sphere = new THREE.Mesh(new THREE.SphereGeometry(size*SIZE, 32,32), mat);
  group.add(sphere);
  const ax = axisMesh(size*SIZE*3.0, Math.max(0.03, size*SIZE*0.06));
  group.add(ax); axisList.push(ax);
  return { name, group, sphere, axis: ax, size };
}

// ---------- planet data with eccentricity (a=visual orbit radius) ----------
const planetDefs = [
  // name, color, visual size, a-dist (scene units), orbitDays, rotH, axial tilt, eccentricity e
  { name:'ìˆ˜ì„±', color:0xb4b4b4, size:0.9, a:16, orbit:87.969, rotH:1407.6, tilt:0.03, e:0.2056 },
  { name:'ê¸ˆì„±', color:0xd8b47d, size:1.1, a:22, orbit:224.701, rotH:-5832.5, tilt:177.36, e:0.0068 },
  { name:'ì§€êµ¬', color:0x5fa8ff, size:1.2, a:30, orbit:365.256, rotH:23.934, tilt:23.44, e:0.0167,
    moons:[ { name:'ë‹¬', color:0xcfd6ff, size:0.35, a:4.0, orbit:27.322, rotH:655.7, tilt:6.68 } ]
  },
  { name:'í™”ì„±', color:0xff6b6b, size:0.9, a:38, orbit:686.980, rotH:24.623, tilt:25.19, e:0.0934,
    moons:[ { name:'í¬ë³´ìŠ¤', color:0xaaaaaa, size:0.12, a:2.5, orbit:0.3189, rotH:7.65, tilt:0 }, { name:'ë°ì´ëª¨ìŠ¤', color:0xcccccc, size:0.08, a:3.2, orbit:1.263, rotH:30.3, tilt:0 } ]
  },
  { name:'ëª©ì„±', color:0xc89f68, size:4.0, a:60, orbit:4332.589, rotH:9.925, tilt:3.13, e:0.0489,
    moons:[ { name:'ì´ì˜¤', color:0xe6d27c, size:0.25, a:6.0, orbit:1.769, rotH:42.46, tilt:0 }, { name:'ìœ ë¡œíŒŒ', color:0xdddddd, size:0.22, a:7.5, orbit:3.551, rotH:85.2, tilt:0.1 } ]
  },
  { name:'í† ì„±', color:0xd8cfae, size:3.6, a:78, orbit:10759.22, rotH:10.656, tilt:26.73, e:0.0565, ring:true,
    moons:[ { name:'íƒ€ì´íƒ„', color:0xcab47a, size:0.28, a:8.0, orbit:15.945, rotH:382.7, tilt:0.3 } ]
  },
  { name:'ì²œì™•ì„±', color:0x9bd7ff, size:2.9, a:96, orbit:30688.5, rotH:-17.24, tilt:97.77, e:0.0457,
    moons:[ { name:'í‹°íƒ€ë‹ˆì•„', color:0xcccccc, size:0.18, a:6.0, orbit:8.706, rotH:208.9, tilt:0 } ]
  },
  { name:'í•´ì™•ì„±', color:0x6aa7ff, size:2.8, a:112, orbit:60182.0, rotH:16.11, tilt:28.32, e:0.0113,
    moons:[ { name:'íŠ¸ë¦¬í†¤', color:0xcfd6ff, size:0.22, a:6.5, orbit:5.877, rotH:141.0, tilt:0, retrogradeOrbit:true } ]
  }
];

// create planetStates with elliptical orbit parameters
const planetStates = [];
for (const def of planetDefs){
  const b = def.a * Math.sqrt(1 - (def.e || 0)*(def.e || 0)); // minor axis scale
  // create visual orbit line (ellipse) centered at (-e*a, 0, 0) so that sun at origin is focus
  const curve = new THREE.EllipseCurve( - (def.e||0) * def.a, 0, def.a, b, 0, 2*Math.PI, false, 0 );
  const points = curve.getPoints(256);
  const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points.map(p => new THREE.Vector3(p.x, 0, p.y)));
  const orbitMaterial = new THREE.LineBasicMaterial({ color: def.color, transparent:true, opacity:0.35 });
  const orbitLine = new THREE.LineLoop(orbitGeometry, orbitMaterial);
  scene.add(orbitLine);

  // create body mesh
  const body = createBodySimple({ name:def.name, size:def.size, color:def.color, axialTiltDeg:def.tilt});
  scene.add(body.group);

  // ring for Saturn if needed
  if (def.ring){
    const ringGeom = new THREE.RingGeometry((def.size*SIZE)*2.0, (def.size*SIZE)*2.8, 128);
    ringGeom.rotateX(-Math.PI/2);
    const ringMat = new THREE.MeshStandardMaterial({ color:0xd8cfae, roughness:0.9, metalness:0, transparent:true, opacity:0.7, side:THREE.DoubleSide });
    const ring = new THREE.Mesh(ringGeom, ringMat);
    body.group.add(ring);
  }

  // add moons relative data (we will compute their positions around the parent)
  const moons = [];
  if (def.moons){
    for (const m of def.moons){
      const mBody = createBodySimple({ name:m.name, size:m.size, color:m.color, axialTiltDeg:m.tilt });
      // add child group to planet group for simple local orbit
      body.group.add(mBody.group);
      moons.push({ def:m, node:mBody, orbitAngle:0 });
    }
  }

  // compute approximate gravity radius & mass ratio as previous
  const MASS_RATIO = { 'ìˆ˜ì„±':0.055,'ê¸ˆì„±':0.815,'ì§€êµ¬':1.0,'í™”ì„±':0.107,'ëª©ì„±':317.8,'í† ì„±':95.2,'ì²œì™•ì„±':14.5,'í•´ì™•ì„±':17.1 };
  const massRatio = MASS_RATIO[def.name] || 0.2;
  const MAX_MASS = 317.8;
  const gravityRadius = Math.max(20, def.a * 0.25 + (massRatio / MAX_MASS) * def.a * 2.0);

  const pstate = {
    def,
    node: body,
    moons,
    a: def.a,
    b: b,
    e: def.e || 0,
    orbitLine,
    orbitAngle: Math.random()*Math.PI*2,
    rotPeriodHours: def.rotH,
    gravityRadius,
    massRatio,
    _gravRing: null,
    _destroyed: false
  };

  // add a subtle gravity ring mesh (will be attached to planet's world position)
  const ringMesh = new THREE.Mesh(
    new THREE.RingGeometry(pstate.gravityRadius * 0.95, pstate.gravityRadius * 1.05, 64).rotateX(-Math.PI/2),
    new THREE.MeshBasicMaterial({ color: def.color, transparent:true, opacity:0.06, side:THREE.DoubleSide })
  );
  pstate._gravRing = ringMesh; // we'll position it in tick by copying planet world pos and rotation
  scene.add(ringMesh);

  planetStates.push(pstate);
  bodies[def.name] = body.group;
}

// ---------- UI binding ----------
const speed = document.getElementById('speed');
const speedNum = document.getElementById('speedNum');
function setRate(v){ timeScale = Math.max(0, Number(v) || 0); speed.value = String(timeScale); speedNum.value = String(timeScale); }
speed.addEventListener('input', e=> setRate(e.target.value));
speedNum.addEventListener('input', e=> setRate(e.target.value));
document.querySelectorAll('.btn[data-rate]').forEach(b=> b.addEventListener('click', ()=> setRate(b.dataset.rate)));

const focusSel = document.getElementById('focusSel');
function applyFocus(){
  const v = focusSel.value;
  if (v === 'ììœ (ìˆ˜ë™)') focusTarget = null;
  else if (v === 'íƒœì–‘') focusTarget = sun;
  else focusTarget = bodies[v] || null;
  updateCam();
}
focusSel.addEventListener('change', applyFocus);

const axisToggle = document.getElementById('axisToggle');
axisToggle.addEventListener('change', ()=> axisList.forEach(ax => ax.visible = axisToggle.checked));
axisList.forEach(ax => ax.visible = true);

// ---------- mouse controls ----------
let dragging=false, px=0, py=0, button=0;
app.addEventListener('mousedown', e=>{ dragging=true; px=e.clientX; py=e.clientY; button=e.button; });
window.addEventListener('mouseup', ()=> dragging=false);
app.addEventListener('contextmenu', e=> e.preventDefault());

window.addEventListener('mousemove', e=>{
  if (!dragging) return;
  const dx = (e.clientX - px), dy = (e.clientY - py);
  if (button === 0) { theta -= dx * 0.005; phi -= dy * 0.005; const eps = 0.001; phi = Math.max(eps, Math.min(Math.PI-eps, phi)); }
  else if (button === 2) { if (!focusTarget) { const s = radius * 0.0012; camera.updateMatrixWorld(); const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); const right = fwd.clone().cross(camera.up).normalize(); const up = camera.up.clone().normalize(); manualTarget.addScaledVector(right, -dx*s); manualTarget.addScaledVector(up, dy*s); } }
  px = e.clientX; py = e.clientY; updateCam();
});
app.addEventListener('wheel', e=>{ e.preventDefault(); radius *= (1 + Math.sign(e.deltaY)*0.08); radius = Math.max(30, Math.min(2000, radius)); updateCam(); },{passive:false});

// ---------- Entities: ships, asteroids, explosions ----------
const ships = [];      // { mesh, vel:Vector3, ai:{mode,brain}, remove:Boolean }
const asteroids = [];  // { mesh, vel:Vector3, remove:Boolean }
const explosions = []; // { particles:[], life, age }

// raycaster + plane y=0
const raycaster = new THREE.Raycaster();
const mouseVec = new THREE.Vector2();
const groundPlane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);

// helper: pointer -> world on y=0
function pointerToWorld(clientX, clientY){
  const rect = renderer.domElement.getBoundingClientRect();
  mouseVec.x = ((clientX - rect.left) / rect.width) * 2 - 1;
  mouseVec.y = -((clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouseVec, camera);
  const p = new THREE.Vector3();
  raycaster.ray.intersectPlane(groundPlane, p);
  return p;
}

// spawn explosion
function spawnExplosion(position){
  const group = [];
  const particleCount = 12 + Math.floor(Math.random()*18);
  for (let i=0;i<particleCount;i++){
    const g = new THREE.SphereGeometry(0.3 + Math.random()*0.6, 6,6);
    const mat = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(0.05 + Math.random()*0.08, 0.85, 0.5), transparent:true });
    const m = new THREE.Mesh(g, mat);
    m.position.copy(position);
    m.userData.v = new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.2)*2, (Math.random()-0.5)*2);
    scene.add(m);
    group.push(m);
  }
  explosions.push({ particles:group, life:1.6, age:0 });
}

// spawn asteroid
function spawnAsteroidAt(pos){
  const geom = new THREE.SphereGeometry(0.6 + Math.random()*1.4, 8,8);
  const mat = new THREE.MeshStandardMaterial({ color:0x9e9e9e, roughness:1.0 });
  const m = new THREE.Mesh(geom, mat);
  m.position.copy(pos);
  scene.add(m);
  const vel = new THREE.Vector3((Math.random()-0.5)*0.6, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.6);
  asteroids.push({ mesh:m, vel, remove:false });
}

// spawn ship (cone, initially stationary)
function spawnShipAt(pos){
  const geom = new THREE.ConeGeometry(1.0, 2.4, 12);
  const mat = new THREE.MeshStandardMaterial({ color:0x66ffff, emissive:0x113344, roughness:0.4 });
  const m = new THREE.Mesh(geom, mat);
  m.rotation.x = Math.PI/2;
  m.position.copy(pos);
  scene.add(m);
  const ship = { mesh:m, vel:new THREE.Vector3(0,0,0), ai:{ mode:'idle', brain:null }, remove:false };
  ships.push(ship);
  return ship;
}

// UI bindings
document.getElementById('spawnAsteroidBtn').addEventListener('click', ()=>{
  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
  const pos = camera.position.clone().add(dir.multiplyScalar(radius * 0.6));
  spawnAsteroidAt(pos);
});
document.getElementById('spawnShipBtn').addEventListener('click', ()=>{
  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
  const pos = camera.position.clone().add(dir.multiplyScalar(radius * 0.6));
  spawnShipAt(pos);
});
document.getElementById('clearShipsBtn').addEventListener('click', ()=>{
  for (const s of ships) scene.remove(s.mesh);
  ships.length = 0;
});

// pointer spawn: left-click spawns ship (shift-click spawns asteroid)
renderer.domElement.addEventListener('pointerdown', (ev)=>{
  if (ev.button !== 0) return;
  const p = pointerToWorld(ev.clientX, ev.clientY);
  if (ev.shiftKey) spawnAsteroidAt(p);
  else spawnShipAt(p);
});

// ---------- updateEntities: gravity, collisions, explosions ----------
function updateEntities(dtSec){
  // update explosions
  for (let i=explosions.length-1;i>=0;i--){
    const ex = explosions[i]; ex.age += dtSec;
    for (const p of ex.particles){
      p.position.addScaledVector(p.userData.v, dtSec*4);
      p.material.opacity = Math.max(0, 1 - ex.age/ex.life);
      p.scale.setScalar(1 + ex.age*1.5);
    }
    if (ex.age >= ex.life){
      for (const p of ex.particles) scene.remove(p);
      explosions.splice(i,1);
    }
  }

  // cache planet positions
  const planetPositions = planetStates.map(ps => {
    const pos = new THREE.Vector3();
    // current planet position computed from a,e,b,orbitAngle in tick() â€” but getWorldPosition is safe
    ps.node.group.getWorldPosition(pos);
    return { ps, pos };
  });

  // asteroids
  for (let i=asteroids.length-1;i>=0;i--){
    const a = asteroids[i];
    if (a.remove){ scene.remove(a.mesh); asteroids.splice(i,1); continue; }
    const acc = new THREE.Vector3();
    for (const {ps, pos} of planetPositions){
      if (ps._destroyed) continue;
      const rVec = pos.clone().sub(a.mesh.position);
      const dist = rVec.length();
      if (dist < ps.gravityRadius && dist > 0.1){
        const strength = (ps.massRatio / 317.8) * 600; // tuning
        const aMag = strength / (dist*dist + 1);
        acc.addScaledVector(rVec.normalize(), aMag);
        if (document.getElementById('showGravity').checked){
          a.mesh.material.emissive = new THREE.Color(ps.def.color).multiplyScalar(0.12);
        }
      }
    }
    a.vel.add(acc.multiplyScalar(dtSec));
    a.mesh.position.addScaledVector(a.vel, dtSec);

    // collision with planets (approx)
    for (const {ps, pos} of planetPositions){
      if (ps._destroyed) continue;
      const dist = pos.distanceTo(a.mesh.position);
      const approxPlanetRadius = ps.def.size * SIZE * 1.0;
      if (dist < approxPlanetRadius * 0.9 + (a.mesh.geometry.parameters.radius || 1.0)){
        if (!ps._destroyed){
          ps._destroyed = true;
          // remove visual sphere from planet node
          if (ps.node.group.children.length) ps.node.group.remove(ps.node.group.children[0]);
          if (ps._gravRing) scene.remove(ps._gravRing);
          spawnExplosion(pos);
        }
        a.remove = true;
        break;
      }
    }
    if (a.remove){ scene.remove(a.mesh); asteroids.splice(i,1); continue; }
  }

  // ships
  for (let i=ships.length-1;i>=0;i--){
    const s = ships[i];
    if (s.remove){ scene.remove(s.mesh); ships.splice(i,1); continue; }
    const acc = new THREE.Vector3();
    for (const {ps, pos} of planetPositions){
      if (ps._destroyed) continue;
      const rVec = pos.clone().sub(s.mesh.position);
      const dist = rVec.length();
      if (dist < ps.gravityRadius && dist > 0.1){
        const strength = (ps.massRatio / 317.8) * 600;
        const aMag = strength / (dist*dist + 1);
        acc.addScaledVector(rVec.normalize(), aMag);
        if (document.getElementById('showGravity').checked) s.mesh.material.emissive = new THREE.Color(ps.def.color).multiplyScalar(0.08);
      }
    }

    // AI slot (stub)
    if (s.ai && s.ai.brain){
      // place to call inference: compute sensor vector and call model
    }

    s.vel.add(acc.multiplyScalar(dtSec));
    s.mesh.position.addScaledVector(s.vel, dtSec);

    // orient to velocity
    const speedMag = s.vel.length();
    if (speedMag > 0.0001){
      const dir = s.vel.clone().normalize();
      const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), dir);
      s.mesh.quaternion.slerp(quat, 0.06);
    }

    // collision with planets
    for (const {ps, pos} of planetPositions){
      if (ps._destroyed) continue;
      const dist = pos.distanceTo(s.mesh.position);
      const approxPlanetRadius = ps.def.size * SIZE * 1.0;
      if (dist < approxPlanetRadius * 0.9 + 1.0){
        s.remove = true;
        spawnExplosion(pos);
        break;
      }
    }
  }

  updateCam();
}

// ---------- tick(): compute elliptical orbits with focus at sun ----------
let last = performance.now();
function tick(now){
  const dtSec = (now - last) / 1000; last = now;
  const dtDays = dtSec * timeScale;

  // sun rotation (visual)
  sun.rotation.y += dtDays * (2*Math.PI / 25.0);

  // iterate planets: compute Î¸ increment and set positions using x = a(cosÎ¸ - e), z = b sinÎ¸
  for (const ps of planetStates){
    if (ps._destroyed) {
      // still update orbit angle for consistency
      ps.orbitAngle += dtDays * (2*Math.PI / Math.max(1, ps.def.orbit));
      continue;
    }

    // increment angle: 2Ï€ / period * dtDays
    const sgn = 1;
    ps.orbitAngle += sgn * dtDays * (2*Math.PI / ps.def.orbit);

    const ang = ps.orbitAngle;
    const a = ps.a;
    const e = ps.e;
    const b = ps.b;

    // position relative to sun (sun at origin, focus at origin)
    const x = a * (Math.cos(ang) - e);
    const z = b * Math.sin(ang);
    // set group's world position (group refers to body.group)
    ps.node.group.position.set(x, 0, z);

    // rotate spin for axial rotation
    const rotDays = Math.abs(ps.rotPeriodHours)/24;
    const rotSgn = ps.rotPeriodHours >= 0 ? 1 : -1;
    if (rotDays > 0){
      // spin rotation is local: rotate the first child (sphere & axis) if exists
      if (ps.node.group.children[0]) ps.node.group.children[0].rotation.y += rotSgn * dtDays * (2*Math.PI / rotDays);
    }

    // position the gravity ring to follow planet
    if (ps._gravRing){
      ps._gravRing.position.set(x, 0.01, z);
      ps._gravRing.rotation.x = -Math.PI/2;
      ps._gravRing.visible = (document.getElementById('showGravity').checked && !ps._destroyed);
    }

    // moons: local orbit around the planet: use stored moon.orbitAngle
    for (let i=0;i<ps.moons.length;i++){
      const m = ps.moons[i];
      const mdef = ps.def.moons[i];
      m.orbitAngle += dtDays * (2*Math.PI / m.def.orbit);
      const ca = Math.cos(m.orbitAngle), sa = Math.sin(m.orbitAngle);
      const mx = ca * m.def.a;
      const mz = -sa * m.def.a;
      m.node.group.position.set(mx, 0, mz); // relative to parent (we added moon group to parent)
      // moon rotation
      const mRotDays = Math.abs(m.node.def ? m.node.def.rotH : (m.def.rotH || 24))/24;
      if (mRotDays > 0 && m.node.group.children[0]) m.node.group.children[0].rotation.y += dtDays * (2*Math.PI / (Math.abs(m.def.rotH)/24 || 1));
    }
  }

  // update entities physics
  updateEntities(dtSec);

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

// ---------- resize ----------
addEventListener('resize', ()=>{
  const w = app.clientWidth, h = app.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
});

// ---------- initial view ----------
document.getElementById('speed').value = '2';
document.getElementById('speedNum').value = '2';
timeScale = 2;
focusSel.value = 'ì§€êµ¬'; applyFocus();
radius = 180; updateCam();

/* Notes:
 - ê¶¤ë„ ì‹: x = a*(cosÎ¸ - e), z = b*sinÎ¸. ì—¬ê¸°ì„œ íƒœì–‘(ì›ì )=ì´ˆì .
 - orbitLine created with EllipseCurve centered at (-e*a,0) so that line visually matches path where sun is a focus.
 - ì„±ëŠ¥: ë‹¤ìˆ˜ ì†Œí–‰ì„±ì€ InstancedMesh ì „í™˜ì„ ê¶Œì¥.
 - AI: ship.ai.brain ìë¦¬ì— TF.js ëª¨ë¸ì„ ë¡œë“œí•´ ì¶”ë¡  ê°€ëŠ¥ (ì¶”í›„ ì‘ì—…).
*/
</script>
</body>
</html>

