<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>3D íƒœì–‘ê³„ â€” ì´ì‹¬ë¥ (e) : íƒœì–‘ì„ íƒ€ì› ì´ˆì ìœ¼ë¡œ (ê¶¤ë„ë©´ ì‹¤ì‚¬í™” Â· ëª…ì™•ì„± í¬í•¨)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#061024;color:#e9f2ff;font:12px/1.4 system-ui}
  #app{position:fixed; inset:0}
  canvas{display:block; width:100%; height:100%}
  .ui{
    position:fixed; left:12px; top:12px; background:rgba(255,255,255,.04);
    border:1px solid rgba(255,255,255,.06); padding:8px 10px; border-radius:10px;
    display:flex; gap:10px; flex-wrap:wrap; align-items:center; max-width:96vw; z-index:20;
  }
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .btn{cursor:pointer; padding:4px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.02)}
  .btn:hover{background:rgba(255,255,255,.04)}
  input[type="range"]{width:200px}
  select,input[type="number"]{background:transparent; color:#e9f2ff; border:1px solid rgba(255,255,255,.06); border-radius:6px; padding:4px}
  .hint{opacity:.7;font-size:12px;color:#bcd}
</style>
</head>
<body>
<div id="app"></div>

<div class="ui">
  <div class="row">
    <label for="speed">ì†ë„</label>
    <input id="speed" type="range" min="0" max="8" step="0.1" value="2">
    <input id="speedNum" type="number" min="0" max="8" step="0.1" value="2" style="width:60px">
    <button class="btn" data-rate="1">1Ã—</button>
    <button class="btn" data-rate="2">2Ã—</button>
    <button class="btn" data-rate="3">3Ã—</button>
  </div>

  <div class="row">
    <label for="focusSel">ì¤‘ì‹¬ì </label>
    <select id="focusSel">
      <option>ììœ (ìˆ˜ë™)</option>
      <option>íƒœì–‘</option>
      <option selected>ì§€êµ¬</option>
      <option>ìˆ˜ì„±</option><option>ê¸ˆì„±</option><option>ë‹¬</option><option>í™”ì„±</option>
      <option>ëª©ì„±</option><option>í† ì„±</option><option>ì²œì™•ì„±</option><option>í•´ì™•ì„±</option><option>ëª…ì™•ì„±</option>
    </select>
    <label><input id="axisToggle" type="checkbox" checked> ìì „ì¶• í‘œì‹œ</label>
    <span class="hint">â€¢ ì¢Œí´ë¦­: íšŒì „ Â· íœ : ì¤Œ Â· ìš°í´ë¦­: íŒ¬(ììœ  ëª¨ë“œ)</span>
  </div>

  <div class="row">
    <button class="btn" id="spawnAsteroidBtn">â˜„ï¸ ì†Œí–‰ì„± ì†Œí™˜ (ì•)</button>
    <button class="btn" id="spawnShipBtn">ğŸš€ ìš°ì£¼ì„  ì†Œí™˜ (ì•)</button>
    <button class="btn" id="clearShipsBtn">ğŸ—‘ï¸ ìš°ì£¼ì„  ì‚­ì œ</button>
    <label style="margin-left:8px"><input id="showGravity" type="checkbox" checked> ì¤‘ë ¥ê¶Œ ì‹œê°í™”</label>
  </div>
</div>

<!-- Three.js UMD -->
<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>

<script>
/*
  3D íƒœì–‘ê³„ â€” ê¶¤ë„ë©´ ì‹¤ì‚¬í™”(íƒ€ì›íŒ) + ëª…ì™•ì„± í¬í•¨
  ê¸°ì¡´ ê¸°ëŠ¥(ì†Œí–‰ì„±, ìš°ì£¼ì„ , ì¤‘ë ¥ê¶Œ, ì¶©ëŒ, AI ìŠ¬ë¡¯) ìœ ì§€
*/

// ---------- ê¸°ë³¸ ë Œë”ëŸ¬/ì”¬/ì¹´ë©”ë¼ ----------
const app = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(app.clientWidth, app.clientHeight);
renderer.setClearColor(0x061024, 1);
app.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, app.clientWidth/app.clientHeight, 0.1, 40000);

// orbit camera (manual)
let radius = 220, phi = THREE.MathUtils.degToRad(25), theta = THREE.MathUtils.degToRad(30);
const manualTarget = new THREE.Vector3(0,0,0);
let focusTarget = null;
function getTarget(){ return focusTarget ? focusTarget.getWorldPosition(new THREE.Vector3()) : manualTarget; }
function updateCam(){
  const t = getTarget();
  const x = t.x + radius * Math.sin(phi) * Math.cos(theta);
  const y = t.y + radius * Math.cos(phi);
  const z = t.z + radius * Math.sin(phi) * Math.sin(theta);
  camera.position.set(x,y,z);
  camera.lookAt(t);
}
updateCam();

// lights
scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const sunLight = new THREE.PointLight(0xffffff, 2.6, 0, 2);
scene.add(sunLight);

// helpers
function axisMesh(len, thick=0.06){
  const g = new THREE.CylinderGeometry(thick, thick, len, 12);
  const m = new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.7, depthWrite:false });
  const cyl = new THREE.Mesh(g, m);
  cyl.position.y = 0;
  return cyl;
}

// containers
const bodies = {}; // name -> group
const axisList = [];
const orbitPlanes = []; // store orbit meshes so we can toggle visibility

// scale/time
const SIZE = 1.0;
let timeScale = 2; // day / sec

// ---------- Sun ----------
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(10*SIZE, 64, 64),
  new THREE.MeshBasicMaterial({ color: 0xffd97a })
);
scene.add(sun);
sunLight.position.copy(sun.position);

// ---------- createBody ----------
function createBodySimple({ name, size=1, color=0xffffff } = {}) {
  const group = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.7 });
  const sphere = new THREE.Mesh(new THREE.SphereGeometry(size*SIZE, 32,32), mat);
  group.add(sphere);
  const ax = axisMesh(size*SIZE*3.0, Math.max(0.03, size*SIZE*0.06));
  group.add(ax); axisList.push(ax);
  return { name, group, sphere, axis: ax, size };
}

// ---------- createOrbitPlane: íƒ€ì›í˜• ë©´ìœ¼ë¡œ ì‹¤ì‚¬í™” ----------
function createOrbitPlane(def){
  const e = def.e || 0;
  const a = def.a;
  const b = a * Math.sqrt(1 - e*e);
  const segments = 256;
  const pts = [];
  for (let i=0;i<=segments;i++){
    const th = (i/segments) * 2 * Math.PI;
    const x = a * Math.cos(th) - e * a; // center shift so focus at origin
    const z = b * Math.sin(th);
    pts.push(new THREE.Vector2(x, z));
  }
  // create shape and geometry (fill)
  const shape = new THREE.Shape(pts);
  const geometry = new THREE.ShapeGeometry(shape, undefined);
  // thin, double-sided, low-opacity material for realistic orbit plane
  const material = new THREE.MeshBasicMaterial({ color: def.color, transparent: true, opacity: 0.06, side: THREE.DoubleSide });
  const mesh = new THREE.Mesh(geometry, material);
  // apply inclination (rotate around X)
  const iRad = THREE.MathUtils.degToRad(def.i || 0);
  mesh.rotation.x = iRad;
  mesh.position.y = 0; // keep in sun-centric plane (y used for inclination rotation)
  scene.add(mesh);
  orbitPlanes.push(mesh);
  return mesh;
}

// ---------- planet definitions (ëª…ì™•ì„± í¬í•¨) ----------
const planetDefs = [
  { name:'ìˆ˜ì„±', color:0xb4b4b4, size:0.9, a:16, orbit:87.969, rotH:1407.6, tilt:0.03, e:0.2056, i:7.0 },
  { name:'ê¸ˆì„±', color:0xd8b47d, size:1.1, a:22, orbit:224.701, rotH:-5832.5, tilt:177.36, e:0.0068, i:3.4 },
  { name:'ì§€êµ¬', color:0x5fa8ff, size:1.2, a:30, orbit:365.256, rotH:23.934, tilt:23.44, e:0.0167, i:0.0,
    moons:[ { name:'ë‹¬', color:0xcfd6ff, size:0.35, a:4.0, orbit:27.322, rotH:655.7, tilt:6.68 } ] },
  { name:'í™”ì„±', color:0xff6b6b, size:0.9, a:38, orbit:686.980, rotH:24.623, tilt:25.19, e:0.0934, i:1.85,
    moons:[ { name:'í¬ë³´ìŠ¤', color:0xaaaaaa, size:0.12, a:2.5, orbit:0.3189, rotH:7.65, tilt:0 },
            { name:'ë°ì´ëª¨ìŠ¤', color:0xcccccc, size:0.08, a:3.2, orbit:1.263, rotH:30.3, tilt:0 } ] },
  { name:'ëª©ì„±', color:0xc89f68, size:4.0, a:60, orbit:4332.589, rotH:9.925, tilt:3.13, e:0.0489, i:1.3,
    moons:[ { name:'ì´ì˜¤', color:0xe6d27c, size:0.25, a:6.0, orbit:1.769, rotH:42.46, tilt:0 },
            { name:'ìœ ë¡œíŒŒ', color:0xdddddd, size:0.22, a:7.5, orbit:3.551, rotH:85.2, tilt:0.1 } ] },
  { name:'í† ì„±', color:0xd8cfae, size:3.6, a:78, orbit:10759.22, rotH:10.656, tilt:26.73, e:0.0565, i:2.48, ring:true,
    moons:[ { name:'íƒ€ì´íƒ„', color:0xcab47a, size:0.28, a:8.0, orbit:15.945, rotH:382.7, tilt:0.3 } ] },
  { name:'ì²œì™•ì„±', color:0x9bd7ff, size:2.9, a:96, orbit:30688.5, rotH:-17.24, tilt:97.77, e:0.0457, i:0.77,
    moons:[ { name:'í‹°íƒ€ë‹ˆì•„', color:0xcccccc, size:0.18, a:6.0, orbit:8.706, rotH:208.9, tilt:0 } ] },
  { name:'í•´ì™•ì„±', color:0x6aa7ff, size:2.8, a:112, orbit:60182.0, rotH:16.11, tilt:28.32, e:0.0113, i:1.77,
    moons:[ { name:'íŠ¸ë¦¬í†¤', color:0xcfd6ff, size:0.22, a:6.5, orbit:5.877, rotH:141.0, tilt:0, retrogradeOrbit:true } ] },
  { name:'ëª…ì™•ì„±', color:0x9999cc, size:0.6, a:140, orbit:90560, rotH:-153.3, tilt:122.5, e:0.2488, i:17.16 }
];

// ---------- planetStates ìƒì„± ----------
const planetStates = [];
for (const def of planetDefs){
  const b = def.a * Math.sqrt(1 - (def.e || 0)*(def.e || 0));

  // ì‹¤ì‚¬ ê¶¤ë„ë©´ ìƒì„±
  createOrbitPlane(def);

  // body
  const body = createBodySimple({ name:def.name, size:def.size, color:def.color });
  scene.add(body.group);

  // í† ì„± ê³ ë¦¬
  if (def.ring){
    const ringGeom = new THREE.RingGeometry((def.size*SIZE)*2.0, (def.size*SIZE)*2.8, 128);
    ringGeom.rotateX(-Math.PI/2);
    const ringMat = new THREE.MeshStandardMaterial({ color:0xd8cfae, roughness:0.9, metalness:0, transparent:true, opacity:0.7, side:THREE.DoubleSide });
    const ring = new THREE.Mesh(ringGeom, ringMat);
    body.group.add(ring);
  }

  // moons
  const moons = [];
  if (def.moons){
    for (const m of def.moons){
      const mBody = createBodySimple({ name:m.name, size:m.size, color:m.color });
      body.group.add(mBody.group);
      moons.push({ def:m, node:mBody, orbitAngle:0 });
    }
  }

  // approximate gravity radius / mass ratio (visual tuning)
  const MASS_RATIO = { 'ìˆ˜ì„±':0.055,'ê¸ˆì„±':0.815,'ì§€êµ¬':1.0,'í™”ì„±':0.107,'ëª©ì„±':317.8,'í† ì„±':95.2,'ì²œì™•ì„±':14.5,'í•´ì™•ì„±':17.1,'ëª…ì™•ì„±':0.0022 };
  const massRatio = MASS_RATIO[def.name] || 0.2;
  const MAX_MASS = 317.8;
  const gravityRadius = Math.max(20, def.a * 0.25 + (massRatio / MAX_MASS) * def.a * 2.0);

  const pstate = {
    def, node: body, moons, a: def.a, b: b, e: def.e || 0,
    orbitAngle: Math.random()*Math.PI*2, rotPeriodHours: def.rotH,
    gravityRadius, massRatio, _gravRing: null, _destroyed: false
  };

  // gravity ring (visual)
  const ringMesh = new THREE.Mesh(
    new THREE.RingGeometry(pstate.gravityRadius * 0.95, pstate.gravityRadius * 1.05, 64).rotateX(-Math.PI/2),
    new THREE.MeshBasicMaterial({ color: def.color, transparent:true, opacity:0.06, side:THREE.DoubleSide })
  );
  pstate._gravRing = ringMesh;
  scene.add(ringMesh);

  planetStates.push(pstate);
  bodies[def.name] = body.group;
}

// ---------- UI binding ----------
const speed = document.getElementById('speed');
const speedNum = document.getElementById('speedNum');
function setRate(v){ timeScale = Math.max(0, Number(v) || 0); speed.value = String(timeScale); speedNum.value = String(timeScale); }
speed.addEventListener('input', e=> setRate(e.target.value));
speedNum.addEventListener('input', e=> setRate(e.target.value));
document.querySelectorAll('.btn[data-rate]').forEach(b=> b.addEventListener('click', ()=> setRate(b.dataset.rate)));

const focusSel = document.getElementById('focusSel');
function applyFocus(){
  const v = focusSel.value;
  if (v === 'ììœ (ìˆ˜ë™)') focusTarget = null;
  else if (v === 'íƒœì–‘') focusTarget = sun;
  else focusTarget = bodies[v] || null;
  updateCam();
}
focusSel.addEventListener('change', applyFocus);

const axisToggle = document.getElementById('axisToggle');
axisToggle.addEventListener('change', ()=> axisList.forEach(ax => ax.visible = axisToggle.checked));
axisList.forEach(ax => ax.visible = true);

// ---------- mouse controls ----------
let dragging=false, px=0, py=0, button=0;
app.addEventListener('mousedown', e=>{ dragging=true; px=e.clientX; py=e.clientY; button=e.button; });
window.addEventListener('mouseup', ()=> dragging=false);
app.addEventListener('contextmenu', e=> e.preventDefault());

window.addEventListener('mousemove', e=>{
  if (!dragging) return;
  const dx = (e.clientX - px), dy = (e.clientY - py);
  if (button === 0) {
    theta -= dx * 0.005; phi -= dy * 0.005;
    const eps = 0.001; phi = Math.max(eps, Math.min(Math.PI-eps, phi));
  } else if (button === 2) {
    if (!focusTarget) {
      const s = radius * 0.0012;
      camera.updateMatrixWorld();
      const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd);
      const right = fwd.clone().cross(camera.up).normalize();
      const up = camera.up.clone().normalize();
      manualTarget.addScaledVector(right, -dx*s);
      manualTarget.addScaledVector(up, dy*s);
    }
  }
  px = e.clientX; py = e.clientY; updateCam();
});
app.addEventListener('wheel', e=>{
  e.preventDefault();
  radius *= (1 + Math.sign(e.deltaY)*0.08);
  radius = Math.max(30, Math.min(2000, radius));
  updateCam();
},{passive:false});

// ---------- Entities: ships, asteroids, explosions ----------
const ships = [];      // { mesh, vel:Vector3, ai:{mode,brain}, remove:Boolean }
const asteroids = [];  // { mesh, vel:Vector3, remove:Boolean }
const explosions = []; // { particles:[], life, age }

// raycaster + plane y=0 (pointer mapping)
const raycaster = new THREE.Raycaster();
const mouseVec = new THREE.Vector2();
const groundPlane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);

function pointerToWorld(clientX, clientY){
  const rect = renderer.domElement.getBoundingClientRect();
  mouseVec.x = ((clientX - rect.left) / rect.width) * 2 - 1;
  mouseVec.y = -((clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouseVec, camera);
  const p = new THREE.Vector3();
  raycaster.ray.intersectPlane(groundPlane, p);
  return p;
}

// spawn explosion
function spawnExplosion(position){
  const group = [];
  const particleCount = 12 + Math.floor(Math.random()*18);
  for (let i=0;i<particleCount;i++){
    const g = new THREE.SphereGeometry(0.3 + Math.random()*0.6, 6,6);
    const mat = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(0.05 + Math.random()*0.08, 0.85, 0.5), transparent:true });
    const m = new THREE.Mesh(g, mat);
    m.position.copy(position);
    m.userData.v = new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.2)*2, (Math.random()-0.5)*2);
    scene.add(m); group.push(m);
  }
  explosions.push({ particles:group, life:1.6, age:0 });
}

// spawn asteroid
function spawnAsteroidAt(pos){
  const geom = new THREE.SphereGeometry(0.6 + Math.random()*1.4, 8,8);
  const mat = new THREE.MeshStandardMaterial({ color:0x9e9e9e, roughness:1.0 });
  const m = new THREE.Mesh(geom, mat);
  m.position.copy(pos); scene.add(m);
  const vel = new THREE.Vector3((Math.random()-0.5)*0.6, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.6);
  asteroids.push({ mesh:m, vel, remove:false });
}

// spawn ship
function spawnShipAt(pos){
  const geom = new THREE.ConeGeometry(1.0, 2.4, 12);
  const mat = new THREE.MeshStandardMaterial({ color:0x66ffff, emissive:0x113344, roughness:0.4 });
  const m = new THREE.Mesh(geom, mat);
  m.rotation.x = Math.PI/2; m.position.copy(pos); scene.add(m);
  const ship = { mesh:m, vel:new THREE.Vector3(0,0,0), ai:{ mode:'idle', brain:null }, remove:false };
  ships.push(ship); return ship;
}

// UI bindings
document.getElementById('spawnAsteroidBtn').addEventListener('click', ()=>{
  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
  const pos = camera.position.clone().add(dir.multiplyScalar(radius * 0.6));
  spawnAsteroidAt(pos);
});
document.getElementById('spawnShipBtn').addEventListener('click', ()=>{
  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
  const pos = camera.position.clone().add(dir.multiplyScalar(radius * 0.6));
  spawnShipAt(pos);
});
document.getElementById('clearShipsBtn').addEventListener('click', ()=>{
  for (const s of ships) scene.remove(s.mesh); ships.length = 0;
});

// pointer spawn: left-click spawns ship (shift-click spawns asteroid)
renderer.domElement.addEventListener('pointerdown', (ev)=>{
  if (ev.button !== 0) return;
  const p = pointerToWorld(ev.clientX, ev.clientY);
  if (ev.shiftKey) spawnAsteroidAt(p);
  else spawnShipAt(p);
});

// ---------- updateEntities: gravity, collisions, explosions ----------
function updateEntities(dtSec){
  // explosions
  for (let i=explosions.length-1;i>=0;i--){
    const ex = explosions[i]; ex.age += dtSec;
    for (const p of ex.particles){
      p.position.addScaledVector(p.userData.v, dtSec*4);
      p.material.opacity = Math.max(0, 1 - ex.age/ex.life);
      p.scale.setScalar(1 + ex.age*1.5);
    }
    if (ex.age >= ex.life){
      for (const p of ex.particles) scene.remove(p);
      explosions.splice(i,1);
    }
  }

  // cache planet positions
  const planetPositions = planetStates.map(ps => {
    const pos = new THREE.Vector3();
    ps.node.group.getWorldPosition(pos);
    return { ps, pos };
  });

  // asteroids
  for (let i=asteroids.length-1;i>=0;i--){
    const a = asteroids[i];
    if (a.remove){ scene.remove(a.mesh); asteroids.splice(i,1); continue; }
    const acc = new THREE.Vector3();
    for (const {ps, pos} of planetPositions){
      if (ps._destroyed) continue;
      const rVec = pos.clone().sub(a.mesh.position);
      const dist = rVec.length();
      if (dist < ps.gravityRadius && dist > 0.1){
        const strength = (ps.massRatio / 317.8) * 600;
        const aMag = strength / (dist*dist + 1);
        acc.addScaledVector(rVec.normalize(), aMag);
        if (document.getElementById('showGravity').checked){
          a.mesh.material.emissive = new THREE.Color(ps.def.color).multiplyScalar(0.12);
        }
      }
    }
    a.vel.add(acc.multiplyScalar(dtSec));
    a.mesh.position.addScaledVector(a.vel, dtSec);

    // collision with planets (approx)
    for (const {ps, pos} of planetPositions){
      if (ps._destroyed) continue;
      const dist = pos.distanceTo(a.mesh.position);
      const approxPlanetRadius = ps.def.size * SIZE * 1.0;
      if (dist < approxPlanetRadius * 0.9 + (a.mesh.geometry.parameters.radius || 1.0)){
        if (!ps._destroyed){
          ps._destroyed = true;
          if (ps.node.group.children.length) ps.node.group.remove(ps.node.group.children[0]);
          if (ps._gravRing) scene.remove(ps._gravRing);
          spawnExplosion(pos);
        }
        a.remove = true; break;
      }
    }
    if (a.remove){ scene.remove(a.mesh); asteroids.splice(i,1); continue; }
  }

  // ships
  for (let i=ships.length-1;i>=0;i--){
    const s = ships[i];
    if (s.remove){ scene.remove(s.mesh); ships.splice(i,1); continue; }
    const acc = new THREE.Vector3();
    for (const {ps, pos} of planetPositions){
      if (ps._destroyed) continue;
      const rVec = pos.clone().sub(s.mesh.position);
      const dist = rVec.length();
      if (dist < ps.gravityRadius && dist > 0.1){
        const strength = (ps.massRatio / 317.8) * 600;
        const aMag = strength / (dist*dist + 1);
        acc.addScaledVector(rVec.normalize(), aMag);
        if (document.getElementById('showGravity').checked) s.mesh.material.emissive = new THREE.Color(ps.def.color).multiplyScalar(0.08);
      }
    }

    // AI slot (stub) - place to call TF.js / WASM model inference for RL / policy
    if (s.ai && s.ai.brain){
      // compute observation & call model -> apply thrust/turn
    }

    s.vel.add(acc.multiplyScalar(dtSec));
    s.mesh.position.addScaledVector(s.vel, dtSec);

    // orient to velocity
    const speedMag = s.vel.length();
    if (speedMag > 0.0001){
      const dir = s.vel.clone().normalize();
      const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), dir);
      s.mesh.quaternion.slerp(quat, 0.06);
    }

    // collision with planets
    for (const {ps, pos} of planetPositions){
      if (ps._destroyed) continue;
      const dist = pos.distanceTo(s.mesh.position);
      const approxPlanetRadius = ps.def.size * SIZE * 1.0;
      if (dist < approxPlanetRadius * 0.9 + 1.0){
        s.remove = true;
        spawnExplosion(pos);
        break;
      }
    }
  }

  updateCam();
}

// ---------- tick(): compute elliptical orbits with focus at sun ----------
let last = performance.now();
function tick(now){
  const dtSec = (now - last) / 1000; last = now;
  const dtDays = dtSec * timeScale;

  // sun rotation (visual)
  sun.rotation.y += dtDays * (2*Math.PI / 25.0);

  // update planets
  for (const ps of planetStates){
    if (ps._destroyed){
      ps.orbitAngle += dtDays * (2*Math.PI / Math.max(1, ps.def.orbit));
      continue;
    }

    ps.orbitAngle += dtDays * (2*Math.PI / ps.def.orbit);

    const ang = ps.orbitAngle;
    const a = ps.a, e = ps.e, b = ps.b;

    // position relative to sun (sun at origin as focus)
    const x = a * (Math.cos(ang) - e);
    const z = b * Math.sin(ang);
    // apply inclination by rotating local position around X
    const iRad = THREE.MathUtils.degToRad(ps.def.i || 0);
    // compute y from inclination: rotate (x,0,z) by iRad around X
    const pos = new THREE.Vector3(x, 0, z);
    // rotation around X: y' = z*sin(i), z' = z*cos(i)
    const y = pos.z * Math.sin(iRad);
    const z2 = pos.z * Math.cos(iRad);

    ps.node.group.position.set(pos.x, y, z2);

    // spin rotation (local)
    const rotDays = Math.abs(ps.rotPeriodHours)/24;
    const rotSgn = ps.rotPeriodHours >= 0 ? 1 : -1;
    if (rotDays > 0){
      if (ps.node.group.children[0]) ps.node.group.children[0].rotation.y += rotSgn * dtDays * (2*Math.PI / rotDays);
    }

    // position gravity ring
    if (ps._gravRing){
      ps._gravRing.position.set(pos.x, 0.01, z2);
      ps._gravRing.rotation.x = -Math.PI/2;
      ps._gravRing.visible = (document.getElementById('showGravity').checked && !ps._destroyed);
    }

    // moons (local around planet)
    for (let i=0;i<ps.moons.length;i++){
      const m = ps.moons[i];
      m.orbitAngle += dtDays * (2*Math.PI / m.def.orbit);
      const ca = Math.cos(m.orbitAngle), sa = Math.sin(m.orbitAngle);
      const mx = ca * m.def.a;
      const mz = -sa * m.def.a;
      m.node.group.position.set(mx, 0, mz);
      // moon rotation
      if (m.node.group.children[0]) m.node.group.children[0].rotation.y += dtDays * (2*Math.PI / (Math.abs(m.def.rotH || 24)/24));
    }
  }

  // update physics entities
  updateEntities(dtSec);

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

// ---------- resize ----------
addEventListener('resize', ()=>{
  const w = app.clientWidth, h = app.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
});

// ---------- initial view ----------
document.getElementById('speed').value = '2';
document.getElementById('speedNum').value = '2';
timeScale = 2;
focusSel.value = 'ì§€êµ¬';
applyFocus();
radius = 180;
updateCam();

/* Notes:
 - ê¶¤ë„ë©´ì€ ê° íƒ€ì›ì˜ ì¤‘ì‹¬ì„ (-e*a, 0)ë¡œ ì‹œí”„íŠ¸í•´ íƒœì–‘(ì›ì )ì„ ì´ˆì ìœ¼ë¡œ ë§ì·„ìŠµë‹ˆë‹¤.
 - ê¶¤ë„ë©´ì˜ ê¸°ìš¸ê¸°(i)ëŠ” mesh.rotation.xìœ¼ë¡œ ì ìš©í•´ ì‹œê°ì ìœ¼ë¡œ ê¶¤ë„ ê²½ì‚¬ë¥¼ í‘œí˜„í•©ë‹ˆë‹¤.
 - ë‹¤ìˆ˜ ì†Œí–‰ì„±/ìš°ì£¼ì„ ì´ ëŠ˜ì–´ë‚˜ë©´ InstancedMeshë¡œ ì „í™˜í•˜ë©´ ì„±ëŠ¥ í–¥ìƒë©ë‹ˆë‹¤.
 - AI ìŠ¬ë¡¯(s.ai.brain)ì— TF.js ëª¨ë¸ì„ ì—°ê²°í•˜ë©´ ë¸Œë¼ìš°ì € ë‚´ì—ì„œ ì •ì±… ì¶”ë¡ ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
*/
</script>
</body>
</html>
