<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>Three.js ë¹„ëª¨ë“¬ íƒœì–‘ê³„ + ì´ë²¤íŠ¸(ì†Œí–‰ì„±/ìš°ì£¼ì„ /ì¤‘ë ¥)</title>
<style>
  html,body{height:100%;margin:0;background:#0b1020;color:#e9ecff;font:12px/1.4 system-ui}
  #app{position:fixed; inset:0}
  canvas{display:block; width:100%; height:100%}
  .ui{
    position:fixed; left:12px; top:12px; background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.12); padding:8px 10px; border-radius:10px;
    display:flex; gap:10px; flex-wrap:wrap; align-items:center; max-width:96vw; z-index:20;
  }
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .ui label{opacity:.85}
  .btn{cursor:pointer; padding:4px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.2); background:rgba(255,255,255,.08)}
  .btn:hover{background:rgba(255,255,255,.15)}
  input[type="range"]{width:220px}
  input[type="number"]{width:60px; background:transparent; border:1px solid rgba(255,255,255,.25); color:#e9ecff; border-radius:6px; padding:2px 6px}
  select{background:transparent; color:#e9ecff; border:1px solid rgba(255,255,255,.25); border-radius:6px; padding:2px 6px}
  .hint{opacity:.65}
  .ui right { margin-left: auto; }
</style>
</head>
<body>
<div id="app"></div>

<div class="ui">
  <div class="row">
    <label for="speed">ì†ë„</label>
    <input id="speed" type="range" min="0" max="8" step="0.1" value="2">
    <input id="speedNum" type="number" min="0" max="8" step="0.1" value="2">
    <button class="btn" data-rate="1">1Ã—</button>
    <button class="btn" data-rate="2">2Ã—</button>
    <button class="btn" data-rate="3">3Ã—</button>
    <button class="btn" data-rate="4">4Ã—</button>
    <button class="btn" data-rate="5">5Ã—</button>
  </div>

  <div class="row">
    <label for="focusSel">ì¤‘ì‹¬ì </label>
    <select id="focusSel">
      <option>ììœ (ìˆ˜ë™)</option>
      <option>íƒœì–‘</option>
      <option selected>ì§€êµ¬</option>
      <option>ìˆ˜ì„±</option><option>ê¸ˆì„±</option><option>ë‹¬</option><option>í™”ì„±</option>
      <option>ëª©ì„±</option><option>í† ì„±</option><option>ì²œì™•ì„±</option><option>í•´ì™•ì„±</option>
    </select>
    <label><input id="axisToggle" type="checkbox" checked> ìì „ì¶• í‘œì‹œ</label>
    <span class="hint">â€¢ ì¢Œí´ë¦­: íšŒì „ Â· íœ : ì¤Œ Â· ìš°í´ë¦­: íŒ¬(ììœ  ëª¨ë“œ)</span>
  </div>

  <div class="row">
    <button class="btn" id="spawnAsteroidBtn">â˜„ï¸ ì†Œí–‰ì„± ì†Œí™˜ (í´ë¦­ ë˜ëŠ” ë²„íŠ¼)</button>
    <button class="btn" id="spawnShipBtn">ğŸš€ ìš°ì£¼ì„  ì†Œí™˜ (í´ë¦­ ë˜ëŠ” ë²„íŠ¼)</button>
    <button class="btn" id="clearShipsBtn">ğŸ—‘ï¸ ìš°ì£¼ì„  ì‚­ì œ</button>
    <label><input id="showGravity" type="checkbox" checked> ì¤‘ë ¥ê¶Œ ì‹œê°í™”</label>
  </div>
</div>

<!-- Three.js (UMD) -->
<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>

<script>
/* ===========================
   ê¸°ì¡´ 3D íƒœì–‘ê³„ ì½”ë“œ (ì›ë³¸ ê¸°ë°˜)
   + ì´ë²¤íŠ¸ í†µí•© (ì•„ë˜ì— ì¶”ê°€)
   ===========================*/

// ---------- renderer / scene / camera ----------
const app = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(app.clientWidth, app.clientHeight);
renderer.setClearColor(0x0b1020, 1);
app.appendChild(renderer.domElement);

const scene  = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, app.clientWidth/app.clientHeight, 0.1, 10000);

/* orbit camera (manual) */
let radius = 220, phi = THREE.MathUtils.degToRad(25), theta = THREE.MathUtils.degToRad(30);
const manualTarget = new THREE.Vector3(0,0,0);
let focusTarget = null;
function getTarget(){ return focusTarget ? focusTarget.getWorldPosition(new THREE.Vector3()) : manualTarget; }
function updateCam(){
  const t = getTarget();
  const x = t.x + radius * Math.sin(phi) * Math.cos(theta);
  const y = t.y + radius * Math.cos(phi);
  const z = t.z + radius * Math.sin(phi) * Math.sin(theta);
  camera.position.set(x,y,z);
  camera.lookAt(t);
}
updateCam();

/* lighting */
scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const sunLight = new THREE.PointLight(0xffffff, 2.6, 0, 2);
scene.add(sunLight);

/* helpers */
function orbitRing(r, color=0x2a3355){
  const g = new THREE.RingGeometry(r-0.1, r+0.1, 256); g.rotateX(-Math.PI/2);
  return new THREE.Mesh(g, new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide, transparent:true, opacity:.9 }));
}
function axisMesh(len, thick=0.06){
  const g = new THREE.CylinderGeometry(thick, thick, len, 16);
  const m = new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.7, depthWrite:false });
  const cyl = new THREE.Mesh(g, m);
  cyl.position.y = 0;
  return cyl;
}

const bodies = {};   // ì´ë¦„ => pivot
const axisList = [];

/* scale/time */
const SIZE = 1.0; // ì‹œê°ì  ìŠ¤ì¼€ì¼
const DIST = 1.0; // ê¶¤ë„ ê±°ë¦¬ ìŠ¤ì¼€ì¼
let timeScale = 2; // [ì¼/ì´ˆ]

/* Sun */
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(10*SIZE, 64, 64),
  new THREE.MeshBasicMaterial({ color: 0xffc04d })
);
scene.add(sun);
sunLight.position.copy(sun.position);

/* createBody function (ì›ë³¸ ì½”ë“œì™€ ë™ì¼ êµ¬ì¡°) */
function createBody({
  name, parent=scene, size=1, color=0xffffff,
  orbitDist=0, orbitPeriodDays=0, retrogradeOrbit=false,
  rotPeriodHours=24, axialTiltDeg=0, showOrbit=true
}={}){
  const pivot = new THREE.Group();
  parent.add(pivot);

  const spin = new THREE.Group();
  spin.rotation.z = THREE.MathUtils.degToRad(axialTiltDeg);
  pivot.add(spin);

  const mat = new THREE.MeshStandardMaterial({ color, roughness:.7, metalness:0.0 });
  const sphere = new THREE.Mesh(new THREE.SphereGeometry(size*SIZE, 32, 32), mat);
  spin.add(sphere);

  const ax = axisMesh(size*SIZE*3.0, Math.max(0.04, size*SIZE*0.08));
  spin.add(ax);
  axisList.push(ax);

  if (showOrbit && parent === scene && orbitDist>0) scene.add(orbitRing(orbitDist*DIST));

  const body = {
    name,
    pivot,
    spin,
    sphere,
    orbitDist: orbitDist*DIST,
    orbitPeriodDays,
    retrogradeOrbit,
    rotPeriodHours,
    orbitAngle: 0
  };
  bodies[name] = pivot;
  return body;
}

/* planet definitions (ì›ë³¸ ë°ì´í„° ìœ ì§€) */
const planetDefs = [
  { name:'ìˆ˜ì„±', color:0xb4b4b4, size:0.9, dist:16, orbit:87.969, rotH:1407.6, tilt:0.03, moons:[] },
  { name:'ê¸ˆì„±', color:0xd8b47d, size:1.1, dist:22, orbit:224.701, rotH:-5832.5, tilt:177.36, moons:[] },
  { name:'ì§€êµ¬', color:0x5fa8ff, size:1.2, dist:30, orbit:365.256, rotH:23.934, tilt:23.44,
    moons:[ { name:'ë‹¬', color:0xcfd6ff, size:0.35, dist:4.0, orbit:27.322, rotH:655.7, tilt:6.68 } ]
  },
  { name:'í™”ì„±', color:0xff6b6b, size:0.9, dist:38, orbit:686.980, rotH:24.623, tilt:25.19,
    moons:[ { name:'í¬ë³´ìŠ¤', color:0xaaaaaa, size:0.12, dist:2.5, orbit:0.3189, rotH:7.65, tilt:0 }, { name:'ë°ì´ëª¨ìŠ¤', color:0xcccccc, size:0.08, dist:3.2, orbit:1.263, rotH:30.3, tilt:0 } ]
  },
  { name:'ëª©ì„±', color:0xc89f68, size:4.0, dist:60, orbit:4332.589, rotH:9.925, tilt:3.13,
    moons:[ { name:'ì´ì˜¤', color:0xe6d27c, size:0.25, dist:6.0, orbit:1.769, rotH:42.46, tilt:0 }, { name:'ìœ ë¡œíŒŒ', color:0xdddddd, size:0.22, dist:7.5, orbit:3.551, rotH:85.2, tilt:0.1 }, { name:'ê°€ë‹ˆë©”ë°', color:0xd0c8b0, size:0.32, dist:9.5, orbit:7.155, rotH:171.7, tilt:0.3 }, { name:'ì¹¼ë¦¬ìŠ¤í† ', color:0x9c8f7a, size:0.29, dist:11.5, orbit:16.689, rotH:400.5, tilt:0.4 } ]
  },
  { name:'í† ì„±', color:0xd8cfae, size:3.6, dist:78, orbit:10759.22, rotH:10.656, tilt:26.73, ring:true,
    moons:[ { name:'íƒ€ì´íƒ„', color:0xcab47a, size:0.28, dist:8.0, orbit:15.945, rotH:382.7, tilt:0.3 }, { name:'ë ˆì•„', color:0xdddddd, size:0.18, dist:6.5, orbit:4.518, rotH:108.6, tilt:0 }, { name:'ì—”ì…€ë¼ë‘ìŠ¤', color:0xf1f8ff, size:0.12, dist:5.5, orbit:1.370, rotH:32.9, tilt:0 }, { name:'ì´ì•„í˜íˆ¬ìŠ¤', color:0x888888, size:0.16, dist:11.5, orbit:79.32, rotH:1903, tilt:0 } ]
  },
  { name:'ì²œì™•ì„±', color:0x9bd7ff, size:2.9, dist:96, orbit:30688.5, rotH:-17.24, tilt:97.77,
    moons:[ { name:'í‹°íƒ€ë‹ˆì•„', color:0xcccccc, size:0.18, dist:6.0, orbit:8.706, rotH:208.9, tilt:0 }, { name:'ì˜¤ë²„ë¡ ', color:0xbfbfbf, size:0.17, dist:7.0, orbit:13.463, rotH:323.1, tilt:0 } ]
  },
  { name:'í•´ì™•ì„±', color:0x6aa7ff, size:2.8, dist:112, orbit:60182.0, rotH:16.11, tilt:28.32,
    moons:[ { name:'íŠ¸ë¦¬í†¤', color:0xcfd6ff, size:0.22, dist:6.5, orbit:5.877, rotH:141.0, tilt:0, retrogradeOrbit:true } ]
  }
];

/* create planets and moons (ì›ë³¸ ë¡œì§ ìœ ì§€) */
const planetStates = [];
for (const p of planetDefs) {
  let ring=null;
  if (p.ring){
    const g = new THREE.RingGeometry((p.size*SIZE)*2.0, (p.size*SIZE)*2.8, 128);
    g.rotateX(-Math.PI/2);
    ring = new THREE.Mesh(g, new THREE.MeshStandardMaterial({ color:0xd8cfae, roughness:.9, metalness:0, transparent:true, opacity:.7, side:THREE.DoubleSide }));
  }

  const plan = createBody({
    name:p.name, size:p.size, color:p.color,
    orbitDist:p.dist, orbitPeriodDays:p.orbit,
    rotPeriodHours:p.rotH, axialTiltDeg:p.tilt,
    showOrbit:true
  });
  if (ring) plan.pivot.add(ring);

  const moons = [];
  for (const m of (p.moons||[])) {
    const moon = createBody({
      name:m.name, parent: plan.pivot, size:m.size, color:m.color,
      orbitDist:m.dist, orbitPeriodDays:m.orbit, retrogradeOrbit:m.retrogradeOrbit||false,
      rotPeriodHours:m.rotH, axialTiltDeg:m.tilt, showOrbit:false
    });
    moons.push(moon);
  }

  planetStates.push({def:p, node:plan, moons});
}

/* UI ë°”ì¸ë”© (ì›ë³¸) */
const speed = document.getElementById('speed');
const speedNum = document.getElementById('speedNum');
function setRate(v){ timeScale = Math.max(0, Number(v) || 0); speed.value = String(timeScale); speedNum.value = String(timeScale); }
speed.addEventListener('input', e=> setRate(e.target.value));
speedNum.addEventListener('input', e=> setRate(e.target.value));
document.querySelectorAll('.btn[data-rate]').forEach(b=>{ b.addEventListener('click', ()=> setRate(b.dataset.rate)); });

const focusSel = document.getElementById('focusSel');
function applyFocus(){
  const v = focusSel.value;
  if (v === 'ììœ (ìˆ˜ë™)')      focusTarget = null;
  else if (v === 'íƒœì–‘')      focusTarget = sun;
  else                        focusTarget = bodies[v] || null;
  updateCam();
}
focusSel.addEventListener('change', applyFocus);

const axisToggle = document.getElementById('axisToggle');
axisToggle.addEventListener('change', ()=> axisList.forEach(ax => ax.visible = axisToggle.checked));
axisList.forEach(ax => ax.visible = true);

/* mouse controls (ì›ë³¸) */
let dragging=false, px=0, py=0, button=0;
app.addEventListener('mousedown', e=>{ dragging=true; px=e.clientX; py=e.clientY; button=e.button; });
window.addEventListener('mouseup',   ()=> dragging=false);
app.addEventListener('contextmenu', e=> e.preventDefault());

window.addEventListener('mousemove', e=>{
  if(!dragging) return;
  const dx = (e.clientX - px), dy = (e.clientY - py);
  if (button === 0) { theta -= dx * 0.005; phi   -= dy * 0.005; const eps = 0.001; phi = Math.max(eps, Math.min(Math.PI-eps, phi)); }
  else if (button === 2) { if (!focusTarget) { const s = radius * 0.0012; camera.updateMatrixWorld(); const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); const right = fwd.clone().cross(camera.up).normalize(); const up = camera.up.clone().normalize(); manualTarget.addScaledVector(right, -dx*s); manualTarget.addScaledVector(up,     dy*s); } }
  px = e.clientX; py = e.clientY; updateCam();
});

// zoom
app.addEventListener('wheel', e=>{ e.preventDefault(); radius *= (1 + Math.sign(e.deltaY)*0.08); radius = Math.max(30, Math.min(2000, radius)); updateCam(); },{passive:false});

/* animation tick (ì›ë³¸) */
let last = performance.now();
function tick(now){
  const dtSec  = (now - last)/1000; last = now;
  const dtDays = dtSec * timeScale;

  sun.rotation.y += dtDays * (2*Math.PI / 25.0);

  for (const P of planetStates){
    const {def, node, moons} = P;
    if (node.orbitPeriodDays > 0) {
      const sgn = node.retrogradeOrbit ? -1 : 1;
      node.orbitAngle += sgn * dtDays * (2*Math.PI / node.orbitPeriodDays);
      const ca = Math.cos(node.orbitAngle), sa = Math.sin(node.orbitAngle);
      node.pivot.position.set(ca*node.orbitDist, 0, -sa*node.orbitDist);
    }
    const rotDays = Math.abs(node.rotPeriodHours)/24;
    const rotSgn  = node.rotPeriodHours>=0 ? 1 : -1;
    if (rotDays>0) node.spin.rotation.y += rotSgn * dtDays * (2*Math.PI / rotDays);

    for (let i=0;i<moons.length;i++){
      const mNode = moons[i]; const mDef  = def.moons[i];
      if (mNode.orbitPeriodDays > 0) {
        const mSgn = (mDef && mDef.retrogradeOrbit) ? -1 : 1;
        mNode.orbitAngle += mSgn * dtDays * (2*Math.PI / mNode.orbitPeriodDays);
        const ca = Math.cos(mNode.orbitAngle), sa = Math.sin(mNode.orbitAngle);
        mNode.pivot.position.set(ca*mNode.orbitDist, 0, -sa*mNode.orbitDist);
      }
      const mRotDays = Math.abs(mNode.rotPeriodHours)/24;
      const mRotSgn  = mNode.rotPeriodHours>=0 ? 1 : -1;
      if (mRotDays>0) mNode.spin.rotation.y += mRotSgn * dtDays * (2*Math.PI / mRotDays);
    }
  }

  // --- ì—¬ê¸°ì„œ ì´í›„ì— ì´ë²¤íŠ¸ìš© ì—…ë°ì´íŠ¸ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤ (ì•„ë˜ì—ì„œ ì •ì˜) ---
  updateEntities(dtSec);

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* resize */
addEventListener('resize', ()=>{
  const w = app.clientWidth, h = app.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
});

/* initial view */
document.getElementById('speed').value = '2';
document.getElementById('speedNum').value = '2';
timeScale = 2; focusSel.value = 'ì§€êµ¬'; applyFocus();
radius = 180; updateCam();

/* ===========================
   ì´ë²¤íŠ¸ í†µí•© ì½”ë“œ ì‹œì‘
   - ì†Œí–‰ì„± / ìš°ì£¼ì„  ê´€ë¦¬
   - ì¶©ëŒ, ì¤‘ë ¥ ì ìš© (í–‰ì„±ë³„ ì‹¤ì œ ë¹„ìœ¨ ê¸°ë°˜)
   - í´ë¦­ ìœ„ì¹˜ë¡œ ì†Œí™˜ (Raycast â†’ í‰ë©´ y=0 êµì°¨)
   - ê°„ë‹¨ í­ë°œ ì´í™íŠ¸
   ===========================*/

// ---------- ì„¤ì •: ì§ˆëŸ‰ë¹„ ë° ì¤‘ë ¥ ë°˜ê²½ ë§µ (ì‹¤ì œ ë¹„ìœ¨ ê¸°ë°˜ ê·¼ì‚¬) ----------
const MASS_RATIO = {
  'ìˆ˜ì„±': 0.055,
  'ê¸ˆì„±': 0.815,
  'ì§€êµ¬': 1.000,
  'í™”ì„±': 0.107,
  'ëª©ì„±': 317.8,
  'í† ì„±': 95.2,
  'ì²œì™•ì„±': 14.5,
  'í•´ì™•ì„±': 17.1
};
// ì¤‘ë ¥ ë°˜ê²½ì˜ ì°¸ì¡° ìµœëŒ€ê°’(ì¥ë©´ ë‹¨ìœ„ì—ì„œ ê°€ì‹œí™” ëª©ì )
const GRAVITY_BASE = 40; // ê¸°ì´ˆê°’
const MAX_MASS = 317.8;  // ëª©ì„± ê¸°ì¤€

// entity ì €ì¥ì†Œ
const ships = [];      // { mesh, vel:Vector3, ai:{mode,brain}, remove:Boolean }
const asteroids = [];  // { mesh, vel:Vector3, remove:Boolean }
const explosions = []; // { particles:Mesh[], life, age }

// raycaster + plane for click -> world
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
// plane at y=0
const groundPlane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);

// toggle visuals
const showGravityCheckbox = document.getElementById('showGravity');

// helper: world position from pointer (intersection with y=0 plane)
function pointerToWorld(clientX, clientY){
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersectPoint = new THREE.Vector3();
  raycaster.ray.intersectPlane(groundPlane, intersectPoint);
  return intersectPoint;
}

// helper: create simple explosion (expanding sprites -> represented as small spheres here)
function spawnExplosion(position){
  const group = [];
  const particleCount = 16 + Math.floor(Math.random()*16);
  for (let i=0;i<particleCount;i++){
    const g = new THREE.SphereGeometry(0.3 + Math.random()*0.6, 6,6);
    const c = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(0.08 + Math.random()*0.08, 0.9, 0.5), transparent:true });
    const m = new THREE.Mesh(g, c);
    m.position.copy(position);
    // random initial velocity
    m.userData.v = new THREE.Vector3((Math.random()-0.5)*2, (Math.random()-0.2)*2, (Math.random()-0.5)*2);
    scene.add(m);
    group.push(m);
  }
  explosions.push({ particles: group, life: 1.6, age:0 });
}

// compute gravity radius for a planet node (scene units)
// we derive from planet's orbitDist and mass ratio to produce a reasonably scaled zone
function computeGravityRadius(def){
  const mass = MASS_RATIO[def.name] || 0.2;
  // base on orbit distance and mass: ensures big planets have larger zones beyond their orbitDist scale
  const r = Math.max( (def.size || 1.0) * 3.0, def.dist * 0.25 + (mass / MAX_MASS) * def.dist * 2.0, GRAVITY_BASE * (mass / 1.0) * 0.02 );
  return r;
}

// attach gravity info to each planetState for faster access
for (const pstate of planetStates){
  const name = pstate.def.name;
  pstate.massRatio = MASS_RATIO[name] || 0.2;
  pstate.gravityRadius = computeGravityRadius(pstate.def); // scene units
  // for visualization:create a ring mesh (slightly transparent)
  pstate._gravRing = new THREE.Mesh(
    new THREE.RingGeometry(pstate.gravityRadius*0.95, pstate.gravityRadius*1.05, 64).rotateX(-Math.PI/2),
    new THREE.MeshBasicMaterial({ color: pstate.def.color, transparent:true, opacity:0.08, side:THREE.DoubleSide })
  );
  // place ring on planet pivot (so it follows planet)
  pstate.node.pivot.add(pstate._gravRing);
}

// ---------- spawn functions ----------
function spawnAsteroidAt(pos){
  const geom = new THREE.SphereGeometry(0.8 + Math.random()*1.6, 8, 8);
  const mat = new THREE.MeshStandardMaterial({ color:0x9e9e9e, roughness:1.0 });
  const mesh = new THREE.Mesh(geom, mat);
  mesh.position.copy(pos);
  mesh.castShadow = false;
  scene.add(mesh);
  const vel = new THREE.Vector3((Math.random()-0.5)*0.6, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.6);
  asteroids.push({ mesh, vel, remove:false });
}

function spawnShipAt(pos){
  const geom = new THREE.ConeGeometry(1.0, 2.4, 12);
  const mat = new THREE.MeshStandardMaterial({ color:0x66ffff, emissive:0x113344, roughness:0.4 });
  const mesh = new THREE.Mesh(geom, mat);
  mesh.rotation.x = Math.PI/2;
  mesh.position.copy(pos);
  scene.add(mesh);
  const vel = new THREE.Vector3(0,0,0); // ì •ì§€ ìƒíƒœë¡œ ìƒì„± (ìš”ì²­)
  const ship = { mesh, vel, ai:{ mode:'idle', brain:null }, remove:false };
  ships.push(ship);
  return ship;
}

// UI event binding: buttons and mouse clicks
document.getElementById('spawnAsteroidBtn').addEventListener('click', ()=>{
  // spawn in front of camera a bit
  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
  const pos = camera.position.clone().add(dir.multiplyScalar(radius*0.5));
  spawnAsteroidAt(pos);
});
document.getElementById('spawnShipBtn').addEventListener('click', ()=>{
  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
  const pos = camera.position.clone().add(dir.multiplyScalar(radius*0.5));
  spawnShipAt(pos);
});
document.getElementById('clearShipsBtn').addEventListener('click', ()=>{
  for (const s of ships) scene.remove(s.mesh);
  ships.length = 0;
});

// click in scene: spawn ship or asteroid depending on modifier keys
renderer.domElement.addEventListener('pointerdown', (ev)=>{
  if (ev.button !== 0) return; // left only
  const pos = pointerToWorld(ev.clientX, ev.clientY);
  if (ev.shiftKey) spawnAsteroidAt(pos); // shift+click => asteroid
  else spawnShipAt(pos); // click => ship
});

// ---------- physics/update for entities ----------
function updateEntities(dtSec){
  // update explosions
  for (let i=explosions.length-1;i>=0;i--){
    const ex = explosions[i];
    ex.age += dtSec;
    // particles move outward & fade
    for (const p of ex.particles){
      p.position.addScaledVector(p.userData.v, dtSec*6);
      p.material.opacity = Math.max(0, 1 - ex.age/ex.life);
      p.scale.setScalar(1 + ex.age*1.5);
    }
    if (ex.age >= ex.life){
      for (const p of ex.particles) scene.remove(p);
      explosions.splice(i,1);
    }
  }

  // helper: find planet world positions once per frame (cache)
  const planetPositions = planetStates.map(ps => {
    const pos = new THREE.Vector3();
    ps.node.pivot.getWorldPosition(pos);
    return { ps, pos };
  });

  // --- asteroids physics ---
  for (let i=asteroids.length-1;i>=0;i--){
    const a = asteroids[i];
    if (a.remove) { scene.remove(a.mesh); asteroids.splice(i,1); continue; }

    // gravity from planets: accumulate acceleration
    const acc = new THREE.Vector3(0,0,0);
    for (const {ps, pos} of planetPositions){
      if (ps.node === undefined || ps.node === null) continue;
      const rVec = pos.clone().sub(a.mesh.position);
      const dist = rVec.length();
      // if inside gravity radius, apply attraction
      if (dist < ps.gravityRadius && dist > 0.1){
        // visual tuned acceleration: proportional to mass ratio and inverse-square-ish
        const strength = (ps.massRatio / MAX_MASS) * 300; // tuned factor
        const aMag = strength / (dist * dist + 1); // avoid inf
        acc.addScaledVector(rVec.normalize(), aMag);
        // highlight when inside gravity zone
        if (showGravityCheckbox.checked){
          a.mesh.material.emissive = new THREE.Color(ps.def.color).multiplyScalar(0.12);
        }
      }
    }

    // integrate (simple euler)
    a.vel.add(acc.multiplyScalar(dtSec));
    a.mesh.position.addScaledVector(a.vel, dtSec);

    // check collisions with planets
    for (const {ps, pos} of planetPositions){
      const dist = pos.distanceTo(a.mesh.position);
      const planetRadius = ps.node.spin.children.find(c => c.geometry && c.geometry.parameters).geometry ? ps.node.spin.children[0].geometry.parameters.radius * SIZE : (ps.def.size*SIZE);
      // use visible sphere size approximation:
      const approxPlanetRadius = ps.node.spin.children[0].geometry.parameters.radius * SIZE || (ps.def.size*SIZE);
      if (dist < approxPlanetRadius * 0.9 + (a.mesh.geometry.parameters.radius || 1.0)){
        // impact: destroy planet (mark and remove visuals) and spawn explosion
        // we will remove the planet's mesh (spin.children[0]) and its pivot ring etc.
        // mark destroyed:
        if (!ps._destroyed){
          ps._destroyed = true;
          // remove visual sphere + axis
          if (ps.node.spin && ps.node.spin.children[0]) ps.node.spin.remove(ps.node.spin.children[0]);
          if (ps._gravRing) ps.node.pivot.remove(ps._gravRing);
          spawnExplosion(pos);
        }
        // remove asteroid
        a.remove = true;
        break;
      }
    }
    if (a.remove){ scene.remove(a.mesh); asteroids.splice(i,1); continue; }
  }

  // --- ships physics ---
  for (let i=ships.length-1;i>=0;i--){
    const s = ships[i];
    if (s.remove){ scene.remove(s.mesh); ships.splice(i,1); continue; }

    // gravity similar to asteroids
    const acc = new THREE.Vector3(0,0,0);
    for (const {ps, pos} of planetPositions){
      const rVec = pos.clone().sub(s.mesh.position);
      const dist = rVec.length();
      if (dist < ps.gravityRadius && dist > 0.1){
        const strength = (ps.massRatio / MAX_MASS) * 300;
        const aMag = strength / (dist * dist + 1);
        acc.addScaledVector(rVec.normalize(), aMag);
        if (showGravityCheckbox.checked) s.mesh.material.emissive = new THREE.Color(ps.def.color).multiplyScalar(0.1);
      }
    }
    // AI slot (stub) - place to call inference if brain is loaded
    if (s.ai && s.ai.brain){
      // ì˜ˆ: s.ai.brain.predict(...) -> apply thrust/acc
      // í˜„ì¬ëŠ” ìŠ¤í…: no-op
    }

    // integrate velocity and position
    s.vel.add(acc.multiplyScalar(dtSec));
    s.mesh.position.addScaledVector(s.vel, dtSec);

    // rotate ship to heading (for visual)
    const speedMag = s.vel.length();
    if (speedMag > 0.0001){
      const dir = s.vel.clone().normalize();
      const quat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), dir);
      s.mesh.quaternion.slerp(quat, 0.06);
    }

    // collision with planets: if too close -> destroy ship and spawn explosion
    for (const {ps, pos} of planetPositions){
      const dist = pos.distanceTo(s.mesh.position);
      const approxPlanetRadius = ps.node.spin.children[0] && ps.node.spin.children[0].geometry ? ps.node.spin.children[0].geometry.parameters.radius * SIZE : (ps.def.size*SIZE);
      if (dist < approxPlanetRadius * 0.9 + 1.0){
        s.remove = true;
        spawnExplosion(pos);
        break;
      }
    }
  }

  // camera focus update (if focusTarget is dynamic, ensure updateCam uses its world pos)
  updateCam();
}

/* ========== garbage/perf note ===========
 - ë‹¤ìˆ˜ì˜ ì†Œí–‰ì„± ì‚¬ìš© ì‹œ InstancedMeshë¡œ ì „í™˜ ê¶Œì¥ (ì„±ëŠ¥ ëŒ€í­ í–¥ìƒ)
 - í­ë°œ íŒŒí‹°í´ì€ ë‹¨ìˆœ ë©”ì‰¬ë¡œ êµ¬í˜„í–ˆìœ¼ë¯€ë¡œ ë§ì€ íŒŒí‹°í´ ì‚¬ìš© ì‹œ FPS í•˜ë½ ê°€ëŠ¥
========================================== */

</script>
</body>
</html>

